
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 50 e3 00 00       	call   80e381 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 74 a4 00 00       	call   80a4bc <thread_wakeup>
  800048:	83 c4 10             	add    $0x10,%esp
}
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 bd a4 00 00       	call   80a52a <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	79 1b                	jns    80008f <start_timer+0x42>
		panic("cannot create timer thread: %s", e2s(r));
  800074:	83 ec 0c             	sub    $0xc,%esp
  800077:	50                   	push   %eax
  800078:	e8 dc a7 00 00       	call   80a859 <e2s>
  80007d:	50                   	push   %eax
  80007e:	68 80 0c 81 00       	push   $0x810c80
  800083:	6a 7a                	push   $0x7a
  800085:	68 b5 0d 81 00       	push   $0x810db5
  80008a:	e8 52 e3 00 00       	call   80e3e1 <_panic>
}
  80008f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800092:	c9                   	leave  
  800093:	c3                   	ret    

00800094 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi

	for (;;) {
		uint32_t cur = sys_time_msec();
  80009c:	e8 9a ef 00 00       	call   80f03b <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx

		lwip_core_lock();
  8000a3:	e8 db a3 00 00       	call   80a483 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 d8 a3 00 00       	call   80a488 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 14 a6 00 00       	call   80a6d3 <thread_wait>
	}
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 0b 01 00 00    	ja     8001e7 <serve_thread+0x123>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 60 0e 81 00 	jmp    *0x810e60(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 af 0d 00 00       	call   800eac <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 c5 ea 00 00       	call   80ebd3 <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
  800111:	e9 ec 00 00 00       	jmp    800202 <serve_thread+0x13e>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800116:	83 ec 04             	sub    $0x4,%esp
  800119:	ff 76 14             	pushl  0x14(%esi)
  80011c:	8d 46 04             	lea    0x4(%esi),%eax
  80011f:	50                   	push   %eax
  800120:	ff 36                	pushl  (%esi)
  800122:	e8 34 0f 00 00       	call   80105b <lwip_bind>
  800127:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  800129:	83 c4 10             	add    $0x10,%esp
  80012c:	e9 d1 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800131:	83 ec 08             	sub    $0x8,%esp
  800134:	ff 76 04             	pushl  0x4(%esi)
  800137:	ff 36                	pushl  (%esi)
  800139:	e8 2b 1a 00 00       	call   801b69 <lwip_shutdown>
  80013e:	89 c7                	mov    %eax,%edi
		break;
  800140:	83 c4 10             	add    $0x10,%esp
  800143:	e9 ba 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800148:	83 ec 0c             	sub    $0xc,%esp
  80014b:	ff 36                	pushl  (%esi)
  80014d:	e8 bf 0f 00 00       	call   801111 <lwip_close>
  800152:	89 c7                	mov    %eax,%edi
		break;
  800154:	83 c4 10             	add    $0x10,%esp
  800157:	e9 a6 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80015c:	83 ec 04             	sub    $0x4,%esp
  80015f:	ff 76 14             	pushl  0x14(%esi)
  800162:	8d 46 04             	lea    0x4(%esi),%eax
  800165:	50                   	push   %eax
  800166:	ff 36                	pushl  (%esi)
  800168:	e8 2d 10 00 00       	call   80119a <lwip_connect>
  80016d:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  80016f:	83 c4 10             	add    $0x10,%esp
  800172:	e9 8b 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  800177:	83 ec 08             	sub    $0x8,%esp
  80017a:	ff 76 04             	pushl  0x4(%esi)
  80017d:	ff 36                	pushl  (%esi)
  80017f:	e8 cc 10 00 00       	call   801250 <lwip_listen>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	83 c4 10             	add    $0x10,%esp
  800189:	eb 77                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80018b:	ff 76 08             	pushl  0x8(%esi)
  80018e:	ff 76 04             	pushl  0x4(%esi)
  800191:	56                   	push   %esi
  800192:	ff 36                	pushl  (%esi)
  800194:	e8 8a 13 00 00       	call   801523 <lwip_recv>
  800199:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  80019b:	83 c4 10             	add    $0x10,%esp
  80019e:	eb 62                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001a0:	ff 76 08             	pushl  0x8(%esi)
  8001a3:	ff 76 04             	pushl  0x4(%esi)
  8001a6:	8d 46 0c             	lea    0xc(%esi),%eax
  8001a9:	50                   	push   %eax
  8001aa:	ff 36                	pushl  (%esi)
  8001ac:	e8 df 14 00 00       	call   801690 <lwip_send>
  8001b1:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  8001b3:	83 c4 10             	add    $0x10,%esp
  8001b6:	eb 4a                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001b8:	83 ec 04             	sub    $0x4,%esp
  8001bb:	ff 76 08             	pushl  0x8(%esi)
  8001be:	ff 76 04             	pushl  0x4(%esi)
  8001c1:	ff 36                	pushl  (%esi)
  8001c3:	e8 5b 15 00 00       	call   801723 <lwip_socket>
  8001c8:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  8001ca:	83 c4 10             	add    $0x10,%esp
  8001cd:	eb 33                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  8001cf:	83 ec 08             	sub    $0x8,%esp
  8001d2:	56                   	push   %esi
  8001d3:	68 40 b3 b3 00       	push   $0xb3b340
  8001d8:	e8 6b a7 00 00       	call   80a948 <jif_input>
		r = 0;
		break;
  8001dd:	83 c4 10             	add    $0x10,%esp
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
				req->socket.req_protocol);
		break;
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
  8001e0:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  8001e5:	eb 3d                	jmp    800224 <serve_thread+0x160>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  8001e7:	83 ec 04             	sub    $0x4,%esp
  8001ea:	56                   	push   %esi
  8001eb:	ff 73 04             	pushl  0x4(%ebx)
  8001ee:	68 a0 0c 81 00       	push   $0x810ca0
  8001f3:	e8 c2 e2 00 00       	call   80e4ba <cprintf>
		r = -E_INVAL;
		break;
  8001f8:	83 c4 10             	add    $0x10,%esp
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
		break;
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
  8001fb:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800200:	eb 22                	jmp    800224 <serve_thread+0x160>
	}

	if (r == -1) {
  800202:	83 ff ff             	cmp    $0xffffffff,%edi
  800205:	75 1d                	jne    800224 <serve_thread+0x160>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800207:	ff 33                	pushl  (%ebx)
  800209:	68 c0 0d 81 00       	push   $0x810dc0
  80020e:	6a 64                	push   $0x64
  800210:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800213:	56                   	push   %esi
  800214:	e8 d5 e7 00 00       	call   80e9ee <snprintf>
		perror(buf);
  800219:	89 34 24             	mov    %esi,(%esp)
  80021c:	e8 14 a6 00 00       	call   80a835 <perror>
  800221:	83 c4 10             	add    $0x10,%esp
	}

	if (args->reqno != NSREQ_INPUT)
  800224:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800227:	74 10                	je     800239 <serve_thread+0x175>
		ipc_send(args->whom, r, 0, 0);
  800229:	6a 00                	push   $0x0
  80022b:	6a 00                	push   $0x0
  80022d:	57                   	push   %edi
  80022e:	ff 73 04             	pushl  0x4(%ebx)
  800231:	e8 13 f2 00 00       	call   80f449 <ipc_send>
  800236:	83 c4 10             	add    $0x10,%esp

	put_buffer(args->req);
  800239:	8b 53 08             	mov    0x8(%ebx),%edx
	return va;
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  80023c:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800242:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  800245:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  80024c:	83 ec 08             	sub    $0x8,%esp
  80024f:	52                   	push   %edx
  800250:	6a 00                	push   $0x0
  800252:	e8 78 ec 00 00       	call   80eecf <sys_page_unmap>
	free(args);
  800257:	89 1c 24             	mov    %ebx,(%esp)
  80025a:	e8 1d ff 00 00       	call   81017c <free>
}
  80025f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800262:	5b                   	pop    %ebx
  800263:	5e                   	pop    %esi
  800264:	5f                   	pop    %edi
  800265:	5d                   	pop    %ebp
  800266:	c3                   	ret    

00800267 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800267:	55                   	push   %ebp
  800268:	89 e5                	mov    %esp,%ebp
  80026a:	56                   	push   %esi
  80026b:	53                   	push   %ebx
  80026c:	83 ec 10             	sub    $0x10,%esp
  80026f:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800272:	e8 0c a2 00 00       	call   80a483 <lwip_core_lock>

	uint32_t done = 0;
  800277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80027e:	83 ec 08             	sub    $0x8,%esp
  800281:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800284:	53                   	push   %ebx
  800285:	68 33 00 80 00       	push   $0x800033
  80028a:	e8 98 21 00 00       	call   802427 <tcpip_init>
	lwip_core_unlock();
  80028f:	e8 f4 a1 00 00       	call   80a488 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  800294:	83 c4 0c             	add    $0xc,%esp
  800297:	6a ff                	push   $0xffffffff
  800299:	6a 00                	push   $0x0
  80029b:	53                   	push   %ebx
  80029c:	e8 32 a4 00 00       	call   80a6d3 <thread_wait>
	lwip_core_lock();
  8002a1:	e8 dd a1 00 00       	call   80a483 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8002a6:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002af:	8b 45 10             	mov    0x10(%ebp),%eax
  8002b2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002b5:	83 c4 0c             	add    $0xc,%esp
  8002b8:	68 d6 64 80 00       	push   $0x8064d6
  8002bd:	68 3c aa 80 00       	push   $0x80aa3c
  8002c2:	68 14 50 81 00       	push   $0x815014
  8002c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002ca:	50                   	push   %eax
  8002cb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002ce:	50                   	push   %eax
  8002cf:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002d2:	50                   	push   %eax
  8002d3:	68 40 b3 b3 00       	push   $0xb3b340
  8002d8:	e8 27 43 00 00       	call   804604 <netif_add>
  8002dd:	83 c4 20             	add    $0x20,%esp
  8002e0:	85 c0                	test   %eax,%eax
  8002e2:	75 14                	jne    8002f8 <serve_init+0x91>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  8002e4:	83 ec 04             	sub    $0x4,%esp
  8002e7:	68 c4 0c 81 00       	push   $0x810cc4
  8002ec:	6a 5c                	push   $0x5c
  8002ee:	68 b5 0d 81 00       	push   $0x810db5
  8002f3:	e8 e9 e0 00 00       	call   80e3e1 <_panic>

	netif_set_default(nif);
  8002f8:	83 ec 0c             	sub    $0xc,%esp
  8002fb:	68 40 b3 b3 00       	push   $0xb3b340
  800300:	e8 b5 43 00 00       	call   8046ba <netif_set_default>
	netif_set_up(nif);
  800305:	c7 04 24 40 b3 b3 00 	movl   $0xb3b340,(%esp)
  80030c:	e8 b6 43 00 00       	call   8046c7 <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800311:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800318:	b9 cf 0d 81 00       	mov    $0x810dcf,%ecx
  80031d:	ba fe 93 80 00       	mov    $0x8093fe,%edx
  800322:	b8 38 50 81 00       	mov    $0x815038,%eax
  800327:	e8 21 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80032c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800333:	b9 d9 0d 81 00       	mov    $0x810dd9,%ecx
  800338:	ba ce 56 80 00       	mov    $0x8056ce,%edx
  80033d:	b8 2c 50 81 00       	mov    $0x81502c,%eax
  800342:	e8 06 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800347:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80034e:	b9 e5 0d 81 00       	mov    $0x810de5,%ecx
  800353:	ba 74 5c 80 00       	mov    $0x805c74,%edx
  800358:	b8 20 50 81 00       	mov    $0x815020,%eax
  80035d:	e8 eb fc ff ff       	call   80004d <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800362:	89 34 24             	mov    %esi,(%esp)
  800365:	e8 48 72 00 00       	call   8075b2 <inet_ntoa>
  80036a:	50                   	push   %eax
  80036b:	0f b6 05 6a b3 b3 00 	movzbl 0xb3b36a,%eax
  800372:	50                   	push   %eax
  800373:	0f b6 05 69 b3 b3 00 	movzbl 0xb3b369,%eax
  80037a:	50                   	push   %eax
  80037b:	0f b6 05 68 b3 b3 00 	movzbl 0xb3b368,%eax
  800382:	50                   	push   %eax
  800383:	0f b6 05 67 b3 b3 00 	movzbl 0xb3b367,%eax
  80038a:	50                   	push   %eax
  80038b:	0f b6 05 66 b3 b3 00 	movzbl 0xb3b366,%eax
  800392:	50                   	push   %eax
  800393:	0f b6 05 65 b3 b3 00 	movzbl 0xb3b365,%eax
  80039a:	50                   	push   %eax
  80039b:	68 e4 0c 81 00       	push   $0x810ce4
  8003a0:	e8 15 e1 00 00       	call   80e4ba <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8003a5:	83 c4 30             	add    $0x30,%esp
  8003a8:	e8 db a0 00 00       	call   80a488 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  8003ad:	83 ec 0c             	sub    $0xc,%esp
  8003b0:	68 f1 0d 81 00       	push   $0x810df1
  8003b5:	e8 00 e1 00 00       	call   80e4ba <cprintf>
  8003ba:	83 c4 10             	add    $0x10,%esp
}
  8003bd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c0:	5b                   	pop    %ebx
  8003c1:	5e                   	pop    %esi
  8003c2:	5d                   	pop    %ebp
  8003c3:	c3                   	ret    

008003c4 <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  8003c4:	55                   	push   %ebp
  8003c5:	89 e5                	mov    %esp,%ebp
  8003c7:	57                   	push   %edi
  8003c8:	56                   	push   %esi
  8003c9:	53                   	push   %ebx
  8003ca:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003cd:	8d 7d e0             	lea    -0x20(%ebp),%edi

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003d0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8003d5:	eb 08                	jmp    8003df <serve+0x1b>
			thread_yield();
  8003d7:	e8 74 a2 00 00       	call   80a650 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003dc:	83 c3 01             	add    $0x1,%ebx
  8003df:	e8 f7 a0 00 00       	call   80a4db <thread_wakeups_pending>
  8003e4:	85 c0                	test   %eax,%eax
  8003e6:	74 05                	je     8003ed <serve+0x29>
  8003e8:	83 fb 1f             	cmp    $0x1f,%ebx
  8003eb:	7e ea                	jle    8003d7 <serve+0x13>
			thread_yield();

		perm = 0;
  8003ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f4:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003f9:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800400:	74 0a                	je     80040c <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800402:	83 c0 01             	add    $0x1,%eax
  800405:	83 f8 14             	cmp    $0x14,%eax
  800408:	75 ef                	jne    8003f9 <serve+0x35>
  80040a:	eb 05                	jmp    800411 <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  80040c:	83 f8 14             	cmp    $0x14,%eax
  80040f:	75 14                	jne    800425 <serve+0x61>
		panic("NS: buffer overflow");
  800411:	83 ec 04             	sub    $0x4,%esp
  800414:	68 0a 0e 81 00       	push   $0x810e0a
  800419:	6a 3f                	push   $0x3f
  80041b:	68 b5 0d 81 00       	push   $0x810db5
  800420:	e8 bc df 00 00       	call   80e3e1 <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  800425:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80042b:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042e:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800435:	83 ec 04             	sub    $0x4,%esp
  800438:	57                   	push   %edi
  800439:	53                   	push   %ebx
  80043a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043d:	50                   	push   %eax
  80043e:	e8 9d ef 00 00       	call   80f3e0 <ipc_recv>
  800443:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800445:	83 c4 10             	add    $0x10,%esp
  800448:	83 f8 0c             	cmp    $0xc,%eax
  80044b:	75 60                	jne    8004ad <serve+0xe9>
			process_timer(whom);
  80044d:	8b 45 e4             	mov    -0x1c(%ebp),%eax

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800450:	8b 35 1c 50 81 00    	mov    0x81501c,%esi
  800456:	39 c6                	cmp    %eax,%esi
  800458:	74 13                	je     80046d <serve+0xa9>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80045a:	83 ec 08             	sub    $0x8,%esp
  80045d:	50                   	push   %eax
  80045e:	68 20 0d 81 00       	push   $0x810d20
  800463:	e8 52 e0 00 00       	call   80e4ba <cprintf>
  800468:	83 c4 10             	add    $0x10,%esp
  80046b:	eb 2b                	jmp    800498 <serve+0xd4>
		return;
	}

	start = sys_time_msec();
  80046d:	e8 c9 eb 00 00       	call   80f03b <sys_time_msec>
  800472:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800475:	e8 d6 a1 00 00       	call   80a650 <thread_yield>
	now = sys_time_msec();
  80047a:	e8 bc eb 00 00       	call   80f03b <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80047f:	6a 00                	push   $0x0
  800481:	6a 00                	push   $0x0
  800483:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800486:	81 c2 fa 00 00 00    	add    $0xfa,%edx

	start = sys_time_msec();
	thread_yield();
	now = sys_time_msec();

	to = TIMER_INTERVAL - (now - start);
  80048c:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80048e:	52                   	push   %edx
  80048f:	56                   	push   %esi
  800490:	e8 b4 ef 00 00       	call   80f449 <ipc_send>
  800495:	83 c4 10             	add    $0x10,%esp
	return va;
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800498:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80049e:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004a1:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  8004a8:	e9 23 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  8004ad:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  8004b1:	75 18                	jne    8004cb <serve+0x107>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  8004b3:	83 ec 08             	sub    $0x8,%esp
  8004b6:	ff 75 e4             	pushl  -0x1c(%ebp)
  8004b9:	68 5c 0d 81 00       	push   $0x810d5c
  8004be:	e8 f7 df 00 00       	call   80e4ba <cprintf>
			continue; // just leave it hanging...
  8004c3:	83 c4 10             	add    $0x10,%esp
  8004c6:	e9 05 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8004cb:	83 ec 0c             	sub    $0xc,%esp
  8004ce:	6a 0c                	push   $0xc
  8004d0:	e8 55 fd 00 00       	call   81022a <malloc>
		if (!args)
  8004d5:	83 c4 10             	add    $0x10,%esp
  8004d8:	85 c0                	test   %eax,%eax
  8004da:	75 17                	jne    8004f3 <serve+0x12f>
			panic("could not allocate thread args structure");
  8004dc:	83 ec 04             	sub    $0x4,%esp
  8004df:	68 8c 0d 81 00       	push   $0x810d8c
  8004e4:	68 27 01 00 00       	push   $0x127
  8004e9:	68 b5 0d 81 00       	push   $0x810db5
  8004ee:	e8 ee de 00 00       	call   80e3e1 <_panic>

		args->reqno = reqno;
  8004f3:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8004f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8004f8:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8004fb:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8004fe:	50                   	push   %eax
  8004ff:	68 c4 00 80 00       	push   $0x8000c4
  800504:	68 1e 0e 81 00       	push   $0x810e1e
  800509:	6a 00                	push   $0x0
  80050b:	e8 1a a0 00 00       	call   80a52a <thread_create>
		thread_yield(); // let the thread created run
  800510:	e8 3b a1 00 00       	call   80a650 <thread_yield>
  800515:	83 c4 10             	add    $0x10,%esp
  800518:	e9 b3 fe ff ff       	jmp    8003d0 <serve+0xc>

0080051d <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80051d:	55                   	push   %ebp
  80051e:	89 e5                	mov    %esp,%ebp
  800520:	56                   	push   %esi
  800521:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800522:	83 ec 0c             	sub    $0xc,%esp
  800525:	68 2b 0e 81 00       	push   $0x810e2b
  80052a:	e8 4d 73 00 00       	call   80787c <inet_addr>
  80052f:	89 c6                	mov    %eax,%esi
  800531:	c7 04 24 34 0e 81 00 	movl   $0x810e34,(%esp)
  800538:	e8 3f 73 00 00       	call   80787c <inet_addr>
  80053d:	89 c3                	mov    %eax,%ebx
  80053f:	c7 04 24 42 0e 81 00 	movl   $0x810e42,(%esp)
  800546:	e8 31 73 00 00       	call   80787c <inet_addr>
  80054b:	83 c4 0c             	add    $0xc,%esp
  80054e:	56                   	push   %esi
  80054f:	53                   	push   %ebx
  800550:	50                   	push   %eax
  800551:	e8 11 fd ff ff       	call   800267 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800556:	e8 69 fe ff ff       	call   8003c4 <serve>

0080055b <umain>:
}

void
umain(int argc, char **argv)
{
  80055b:	55                   	push   %ebp
  80055c:	89 e5                	mov    %esp,%ebp
  80055e:	53                   	push   %ebx
  80055f:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  800562:	e8 a5 e8 00 00       	call   80ee0c <sys_getenvid>
  800567:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800569:	c7 05 08 43 81 00 93 	movl   $0x813893,0x814308
  800570:	38 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800573:	e8 46 ec 00 00       	call   80f1be <fork>
  800578:	a3 1c 50 81 00       	mov    %eax,0x81501c
	if (timer_envid < 0)
  80057d:	85 c0                	test   %eax,%eax
  80057f:	79 17                	jns    800598 <umain+0x3d>
		panic("error forking");
  800581:	83 ec 04             	sub    $0x4,%esp
  800584:	68 4c 0e 81 00       	push   $0x810e4c
  800589:	68 44 01 00 00       	push   $0x144
  80058e:	68 b5 0d 81 00       	push   $0x810db5
  800593:	e8 49 de 00 00       	call   80e3e1 <_panic>
	else if (timer_envid == 0) {
  800598:	85 c0                	test   %eax,%eax
  80059a:	75 16                	jne    8005b2 <umain+0x57>
		timer(ns_envid, TIMER_INTERVAL);
  80059c:	83 ec 08             	sub    $0x8,%esp
  80059f:	68 fa 00 00 00       	push   $0xfa
  8005a4:	53                   	push   %ebx
  8005a5:	e8 9b 00 00 00       	call   800645 <timer>
		return;
  8005aa:	83 c4 10             	add    $0x10,%esp
  8005ad:	e9 8e 00 00 00       	jmp    800640 <umain+0xe5>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005b2:	e8 07 ec 00 00       	call   80f1be <fork>
  8005b7:	a3 18 50 81 00       	mov    %eax,0x815018
	if (input_envid < 0)
  8005bc:	85 c0                	test   %eax,%eax
  8005be:	79 17                	jns    8005d7 <umain+0x7c>
		panic("error forking");
  8005c0:	83 ec 04             	sub    $0x4,%esp
  8005c3:	68 4c 0e 81 00       	push   $0x810e4c
  8005c8:	68 4e 01 00 00       	push   $0x14e
  8005cd:	68 b5 0d 81 00       	push   $0x810db5
  8005d2:	e8 0a de 00 00       	call   80e3e1 <_panic>
	else if (input_envid == 0) {
  8005d7:	85 c0                	test   %eax,%eax
  8005d9:	75 0e                	jne    8005e9 <umain+0x8e>
		input(ns_envid);
  8005db:	83 ec 0c             	sub    $0xc,%esp
  8005de:	53                   	push   %ebx
  8005df:	e8 f4 00 00 00       	call   8006d8 <input>
		return;
  8005e4:	83 c4 10             	add    $0x10,%esp
  8005e7:	eb 57                	jmp    800640 <umain+0xe5>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005e9:	e8 d0 eb 00 00       	call   80f1be <fork>
  8005ee:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005f3:	85 c0                	test   %eax,%eax
  8005f5:	79 17                	jns    80060e <umain+0xb3>
		panic("error forking");
  8005f7:	83 ec 04             	sub    $0x4,%esp
  8005fa:	68 4c 0e 81 00       	push   $0x810e4c
  8005ff:	68 58 01 00 00       	push   $0x158
  800604:	68 b5 0d 81 00       	push   $0x810db5
  800609:	e8 d3 dd 00 00       	call   80e3e1 <_panic>
	else if (output_envid == 0) {
  80060e:	85 c0                	test   %eax,%eax
  800610:	75 0e                	jne    800620 <umain+0xc5>
		output(ns_envid);
  800612:	83 ec 0c             	sub    $0xc,%esp
  800615:	53                   	push   %ebx
  800616:	e8 17 01 00 00       	call   800732 <output>
		return;
  80061b:	83 c4 10             	add    $0x10,%esp
  80061e:	eb 20                	jmp    800640 <umain+0xe5>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800620:	e8 68 9e 00 00       	call   80a48d <thread_init>
	thread_create(0, "main", tmain, 0);
  800625:	6a 00                	push   $0x0
  800627:	68 1d 05 80 00       	push   $0x80051d
  80062c:	68 5a 0e 81 00       	push   $0x810e5a
  800631:	6a 00                	push   $0x0
  800633:	e8 f2 9e 00 00       	call   80a52a <thread_create>
	thread_yield();
  800638:	e8 13 a0 00 00       	call   80a650 <thread_yield>
  80063d:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800640:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800643:	c9                   	leave  
  800644:	c3                   	ret    

00800645 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800645:	55                   	push   %ebp
  800646:	89 e5                	mov    %esp,%ebp
  800648:	57                   	push   %edi
  800649:	56                   	push   %esi
  80064a:	53                   	push   %ebx
  80064b:	83 ec 1c             	sub    $0x1c,%esp
  80064e:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800651:	e8 e5 e9 00 00       	call   80f03b <sys_time_msec>
  800656:	03 45 0c             	add    0xc(%ebp),%eax
  800659:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  80065b:	c7 05 08 43 81 00 8c 	movl   $0x810e8c,0x814308
  800662:	0e 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800665:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800668:	eb 05                	jmp    80066f <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  80066a:	e8 bc e7 00 00       	call   80ee2b <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  80066f:	e8 c7 e9 00 00       	call   80f03b <sys_time_msec>
  800674:	89 c2                	mov    %eax,%edx
  800676:	85 c0                	test   %eax,%eax
  800678:	78 04                	js     80067e <timer+0x39>
  80067a:	39 c3                	cmp    %eax,%ebx
  80067c:	77 ec                	ja     80066a <timer+0x25>
			sys_yield();
		}
		if (r < 0)
  80067e:	85 c0                	test   %eax,%eax
  800680:	79 12                	jns    800694 <timer+0x4f>
			panic("sys_time_msec: %e", r);
  800682:	52                   	push   %edx
  800683:	68 95 0e 81 00       	push   $0x810e95
  800688:	6a 0f                	push   $0xf
  80068a:	68 a7 0e 81 00       	push   $0x810ea7
  80068f:	e8 4d dd 00 00       	call   80e3e1 <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800694:	6a 00                	push   $0x0
  800696:	6a 00                	push   $0x0
  800698:	6a 0c                	push   $0xc
  80069a:	56                   	push   %esi
  80069b:	e8 a9 ed 00 00       	call   80f449 <ipc_send>
  8006a0:	83 c4 10             	add    $0x10,%esp

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006a3:	83 ec 04             	sub    $0x4,%esp
  8006a6:	6a 00                	push   $0x0
  8006a8:	6a 00                	push   $0x0
  8006aa:	57                   	push   %edi
  8006ab:	e8 30 ed 00 00       	call   80f3e0 <ipc_recv>
  8006b0:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006b5:	83 c4 10             	add    $0x10,%esp
  8006b8:	39 c6                	cmp    %eax,%esi
  8006ba:	74 13                	je     8006cf <timer+0x8a>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006bc:	83 ec 08             	sub    $0x8,%esp
  8006bf:	50                   	push   %eax
  8006c0:	68 b4 0e 81 00       	push   $0x810eb4
  8006c5:	e8 f0 dd 00 00       	call   80e4ba <cprintf>
				continue;
  8006ca:	83 c4 10             	add    $0x10,%esp
  8006cd:	eb d4                	jmp    8006a3 <timer+0x5e>
			}

			stop = sys_time_msec() + to;
  8006cf:	e8 67 e9 00 00       	call   80f03b <sys_time_msec>
  8006d4:	01 c3                	add    %eax,%ebx
  8006d6:	eb 97                	jmp    80066f <timer+0x2a>

008006d8 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  8006d8:	55                   	push   %ebp
  8006d9:	89 e5                	mov    %esp,%ebp
  8006db:	53                   	push   %ebx
  8006dc:	83 ec 04             	sub    $0x4,%esp
  8006df:	8b 5d 08             	mov    0x8(%ebp),%ebx
	binaryname = "ns_input";
  8006e2:	c7 05 08 43 81 00 ef 	movl   $0x810eef,0x814308
  8006e9:	0e 81 00 
  8006ec:	eb 1c                	jmp    80070a <input+0x32>
        int r;
        while(1) {
 
                
                 while(( r = sys_recv((void *)RXTEP)) < 0) {
                       if(r != -E_IPC_NOT_RECV)
  8006ee:	83 f8 f9             	cmp    $0xfffffff9,%eax
  8006f1:	74 12                	je     800705 <input+0x2d>
                               panic("sys_recv fails %e\n", r);
  8006f3:	50                   	push   %eax
  8006f4:	68 f8 0e 81 00       	push   $0x810ef8
  8006f9:	6a 17                	push   $0x17
  8006fb:	68 0b 0f 81 00       	push   $0x810f0b
  800700:	e8 dc dc 00 00       	call   80e3e1 <_panic>
                       sys_yield();
  800705:	e8 21 e7 00 00       	call   80ee2b <sys_yield>
 
        int r;
        while(1) {
 
                
                 while(( r = sys_recv((void *)RXTEP)) < 0) {
  80070a:	83 ec 0c             	sub    $0xc,%esp
  80070d:	68 00 20 80 40       	push   $0x40802000
  800712:	e8 84 e9 00 00       	call   80f09b <sys_recv>
  800717:	83 c4 10             	add    $0x10,%esp
  80071a:	85 c0                	test   %eax,%eax
  80071c:	78 d0                	js     8006ee <input+0x16>
                       if(r != -E_IPC_NOT_RECV)
                               panic("sys_recv fails %e\n", r);
                       sys_yield();
               }
      
               ipc_send(ns_envid, NSREQ_INPUT, (void *)RXTEP, PTE_U | PTE_P); 
  80071e:	6a 05                	push   $0x5
  800720:	68 00 20 80 40       	push   $0x40802000
  800725:	6a 0a                	push   $0xa
  800727:	53                   	push   %ebx
  800728:	e8 1c ed 00 00       	call   80f449 <ipc_send>
        }
  80072d:	83 c4 10             	add    $0x10,%esp
  800730:	eb d8                	jmp    80070a <input+0x32>

00800732 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800732:	55                   	push   %ebp
  800733:	89 e5                	mov    %esp,%ebp
  800735:	57                   	push   %edi
  800736:	56                   	push   %esi
  800737:	53                   	push   %ebx
  800738:	83 ec 1c             	sub    $0x1c,%esp
  80073b:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_output";
  80073e:	c7 05 08 43 81 00 17 	movl   $0x810f17,0x814308
  800745:	0f 81 00 
	//	- send the packet to the device driver
        envid_t from_envid;
        int perm;
        int r;
        while(1) {
                r = ipc_recv(&from_envid, (void *)TXTEP, &perm);
  800748:	8d 75 e0             	lea    -0x20(%ebp),%esi
  80074b:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
  80074e:	83 ec 04             	sub    $0x4,%esp
  800751:	56                   	push   %esi
  800752:	68 00 20 40 40       	push   $0x40402000
  800757:	53                   	push   %ebx
  800758:	e8 83 ec 00 00       	call   80f3e0 <ipc_recv>
                if (r < 0)
  80075d:	83 c4 10             	add    $0x10,%esp
  800760:	85 c0                	test   %eax,%eax
  800762:	79 12                	jns    800776 <output+0x44>
                        panic("ipc_recv from net fails %e\n", r);
  800764:	50                   	push   %eax
  800765:	68 21 0f 81 00       	push   $0x810f21
  80076a:	6a 13                	push   $0x13
  80076c:	68 3d 0f 81 00       	push   $0x810f3d
  800771:	e8 6b dc 00 00       	call   80e3e1 <_panic>
                if (from_envid != ns_envid)
                        continue;
                if (r != NSREQ_OUTPUT)
  800776:	83 f8 0b             	cmp    $0xb,%eax
  800779:	75 d3                	jne    80074e <output+0x1c>
  80077b:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80077e:	75 ce                	jne    80074e <output+0x1c>
  800780:	eb 1c                	jmp    80079e <output+0x6c>
                        continue;
                while((r = sys_transmit((void *)TXTEP) ) < 0) {
                        if(r != -E_IPC_NOT_RECV)
  800782:	83 f8 f9             	cmp    $0xfffffff9,%eax
  800785:	74 12                	je     800799 <output+0x67>
                                panic("sys_transit fails %e\n", r);
  800787:	50                   	push   %eax
  800788:	68 4a 0f 81 00       	push   $0x810f4a
  80078d:	6a 1a                	push   $0x1a
  80078f:	68 3d 0f 81 00       	push   $0x810f3d
  800794:	e8 48 dc 00 00       	call   80e3e1 <_panic>
                        sys_yield();
  800799:	e8 8d e6 00 00       	call   80ee2b <sys_yield>
                        panic("ipc_recv from net fails %e\n", r);
                if (from_envid != ns_envid)
                        continue;
                if (r != NSREQ_OUTPUT)
                        continue;
                while((r = sys_transmit((void *)TXTEP) ) < 0) {
  80079e:	83 ec 0c             	sub    $0xc,%esp
  8007a1:	68 00 20 40 40       	push   $0x40402000
  8007a6:	e8 af e8 00 00       	call   80f05a <sys_transmit>
  8007ab:	83 c4 10             	add    $0x10,%esp
  8007ae:	85 c0                	test   %eax,%eax
  8007b0:	78 d0                	js     800782 <output+0x50>
  8007b2:	eb 9a                	jmp    80074e <output+0x1c>

008007b4 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  8007b4:	55                   	push   %ebp
  8007b5:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8007b7:	83 f8 1f             	cmp    $0x1f,%eax
  8007ba:	76 11                	jbe    8007cd <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  8007bc:	c7 05 20 b3 b3 00 09 	movl   $0x9,0xb3b320
  8007c3:	00 00 00 
    return NULL;
  8007c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8007cb:	eb 30                	jmp    8007fd <get_socket+0x49>
  }

  sock = &sockets[s];
  8007cd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  8007d4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  8007d7:	8d 0c 8d c0 50 81 00 	lea    0x8150c0(,%ecx,4),%ecx

  if (!sock->conn) {
  8007de:	01 c2                	add    %eax,%edx
  8007e0:	83 3c 95 c0 50 81 00 	cmpl   $0x0,0x8150c0(,%edx,4)
  8007e7:	00 
  8007e8:	75 11                	jne    8007fb <get_socket+0x47>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  8007ea:	c7 05 20 b3 b3 00 09 	movl   $0x9,0xb3b320
  8007f1:	00 00 00 
    return NULL;
  8007f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8007f9:	eb 02                	jmp    8007fd <get_socket+0x49>
  }

  return sock;
  8007fb:	89 c8                	mov    %ecx,%eax
}
  8007fd:	5d                   	pop    %ebp
  8007fe:	c3                   	ret    

008007ff <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  8007ff:	55                   	push   %ebp
  800800:	89 e5                	mov    %esp,%ebp
  800802:	57                   	push   %edi
  800803:	56                   	push   %esi
  800804:	53                   	push   %ebx
  800805:	83 ec 40             	sub    $0x40,%esp
  800808:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80080b:	89 55 cc             	mov    %edx,-0x34(%ebp)
  80080e:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800811:	6a 04                	push   $0x4
  800813:	6a 00                	push   $0x0
  800815:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800818:	50                   	push   %eax
  800819:	e8 68 e3 00 00       	call   80eb86 <memset>
  FD_ZERO(&lwriteset);
  80081e:	83 c4 0c             	add    $0xc,%esp
  800821:	6a 04                	push   $0x4
  800823:	6a 00                	push   $0x0
  800825:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800828:	50                   	push   %eax
  800829:	e8 58 e3 00 00       	call   80eb86 <memset>
  FD_ZERO(&lexceptset);
  80082e:	83 c4 0c             	add    $0xc,%esp
  800831:	6a 04                	push   $0x4
  800833:	6a 00                	push   $0x0
  800835:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800838:	50                   	push   %eax
  800839:	e8 48 e3 00 00       	call   80eb86 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80083e:	83 c4 10             	add    $0x10,%esp
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  800841:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800848:	bf 00 00 00 00       	mov    $0x0,%edi
  80084d:	e9 80 00 00 00       	jmp    8008d2 <lwip_selscan+0xd3>
    if (FD_ISSET(i, readset)) {
  800852:	8d 5f 07             	lea    0x7(%edi),%ebx
  800855:	85 ff                	test   %edi,%edi
  800857:	0f 49 df             	cmovns %edi,%ebx
  80085a:	c1 fb 03             	sar    $0x3,%ebx
  80085d:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800860:	89 fe                	mov    %edi,%esi
  800862:	83 e6 07             	and    $0x7,%esi
  800865:	8b 45 cc             	mov    -0x34(%ebp),%eax
  800868:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  80086c:	0f a3 f0             	bt     %esi,%eax
  80086f:	73 2c                	jae    80089d <lwip_selscan+0x9e>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  800871:	89 f8                	mov    %edi,%eax
  800873:	e8 3c ff ff ff       	call   8007b4 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  800878:	85 c0                	test   %eax,%eax
  80087a:	74 21                	je     80089d <lwip_selscan+0x9e>
  80087c:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  800880:	75 07                	jne    800889 <lwip_selscan+0x8a>
  800882:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800887:	74 14                	je     80089d <lwip_selscan+0x9e>
        FD_SET(i, &lreadset);
  800889:	b8 01 00 00 00       	mov    $0x1,%eax
  80088e:	89 f1                	mov    %esi,%ecx
  800890:	d3 e0                	shl    %cl,%eax
  800892:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800895:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800899:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  80089d:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8008a0:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8008a4:	0f a3 f0             	bt     %esi,%eax
  8008a7:	73 26                	jae    8008cf <lwip_selscan+0xd0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8008a9:	89 f8                	mov    %edi,%eax
  8008ab:	e8 04 ff ff ff       	call   8007b4 <get_socket>
      if (p_sock && p_sock->sendevent) {
  8008b0:	85 c0                	test   %eax,%eax
  8008b2:	74 1b                	je     8008cf <lwip_selscan+0xd0>
  8008b4:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8008b9:	74 14                	je     8008cf <lwip_selscan+0xd0>
        FD_SET(i, &lwriteset);
  8008bb:	b8 01 00 00 00       	mov    $0x1,%eax
  8008c0:	89 f1                	mov    %esi,%ecx
  8008c2:	d3 e0                	shl    %cl,%eax
  8008c4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8008c7:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  8008cb:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8008cf:	83 c7 01             	add    $0x1,%edi
  8008d2:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8008d5:	0f 8c 77 ff ff ff    	jl     800852 <lwip_selscan+0x53>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  8008db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008de:	8b 55 cc             	mov    -0x34(%ebp),%edx
  8008e1:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  8008e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8008e6:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  8008e9:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  8008eb:	83 ec 04             	sub    $0x4,%esp
  8008ee:	6a 04                	push   $0x4
  8008f0:	6a 00                	push   $0x0
  8008f2:	ff 75 08             	pushl  0x8(%ebp)
  8008f5:	e8 8c e2 00 00       	call   80eb86 <memset>
  
  return nready;
}
  8008fa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8008fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800900:	5b                   	pop    %ebx
  800901:	5e                   	pop    %esi
  800902:	5f                   	pop    %edi
  800903:	5d                   	pop    %ebp
  800904:	c3                   	ret    

00800905 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800905:	55                   	push   %ebp
  800906:	89 e5                	mov    %esp,%ebp
  800908:	57                   	push   %edi
  800909:	56                   	push   %esi
  80090a:	53                   	push   %ebx
  80090b:	83 ec 3c             	sub    $0x3c,%esp
  80090e:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800911:	89 cf                	mov    %ecx,%edi
  800913:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800916:	e8 99 fe ff ff       	call   8007b4 <get_socket>
  80091b:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80091d:	85 c0                	test   %eax,%eax
  80091f:	74 7e                	je     80099f <lwip_getaddrname+0x9a>
    return -1;

  memset(&sin, 0, sizeof(sin));
  800921:	83 ec 04             	sub    $0x4,%esp
  800924:	6a 10                	push   $0x10
  800926:	6a 00                	push   $0x0
  800928:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80092b:	50                   	push   %eax
  80092c:	e8 55 e2 00 00       	call   80eb86 <memset>
  sin.sin_len = sizeof(sin);
  800931:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800935:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800939:	89 f0                	mov    %esi,%eax
  80093b:	0f b6 f0             	movzbl %al,%esi
  80093e:	56                   	push   %esi
  80093f:	8d 45 da             	lea    -0x26(%ebp),%eax
  800942:	50                   	push   %eax
  800943:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800946:	50                   	push   %eax
  800947:	ff 33                	pushl  (%ebx)
  800949:	e8 ec a2 00 00       	call   80ac3a <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  80094e:	83 c4 14             	add    $0x14,%esp
  800951:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800955:	50                   	push   %eax
  800956:	e8 f2 6c 00 00       	call   80764d <htons>
  80095b:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80095f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800962:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800965:	83 c4 10             	add    $0x10,%esp
  800968:	83 3f 10             	cmpl   $0x10,(%edi)
  80096b:	76 06                	jbe    800973 <lwip_getaddrname+0x6e>
    *namelen = sizeof(sin);
  80096d:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  800973:	83 ec 04             	sub    $0x4,%esp
  800976:	ff 37                	pushl  (%edi)
  800978:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80097b:	50                   	push   %eax
  80097c:	ff 75 c4             	pushl  -0x3c(%ebp)
  80097f:	e8 b7 e2 00 00       	call   80ec3b <memcpy>
  sock_set_errno(sock, 0);
  800984:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80098b:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  800992:	00 00 00 
  return 0;
  800995:	83 c4 10             	add    $0x10,%esp
  800998:	b8 00 00 00 00       	mov    $0x0,%eax
  80099d:	eb 05                	jmp    8009a4 <lwip_getaddrname+0x9f>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  80099f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  8009a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8009a7:	5b                   	pop    %ebx
  8009a8:	5e                   	pop    %esi
  8009a9:	5f                   	pop    %edi
  8009aa:	5d                   	pop    %ebp
  8009ab:	c3                   	ret    

008009ac <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8009ac:	55                   	push   %ebp
  8009ad:	89 e5                	mov    %esp,%ebp
  8009af:	57                   	push   %edi
  8009b0:	56                   	push   %esi
  8009b1:	53                   	push   %ebx
  8009b2:	83 ec 1c             	sub    $0x1c,%esp
  8009b5:	8b 7d 08             	mov    0x8(%ebp),%edi
  8009b8:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8009bb:	85 ff                	test   %edi,%edi
  8009bd:	0f 84 81 01 00 00    	je     800b44 <event_callback+0x198>
    s = conn->socket;
  8009c3:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  8009c6:	85 db                	test   %ebx,%ebx
  8009c8:	79 49                	jns    800a13 <event_callback+0x67>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  8009ca:	83 ec 0c             	sub    $0xc,%esp
  8009cd:	ff 35 84 50 81 00    	pushl  0x815084
  8009d3:	e8 da 46 00 00       	call   8050b2 <sys_sem_wait>
      if (conn->socket < 0) {
  8009d8:	8b 47 1c             	mov    0x1c(%edi),%eax
  8009db:	83 c4 10             	add    $0x10,%esp
  8009de:	85 c0                	test   %eax,%eax
  8009e0:	79 20                	jns    800a02 <event_callback+0x56>
        if (evt == NETCONN_EVT_RCVPLUS) {
  8009e2:	85 f6                	test   %esi,%esi
  8009e4:	75 06                	jne    8009ec <event_callback+0x40>
          conn->socket--;
  8009e6:	83 e8 01             	sub    $0x1,%eax
  8009e9:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  8009ec:	83 ec 0c             	sub    $0xc,%esp
  8009ef:	ff 35 84 50 81 00    	pushl  0x815084
  8009f5:	e8 a1 95 00 00       	call   809f9b <sys_sem_signal>
        return;
  8009fa:	83 c4 10             	add    $0x10,%esp
  8009fd:	e9 42 01 00 00       	jmp    800b44 <event_callback+0x198>
      }
      sys_sem_signal(socksem);
  800a02:	83 ec 0c             	sub    $0xc,%esp
  800a05:	ff 35 84 50 81 00    	pushl  0x815084
  800a0b:	e8 8b 95 00 00       	call   809f9b <sys_sem_signal>
  800a10:	83 c4 10             	add    $0x10,%esp
    }

    sock = get_socket(s);
  800a13:	89 d8                	mov    %ebx,%eax
  800a15:	e8 9a fd ff ff       	call   8007b4 <get_socket>
  800a1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800a1d:	85 c0                	test   %eax,%eax
  800a1f:	0f 84 1f 01 00 00    	je     800b44 <event_callback+0x198>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800a25:	83 ec 0c             	sub    $0xc,%esp
  800a28:	ff 35 80 50 81 00    	pushl  0x815080
  800a2e:	e8 7f 46 00 00       	call   8050b2 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800a33:	83 c4 10             	add    $0x10,%esp
  800a36:	83 fe 01             	cmp    $0x1,%esi
  800a39:	74 1b                	je     800a56 <event_callback+0xaa>
  800a3b:	83 fe 01             	cmp    $0x1,%esi
  800a3e:	72 0c                	jb     800a4c <event_callback+0xa0>
  800a40:	83 fe 02             	cmp    $0x2,%esi
  800a43:	74 1b                	je     800a60 <event_callback+0xb4>
  800a45:	83 fe 03             	cmp    $0x3,%esi
  800a48:	74 21                	je     800a6b <event_callback+0xbf>
  800a4a:	eb 2a                	jmp    800a76 <event_callback+0xca>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800a4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a4f:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  800a54:	eb 37                	jmp    800a8d <event_callback+0xe1>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800a56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a59:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800a5e:	eb 2d                	jmp    800a8d <event_callback+0xe1>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800a60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a63:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800a69:	eb 22                	jmp    800a8d <event_callback+0xe1>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800a6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a6e:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800a74:	eb 17                	jmp    800a8d <event_callback+0xe1>
    default:
      LWIP_ASSERT("unknown event", 0);
  800a76:	83 ec 04             	sub    $0x4,%esp
  800a79:	68 60 0f 81 00       	push   $0x810f60
  800a7e:	68 17 04 00 00       	push   $0x417
  800a83:	68 6e 0f 81 00       	push   $0x810f6e
  800a88:	e8 54 d9 00 00       	call   80e3e1 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800a8d:	83 ec 0c             	sub    $0xc,%esp
  800a90:	ff 35 80 50 81 00    	pushl  0x815080
  800a96:	e8 00 95 00 00       	call   809f9b <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a9b:	8d 73 07             	lea    0x7(%ebx),%esi
  800a9e:	83 c4 10             	add    $0x10,%esp
  800aa1:	85 db                	test   %ebx,%ebx
  800aa3:	0f 49 f3             	cmovns %ebx,%esi
  800aa6:	c1 fe 03             	sar    $0x3,%esi
  800aa9:	89 d9                	mov    %ebx,%ecx
  800aab:	83 e1 07             	and    $0x7,%ecx
  800aae:	bf 01 00 00 00       	mov    $0x1,%edi
  800ab3:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800ab5:	83 ec 0c             	sub    $0xc,%esp
  800ab8:	ff 35 80 50 81 00    	pushl  0x815080
  800abe:	e8 ef 45 00 00       	call   8050b2 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800ac3:	8b 1d 88 50 81 00    	mov    0x815088,%ebx
  800ac9:	83 c4 10             	add    $0x10,%esp
  800acc:	eb 3a                	jmp    800b08 <event_callback+0x15c>
      if (scb->sem_signalled == 0) {
  800ace:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800ad2:	75 32                	jne    800b06 <event_callback+0x15a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800ad4:	8b 43 04             	mov    0x4(%ebx),%eax
  800ad7:	85 c0                	test   %eax,%eax
  800ad9:	74 12                	je     800aed <event_callback+0x141>
  800adb:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800adf:	85 f8                	test   %edi,%eax
  800ae1:	74 0a                	je     800aed <event_callback+0x141>
          if (sock->rcvevent)
  800ae3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ae6:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800aeb:	75 21                	jne    800b0e <event_callback+0x162>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800aed:	8b 43 08             	mov    0x8(%ebx),%eax
  800af0:	85 c0                	test   %eax,%eax
  800af2:	74 12                	je     800b06 <event_callback+0x15a>
  800af4:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800af8:	85 f8                	test   %edi,%eax
  800afa:	74 0a                	je     800b06 <event_callback+0x15a>
          if (sock->sendevent)
  800afc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800aff:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800b04:	75 08                	jne    800b0e <event_callback+0x162>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b06:	8b 1b                	mov    (%ebx),%ebx
  800b08:	85 db                	test   %ebx,%ebx
  800b0a:	75 c2                	jne    800ace <event_callback+0x122>
  800b0c:	eb 25                	jmp    800b33 <event_callback+0x187>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800b0e:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800b15:	83 ec 0c             	sub    $0xc,%esp
  800b18:	ff 35 80 50 81 00    	pushl  0x815080
  800b1e:	e8 78 94 00 00       	call   809f9b <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b23:	83 c4 04             	add    $0x4,%esp
  800b26:	ff 73 14             	pushl  0x14(%ebx)
  800b29:	e8 6d 94 00 00       	call   809f9b <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800b2e:	83 c4 10             	add    $0x10,%esp
  800b31:	eb 82                	jmp    800ab5 <event_callback+0x109>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800b33:	83 ec 0c             	sub    $0xc,%esp
  800b36:	ff 35 80 50 81 00    	pushl  0x815080
  800b3c:	e8 5a 94 00 00       	call   809f9b <sys_sem_signal>
      break;
  800b41:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  800b44:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800b47:	5b                   	pop    %ebx
  800b48:	5e                   	pop    %esi
  800b49:	5f                   	pop    %edi
  800b4a:	5d                   	pop    %ebp
  800b4b:	c3                   	ret    

00800b4c <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800b4c:	55                   	push   %ebp
  800b4d:	89 e5                	mov    %esp,%ebp
  800b4f:	56                   	push   %esi
  800b50:	53                   	push   %ebx
  800b51:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800b53:	83 ec 0c             	sub    $0xc,%esp
  800b56:	ff 35 84 50 81 00    	pushl  0x815084
  800b5c:	e8 51 45 00 00       	call   8050b2 <sys_sem_wait>
  800b61:	ba c0 50 81 00       	mov    $0x8150c0,%edx
  800b66:	83 c4 10             	add    $0x10,%esp

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800b69:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800b6e:	83 3a 00             	cmpl   $0x0,(%edx)
  800b71:	75 63                	jne    800bd6 <alloc_socket+0x8a>
      sockets[i].conn       = newconn;
  800b73:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
  800b7a:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  800b7d:	c1 e1 02             	shl    $0x2,%ecx
  800b80:	89 b1 c0 50 81 00    	mov    %esi,0x8150c0(%ecx)
      sockets[i].lastdata   = NULL;
  800b86:	c7 81 c4 50 81 00 00 	movl   $0x0,0x8150c4(%ecx)
  800b8d:	00 00 00 
      sockets[i].lastoffset = 0;
  800b90:	66 c7 81 c8 50 81 00 	movw   $0x0,0x8150c8(%ecx)
  800b97:	00 00 
      sockets[i].rcvevent   = 0;
  800b99:	66 c7 81 ca 50 81 00 	movw   $0x0,0x8150ca(%ecx)
  800ba0:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800ba2:	66 c7 81 cc 50 81 00 	movw   $0x1,0x8150cc(%ecx)
  800ba9:	01 00 
      sockets[i].flags      = 0;
  800bab:	66 c7 81 ce 50 81 00 	movw   $0x0,0x8150ce(%ecx)
  800bb2:	00 00 
      sockets[i].err        = 0;
  800bb4:	01 da                	add    %ebx,%edx
  800bb6:	c7 04 95 d0 50 81 00 	movl   $0x0,0x8150d0(,%edx,4)
  800bbd:	00 00 00 00 
      sys_sem_signal(socksem);
  800bc1:	83 ec 0c             	sub    $0xc,%esp
  800bc4:	ff 35 84 50 81 00    	pushl  0x815084
  800bca:	e8 cc 93 00 00       	call   809f9b <sys_sem_signal>
      return i;
  800bcf:	83 c4 10             	add    $0x10,%esp
  800bd2:	89 d8                	mov    %ebx,%eax
  800bd4:	eb 21                	jmp    800bf7 <alloc_socket+0xab>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800bd6:	83 c3 01             	add    $0x1,%ebx
  800bd9:	83 c2 14             	add    $0x14,%edx
  800bdc:	83 fb 20             	cmp    $0x20,%ebx
  800bdf:	75 8d                	jne    800b6e <alloc_socket+0x22>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800be1:	83 ec 0c             	sub    $0xc,%esp
  800be4:	ff 35 84 50 81 00    	pushl  0x815084
  800bea:	e8 ac 93 00 00       	call   809f9b <sys_sem_signal>
  return -1;
  800bef:	83 c4 10             	add    $0x10,%esp
  800bf2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800bf7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800bfa:	5b                   	pop    %ebx
  800bfb:	5e                   	pop    %esi
  800bfc:	5d                   	pop    %ebp
  800bfd:	c3                   	ret    

00800bfe <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800bfe:	55                   	push   %ebp
  800bff:	89 e5                	mov    %esp,%ebp
  800c01:	53                   	push   %ebx
  800c02:	83 ec 04             	sub    $0x4,%esp
  800c05:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c08:	85 c0                	test   %eax,%eax
  800c0a:	75 17                	jne    800c23 <lwip_getsockopt_internal+0x25>
  800c0c:	83 ec 04             	sub    $0x4,%esp
  800c0f:	68 85 0f 81 00       	push   $0x810f85
  800c14:	68 38 05 00 00       	push   $0x538
  800c19:	68 6e 0f 81 00       	push   $0x810f6e
  800c1e:	e8 be d7 00 00       	call   80e3e1 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800c23:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800c25:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800c28:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800c2b:	8b 40 08             	mov    0x8(%eax),%eax
  800c2e:	83 f8 06             	cmp    $0x6,%eax
  800c31:	0f 84 09 01 00 00    	je     800d40 <lwip_getsockopt_internal+0x142>
  800c37:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800c3c:	74 0d                	je     800c4b <lwip_getsockopt_internal+0x4d>
  800c3e:	85 c0                	test   %eax,%eax
  800c40:	0f 85 26 01 00 00    	jne    800d6c <lwip_getsockopt_internal+0x16e>
  800c46:	e9 d1 00 00 00       	jmp    800d1c <lwip_getsockopt_internal+0x11e>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800c4b:	83 fa 20             	cmp    $0x20,%edx
  800c4e:	74 37                	je     800c87 <lwip_getsockopt_internal+0x89>
  800c50:	83 fa 20             	cmp    $0x20,%edx
  800c53:	7f 10                	jg     800c65 <lwip_getsockopt_internal+0x67>
  800c55:	83 fa 02             	cmp    $0x2,%edx
  800c58:	74 2d                	je     800c87 <lwip_getsockopt_internal+0x89>
  800c5a:	83 fa 08             	cmp    $0x8,%edx
  800c5d:	0f 85 09 01 00 00    	jne    800d6c <lwip_getsockopt_internal+0x16e>
  800c63:	eb 22                	jmp    800c87 <lwip_getsockopt_internal+0x89>
  800c65:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800c6b:	74 2c                	je     800c99 <lwip_getsockopt_internal+0x9b>
  800c6d:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800c73:	0f 84 93 00 00 00    	je     800d0c <lwip_getsockopt_internal+0x10e>
  800c79:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800c7f:	0f 85 e7 00 00 00    	jne    800d6c <lwip_getsockopt_internal+0x16e>
  800c85:	eb 4f                	jmp    800cd6 <lwip_getsockopt_internal+0xd8>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800c87:	8b 01                	mov    (%ecx),%eax
  800c89:	8b 40 08             	mov    0x8(%eax),%eax
  800c8c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800c90:	21 c2                	and    %eax,%edx
  800c92:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800c94:	e9 d3 00 00 00       	jmp    800d6c <lwip_getsockopt_internal+0x16e>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800c99:	8b 01                	mov    (%ecx),%eax
  800c9b:	8b 10                	mov    (%eax),%edx
  800c9d:	89 d0                	mov    %edx,%eax
  800c9f:	25 f0 00 00 00       	and    $0xf0,%eax
  800ca4:	83 f8 20             	cmp    $0x20,%eax
  800ca7:	74 22                	je     800ccb <lwip_getsockopt_internal+0xcd>
  800ca9:	83 f8 40             	cmp    $0x40,%eax
  800cac:	74 12                	je     800cc0 <lwip_getsockopt_internal+0xc2>
  800cae:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800cb1:	b8 01 00 00 00       	mov    $0x1,%eax
  800cb6:	0f 44 d0             	cmove  %eax,%edx
  800cb9:	89 13                	mov    %edx,(%ebx)
  800cbb:	e9 ac 00 00 00       	jmp    800d6c <lwip_getsockopt_internal+0x16e>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800cc0:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800cc6:	e9 a1 00 00 00       	jmp    800d6c <lwip_getsockopt_internal+0x16e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800ccb:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800cd1:	e9 96 00 00 00       	jmp    800d6c <lwip_getsockopt_internal+0x16e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800cd6:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800cda:	75 22                	jne    800cfe <lwip_getsockopt_internal+0x100>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800cdc:	8b 01                	mov    (%ecx),%eax
  800cde:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800ce2:	f7 d8                	neg    %eax
  800ce4:	ba 05 00 00 00       	mov    $0x5,%edx
  800ce9:	83 f8 0e             	cmp    $0xe,%eax
  800cec:	77 07                	ja     800cf5 <lwip_getsockopt_internal+0xf7>
  800cee:	8b 14 85 20 10 81 00 	mov    0x811020(,%eax,4),%edx
  800cf5:	89 51 10             	mov    %edx,0x10(%ecx)
  800cf8:	89 15 20 b3 b3 00    	mov    %edx,0xb3b320
      } 
      *(int *)optval = sock->err;
  800cfe:	8b 41 10             	mov    0x10(%ecx),%eax
  800d01:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800d03:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800d0a:	eb 60                	jmp    800d6c <lwip_getsockopt_internal+0x16e>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800d0c:	8b 01                	mov    (%ecx),%eax
  800d0e:	8b 40 08             	mov    0x8(%eax),%eax
  800d11:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800d15:	83 e0 01             	and    $0x1,%eax
  800d18:	89 03                	mov    %eax,(%ebx)
      break;
  800d1a:	eb 50                	jmp    800d6c <lwip_getsockopt_internal+0x16e>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800d1c:	83 fa 01             	cmp    $0x1,%edx
  800d1f:	74 12                	je     800d33 <lwip_getsockopt_internal+0x135>
  800d21:	83 fa 02             	cmp    $0x2,%edx
  800d24:	75 46                	jne    800d6c <lwip_getsockopt_internal+0x16e>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d26:	8b 01                	mov    (%ecx),%eax
  800d28:	8b 40 08             	mov    0x8(%eax),%eax
  800d2b:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800d2f:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800d31:	eb 39                	jmp    800d6c <lwip_getsockopt_internal+0x16e>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800d33:	8b 01                	mov    (%ecx),%eax
  800d35:	8b 40 08             	mov    0x8(%eax),%eax
  800d38:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800d3c:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800d3e:	eb 2c                	jmp    800d6c <lwip_getsockopt_internal+0x16e>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800d40:	83 fa 01             	cmp    $0x1,%edx
  800d43:	74 07                	je     800d4c <lwip_getsockopt_internal+0x14e>
  800d45:	83 fa 02             	cmp    $0x2,%edx
  800d48:	74 15                	je     800d5f <lwip_getsockopt_internal+0x161>
  800d4a:	eb 20                	jmp    800d6c <lwip_getsockopt_internal+0x16e>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800d4c:	8b 01                	mov    (%ecx),%eax
  800d4e:	8b 40 08             	mov    0x8(%eax),%eax
  800d51:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800d55:	83 e0 40             	and    $0x40,%eax
  800d58:	0f b6 c0             	movzbl %al,%eax
  800d5b:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800d5d:	eb 0d                	jmp    800d6c <lwip_getsockopt_internal+0x16e>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800d5f:	8b 01                	mov    (%ecx),%eax
  800d61:	8b 40 08             	mov    0x8(%eax),%eax
  800d64:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800d6a:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800d6c:	83 ec 0c             	sub    $0xc,%esp
  800d6f:	8b 01                	mov    (%ecx),%eax
  800d71:	ff 70 10             	pushl  0x10(%eax)
  800d74:	e8 22 92 00 00       	call   809f9b <sys_sem_signal>
  800d79:	83 c4 10             	add    $0x10,%esp
}
  800d7c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800d7f:	c9                   	leave  
  800d80:	c3                   	ret    

00800d81 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800d81:	55                   	push   %ebp
  800d82:	89 e5                	mov    %esp,%ebp
  800d84:	53                   	push   %ebx
  800d85:	83 ec 04             	sub    $0x4,%esp
  800d88:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d8b:	85 c0                	test   %eax,%eax
  800d8d:	75 17                	jne    800da6 <lwip_setsockopt_internal+0x25>
  800d8f:	83 ec 04             	sub    $0x4,%esp
  800d92:	68 85 0f 81 00       	push   $0x810f85
  800d97:	68 ae 06 00 00       	push   $0x6ae
  800d9c:	68 6e 0f 81 00       	push   $0x810f6e
  800da1:	e8 3b d6 00 00       	call   80e3e1 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800da6:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800da8:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800dab:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800dae:	8b 40 08             	mov    0x8(%eax),%eax
  800db1:	83 f8 06             	cmp    $0x6,%eax
  800db4:	0f 84 81 00 00 00    	je     800e3b <lwip_setsockopt_internal+0xba>
  800dba:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800dbf:	74 0a                	je     800dcb <lwip_setsockopt_internal+0x4a>
  800dc1:	85 c0                	test   %eax,%eax
  800dc3:	0f 85 a6 00 00 00    	jne    800e6f <lwip_setsockopt_internal+0xee>
  800dc9:	eb 4e                	jmp    800e19 <lwip_setsockopt_internal+0x98>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800dcb:	83 fa 20             	cmp    $0x20,%edx
  800dce:	74 11                	je     800de1 <lwip_setsockopt_internal+0x60>
  800dd0:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800dd6:	74 26                	je     800dfe <lwip_setsockopt_internal+0x7d>
  800dd8:	83 fa 08             	cmp    $0x8,%edx
  800ddb:	0f 85 8e 00 00 00    	jne    800e6f <lwip_setsockopt_internal+0xee>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800de1:	83 3b 00             	cmpl   $0x0,(%ebx)
  800de4:	74 0b                	je     800df1 <lwip_setsockopt_internal+0x70>
        sock->conn->pcb.ip->so_options |= optname;
  800de6:	8b 01                	mov    (%ecx),%eax
  800de8:	8b 40 08             	mov    0x8(%eax),%eax
  800deb:	66 09 50 08          	or     %dx,0x8(%eax)
  800def:	eb 7e                	jmp    800e6f <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800df1:	8b 01                	mov    (%ecx),%eax
  800df3:	8b 40 08             	mov    0x8(%eax),%eax
  800df6:	f7 d2                	not    %edx
  800df8:	66 21 50 08          	and    %dx,0x8(%eax)
  800dfc:	eb 71                	jmp    800e6f <lwip_setsockopt_internal+0xee>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800dfe:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e01:	74 0b                	je     800e0e <lwip_setsockopt_internal+0x8d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e03:	8b 01                	mov    (%ecx),%eax
  800e05:	8b 40 08             	mov    0x8(%eax),%eax
  800e08:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e0c:	eb 61                	jmp    800e6f <lwip_setsockopt_internal+0xee>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e0e:	8b 01                	mov    (%ecx),%eax
  800e10:	8b 40 08             	mov    0x8(%eax),%eax
  800e13:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e17:	eb 56                	jmp    800e6f <lwip_setsockopt_internal+0xee>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800e19:	83 fa 01             	cmp    $0x1,%edx
  800e1c:	74 11                	je     800e2f <lwip_setsockopt_internal+0xae>
  800e1e:	83 fa 02             	cmp    $0x2,%edx
  800e21:	75 4c                	jne    800e6f <lwip_setsockopt_internal+0xee>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800e23:	8b 01                	mov    (%ecx),%eax
  800e25:	8b 40 08             	mov    0x8(%eax),%eax
  800e28:	8b 13                	mov    (%ebx),%edx
  800e2a:	88 50 0b             	mov    %dl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800e2d:	eb 40                	jmp    800e6f <lwip_setsockopt_internal+0xee>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800e2f:	8b 01                	mov    (%ecx),%eax
  800e31:	8b 40 08             	mov    0x8(%eax),%eax
  800e34:	8b 13                	mov    (%ebx),%edx
  800e36:	88 50 0a             	mov    %dl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800e39:	eb 34                	jmp    800e6f <lwip_setsockopt_internal+0xee>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800e3b:	83 fa 01             	cmp    $0x1,%edx
  800e3e:	74 07                	je     800e47 <lwip_setsockopt_internal+0xc6>
  800e40:	83 fa 02             	cmp    $0x2,%edx
  800e43:	74 1d                	je     800e62 <lwip_setsockopt_internal+0xe1>
  800e45:	eb 28                	jmp    800e6f <lwip_setsockopt_internal+0xee>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800e47:	83 3b 00             	cmpl   $0x0,(%ebx)
  800e4a:	74 0b                	je     800e57 <lwip_setsockopt_internal+0xd6>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800e4c:	8b 01                	mov    (%ecx),%eax
  800e4e:	8b 40 08             	mov    0x8(%eax),%eax
  800e51:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800e55:	eb 18                	jmp    800e6f <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800e57:	8b 01                	mov    (%ecx),%eax
  800e59:	8b 40 08             	mov    0x8(%eax),%eax
  800e5c:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800e60:	eb 0d                	jmp    800e6f <lwip_setsockopt_internal+0xee>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800e62:	8b 01                	mov    (%ecx),%eax
  800e64:	8b 40 08             	mov    0x8(%eax),%eax
  800e67:	8b 13                	mov    (%ebx),%edx
  800e69:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800e6f:	83 ec 0c             	sub    $0xc,%esp
  800e72:	8b 01                	mov    (%ecx),%eax
  800e74:	ff 70 10             	pushl  0x10(%eax)
  800e77:	e8 1f 91 00 00       	call   809f9b <sys_sem_signal>
  800e7c:	83 c4 10             	add    $0x10,%esp
}
  800e7f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800e82:	c9                   	leave  
  800e83:	c3                   	ret    

00800e84 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  800e84:	55                   	push   %ebp
  800e85:	89 e5                	mov    %esp,%ebp
  800e87:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800e8a:	6a 01                	push   $0x1
  800e8c:	e8 59 8e 00 00       	call   809cea <sys_sem_new>
  800e91:	a3 84 50 81 00       	mov    %eax,0x815084
  selectsem = sys_sem_new(1);
  800e96:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800e9d:	e8 48 8e 00 00       	call   809cea <sys_sem_new>
  800ea2:	a3 80 50 81 00       	mov    %eax,0x815080
  800ea7:	83 c4 10             	add    $0x10,%esp
}
  800eaa:	c9                   	leave  
  800eab:	c3                   	ret    

00800eac <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  800eac:	55                   	push   %ebp
  800ead:	89 e5                	mov    %esp,%ebp
  800eaf:	57                   	push   %edi
  800eb0:	56                   	push   %esi
  800eb1:	53                   	push   %ebx
  800eb2:	83 ec 3c             	sub    $0x3c,%esp
  800eb5:	8b 7d 10             	mov    0x10(%ebp),%edi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  800eb8:	8b 45 08             	mov    0x8(%ebp),%eax
  800ebb:	e8 f4 f8 ff ff       	call   8007b4 <get_socket>
  800ec0:	89 c6                	mov    %eax,%esi
  if (!sock)
  800ec2:	85 c0                	test   %eax,%eax
  800ec4:	0f 84 84 01 00 00    	je     80104e <lwip_accept+0x1a2>
    return -1;

  newconn = netconn_accept(sock->conn);
  800eca:	83 ec 0c             	sub    $0xc,%esp
  800ecd:	ff 30                	pushl  (%eax)
  800ecf:	e8 1c 9f 00 00       	call   80adf0 <netconn_accept>
  800ed4:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800ed6:	83 c4 10             	add    $0x10,%esp
  800ed9:	85 c0                	test   %eax,%eax
  800edb:	75 2c                	jne    800f09 <lwip_accept+0x5d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800edd:	8b 06                	mov    (%esi),%eax
  800edf:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800ee3:	f7 d8                	neg    %eax
  800ee5:	ba 05 00 00 00       	mov    $0x5,%edx
  800eea:	83 f8 0e             	cmp    $0xe,%eax
  800eed:	77 07                	ja     800ef6 <lwip_accept+0x4a>
  800eef:	8b 14 85 20 10 81 00 	mov    0x811020(,%eax,4),%edx
  800ef6:	89 56 10             	mov    %edx,0x10(%esi)
  800ef9:	89 15 20 b3 b3 00    	mov    %edx,0xb3b320
    return -1;
  800eff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f04:	e9 4a 01 00 00       	jmp    801053 <lwip_accept+0x1a7>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  800f09:	6a 00                	push   $0x0
  800f0b:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800f0e:	50                   	push   %eax
  800f0f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800f12:	50                   	push   %eax
  800f13:	53                   	push   %ebx
  800f14:	e8 21 9d 00 00       	call   80ac3a <netconn_getaddr>
  800f19:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800f1c:	83 c4 10             	add    $0x10,%esp
  800f1f:	84 c0                	test   %al,%al
  800f21:	74 36                	je     800f59 <lwip_accept+0xad>
    netconn_delete(newconn);
  800f23:	83 ec 0c             	sub    $0xc,%esp
  800f26:	53                   	push   %ebx
  800f27:	e8 a6 9c 00 00       	call   80abd2 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800f2c:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800f30:	f7 d8                	neg    %eax
  800f32:	83 c4 10             	add    $0x10,%esp
  800f35:	ba 05 00 00 00       	mov    $0x5,%edx
  800f3a:	83 f8 0e             	cmp    $0xe,%eax
  800f3d:	77 07                	ja     800f46 <lwip_accept+0x9a>
  800f3f:	8b 14 85 20 10 81 00 	mov    0x811020(,%eax,4),%edx
  800f46:	89 56 10             	mov    %edx,0x10(%esi)
  800f49:	89 15 20 b3 b3 00    	mov    %edx,0xb3b320
    return -1;
  800f4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f54:	e9 fa 00 00 00       	jmp    801053 <lwip_accept+0x1a7>
  }

  memset(&sin, 0, sizeof(sin));
  800f59:	83 ec 04             	sub    $0x4,%esp
  800f5c:	6a 10                	push   $0x10
  800f5e:	6a 00                	push   $0x0
  800f60:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f63:	50                   	push   %eax
  800f64:	e8 1d dc 00 00       	call   80eb86 <memset>
  sin.sin_len = sizeof(sin);
  800f69:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800f6d:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800f71:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800f75:	89 04 24             	mov    %eax,(%esp)
  800f78:	e8 d0 66 00 00       	call   80764d <htons>
  800f7d:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800f81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800f84:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  800f87:	83 c4 10             	add    $0x10,%esp
  800f8a:	83 3f 10             	cmpl   $0x10,(%edi)
  800f8d:	76 06                	jbe    800f95 <lwip_accept+0xe9>
    *addrlen = sizeof(sin);
  800f8f:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(addr, &sin, *addrlen);
  800f95:	83 ec 04             	sub    $0x4,%esp
  800f98:	ff 37                	pushl  (%edi)
  800f9a:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f9d:	50                   	push   %eax
  800f9e:	ff 75 0c             	pushl  0xc(%ebp)
  800fa1:	e8 95 dc 00 00       	call   80ec3b <memcpy>

  newsock = alloc_socket(newconn);
  800fa6:	89 d8                	mov    %ebx,%eax
  800fa8:	e8 9f fb ff ff       	call   800b4c <alloc_socket>
  800fad:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800faf:	83 c4 10             	add    $0x10,%esp
  800fb2:	83 f8 ff             	cmp    $0xffffffff,%eax
  800fb5:	75 24                	jne    800fdb <lwip_accept+0x12f>
    netconn_delete(newconn);
  800fb7:	83 ec 0c             	sub    $0xc,%esp
  800fba:	53                   	push   %ebx
  800fbb:	e8 12 9c 00 00       	call   80abd2 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800fc0:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800fc7:	c7 05 20 b3 b3 00 17 	movl   $0x17,0xb3b320
  800fce:	00 00 00 
    return -1;
  800fd1:	83 c4 10             	add    $0x10,%esp
  800fd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800fd9:	eb 78                	jmp    801053 <lwip_accept+0x1a7>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800fdb:	83 f8 1f             	cmp    $0x1f,%eax
  800fde:	76 17                	jbe    800ff7 <lwip_accept+0x14b>
  800fe0:	83 ec 04             	sub    $0x4,%esp
  800fe3:	68 91 0f 81 00       	push   $0x810f91
  800fe8:	68 25 01 00 00       	push   $0x125
  800fed:	68 6e 0f 81 00       	push   $0x810f6e
  800ff2:	e8 ea d3 00 00       	call   80e3e1 <_panic>
  newconn->callback = event_callback;
  800ff7:	c7 43 2c ac 09 80 00 	movl   $0x8009ac,0x2c(%ebx)
  nsock = &sockets[newsock];
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  800ffe:	83 ec 0c             	sub    $0xc,%esp
  801001:	ff 35 84 50 81 00    	pushl  0x815084
  801007:	e8 a6 40 00 00       	call   8050b2 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  80100c:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  80100f:	8d 14 85 c0 50 81 00 	lea    0x8150c0(,%eax,4),%edx
  801016:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  80101a:	83 e8 01             	sub    $0x1,%eax
  80101d:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  801021:	66 89 42 0a          	mov    %ax,0xa(%edx)
  newconn->socket = newsock;
  801025:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  801028:	83 c4 04             	add    $0x4,%esp
  80102b:	ff 35 84 50 81 00    	pushl  0x815084
  801031:	e8 65 8f 00 00       	call   809f9b <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  801036:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80103d:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  801044:	00 00 00 
  return newsock;
  801047:	83 c4 10             	add    $0x10,%esp
  80104a:	89 f8                	mov    %edi,%eax
  80104c:	eb 05                	jmp    801053 <lwip_accept+0x1a7>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  80104e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  801053:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801056:	5b                   	pop    %ebx
  801057:	5e                   	pop    %esi
  801058:	5f                   	pop    %edi
  801059:	5d                   	pop    %ebp
  80105a:	c3                   	ret    

0080105b <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80105b:	55                   	push   %ebp
  80105c:	89 e5                	mov    %esp,%ebp
  80105e:	56                   	push   %esi
  80105f:	53                   	push   %ebx
  801060:	83 ec 10             	sub    $0x10,%esp
  801063:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  801066:	8b 45 08             	mov    0x8(%ebp),%eax
  801069:	e8 46 f7 ff ff       	call   8007b4 <get_socket>
  80106e:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801070:	85 c0                	test   %eax,%eax
  801072:	0f 84 8d 00 00 00    	je     801105 <lwip_bind+0xaa>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801078:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80107c:	75 06                	jne    801084 <lwip_bind+0x29>
  80107e:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801082:	74 17                	je     80109b <lwip_bind+0x40>
  801084:	83 ec 04             	sub    $0x4,%esp
  801087:	68 a6 0f 81 00       	push   $0x810fa6
  80108c:	68 4a 01 00 00       	push   $0x14a
  801091:	68 6e 0f 81 00       	push   $0x810f6e
  801096:	e8 46 d3 00 00       	call   80e3e1 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80109b:	8b 46 04             	mov    0x4(%esi),%eax
  80109e:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8010a1:	83 ec 0c             	sub    $0xc,%esp
  8010a4:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8010a8:	50                   	push   %eax
  8010a9:	e8 ac 65 00 00       	call   80765a <ntohs>
  8010ae:	83 c4 0c             	add    $0xc,%esp
  8010b1:	0f b7 c0             	movzwl %ax,%eax
  8010b4:	50                   	push   %eax
  8010b5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8010b8:	50                   	push   %eax
  8010b9:	ff 33                	pushl  (%ebx)
  8010bb:	e8 06 9c 00 00       	call   80acc6 <netconn_bind>

  if (err != ERR_OK) {
  8010c0:	83 c4 10             	add    $0x10,%esp
  8010c3:	84 c0                	test   %al,%al
  8010c5:	74 26                	je     8010ed <lwip_bind+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8010c7:	0f be c0             	movsbl %al,%eax
  8010ca:	f7 d8                	neg    %eax
  8010cc:	ba 05 00 00 00       	mov    $0x5,%edx
  8010d1:	83 f8 0e             	cmp    $0xe,%eax
  8010d4:	77 07                	ja     8010dd <lwip_bind+0x82>
  8010d6:	8b 14 85 20 10 81 00 	mov    0x811020(,%eax,4),%edx
  8010dd:	89 53 10             	mov    %edx,0x10(%ebx)
  8010e0:	89 15 20 b3 b3 00    	mov    %edx,0xb3b320
    return -1;
  8010e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010eb:	eb 1d                	jmp    80110a <lwip_bind+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8010ed:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010f4:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  8010fb:	00 00 00 
  return 0;
  8010fe:	b8 00 00 00 00       	mov    $0x0,%eax
  801103:	eb 05                	jmp    80110a <lwip_bind+0xaf>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801105:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  80110a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80110d:	5b                   	pop    %ebx
  80110e:	5e                   	pop    %esi
  80110f:	5d                   	pop    %ebp
  801110:	c3                   	ret    

00801111 <lwip_close>:

int
lwip_close(int s)
{
  801111:	55                   	push   %ebp
  801112:	89 e5                	mov    %esp,%ebp
  801114:	53                   	push   %ebx
  801115:	83 ec 04             	sub    $0x4,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  801118:	8b 45 08             	mov    0x8(%ebp),%eax
  80111b:	e8 94 f6 ff ff       	call   8007b4 <get_socket>
  801120:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  801122:	85 c0                	test   %eax,%eax
  801124:	74 6a                	je     801190 <lwip_close+0x7f>
    return -1;
  }

  netconn_delete(sock->conn);
  801126:	83 ec 0c             	sub    $0xc,%esp
  801129:	ff 30                	pushl  (%eax)
  80112b:	e8 a2 9a 00 00       	call   80abd2 <netconn_delete>

  sys_sem_wait(socksem);
  801130:	83 c4 04             	add    $0x4,%esp
  801133:	ff 35 84 50 81 00    	pushl  0x815084
  801139:	e8 74 3f 00 00       	call   8050b2 <sys_sem_wait>
  if (sock->lastdata) {
  80113e:	8b 43 04             	mov    0x4(%ebx),%eax
  801141:	83 c4 10             	add    $0x10,%esp
  801144:	85 c0                	test   %eax,%eax
  801146:	74 0c                	je     801154 <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  801148:	83 ec 0c             	sub    $0xc,%esp
  80114b:	50                   	push   %eax
  80114c:	e8 77 13 00 00       	call   8024c8 <netbuf_delete>
  801151:	83 c4 10             	add    $0x10,%esp
  }
  sock->lastdata   = NULL;
  801154:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  80115b:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  801161:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801167:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80116e:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  801175:	00 00 00 
  sys_sem_signal(socksem);
  801178:	83 ec 0c             	sub    $0xc,%esp
  80117b:	ff 35 84 50 81 00    	pushl  0x815084
  801181:	e8 15 8e 00 00       	call   809f9b <sys_sem_signal>
  return 0;
  801186:	83 c4 10             	add    $0x10,%esp
  801189:	b8 00 00 00 00       	mov    $0x0,%eax
  80118e:	eb 05                	jmp    801195 <lwip_close+0x84>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  801190:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  801195:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801198:	c9                   	leave  
  801199:	c3                   	ret    

0080119a <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80119a:	55                   	push   %ebp
  80119b:	89 e5                	mov    %esp,%ebp
  80119d:	56                   	push   %esi
  80119e:	53                   	push   %ebx
  80119f:	83 ec 10             	sub    $0x10,%esp
  8011a2:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  8011a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8011a8:	e8 07 f6 ff ff       	call   8007b4 <get_socket>
  8011ad:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8011af:	85 c0                	test   %eax,%eax
  8011b1:	0f 84 8d 00 00 00    	je     801244 <lwip_connect+0xaa>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8011b7:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8011bb:	75 06                	jne    8011c3 <lwip_connect+0x29>
  8011bd:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8011c1:	74 17                	je     8011da <lwip_connect+0x40>
  8011c3:	83 ec 04             	sub    $0x4,%esp
  8011c6:	68 c1 0f 81 00       	push   $0x810fc1
  8011cb:	68 86 01 00 00       	push   $0x186
  8011d0:	68 6e 0f 81 00       	push   $0x810f6e
  8011d5:	e8 07 d2 00 00       	call   80e3e1 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8011da:	8b 46 04             	mov    0x4(%esi),%eax
  8011dd:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8011e0:	83 ec 0c             	sub    $0xc,%esp
  8011e3:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8011e7:	50                   	push   %eax
  8011e8:	e8 6d 64 00 00       	call   80765a <ntohs>
  8011ed:	83 c4 0c             	add    $0xc,%esp
  8011f0:	0f b7 c0             	movzwl %ax,%eax
  8011f3:	50                   	push   %eax
  8011f4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8011f7:	50                   	push   %eax
  8011f8:	ff 33                	pushl  (%ebx)
  8011fa:	e8 18 9b 00 00       	call   80ad17 <netconn_connect>
  }

  if (err != ERR_OK) {
  8011ff:	83 c4 10             	add    $0x10,%esp
  801202:	84 c0                	test   %al,%al
  801204:	74 26                	je     80122c <lwip_connect+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801206:	0f be c0             	movsbl %al,%eax
  801209:	f7 d8                	neg    %eax
  80120b:	ba 05 00 00 00       	mov    $0x5,%edx
  801210:	83 f8 0e             	cmp    $0xe,%eax
  801213:	77 07                	ja     80121c <lwip_connect+0x82>
  801215:	8b 14 85 20 10 81 00 	mov    0x811020(,%eax,4),%edx
  80121c:	89 53 10             	mov    %edx,0x10(%ebx)
  80121f:	89 15 20 b3 b3 00    	mov    %edx,0xb3b320
    return -1;
  801225:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80122a:	eb 1d                	jmp    801249 <lwip_connect+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80122c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801233:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  80123a:	00 00 00 
  return 0;
  80123d:	b8 00 00 00 00       	mov    $0x0,%eax
  801242:	eb 05                	jmp    801249 <lwip_connect+0xaf>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801244:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  801249:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80124c:	5b                   	pop    %ebx
  80124d:	5e                   	pop    %esi
  80124e:	5d                   	pop    %ebp
  80124f:	c3                   	ret    

00801250 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801250:	55                   	push   %ebp
  801251:	89 e5                	mov    %esp,%ebp
  801253:	56                   	push   %esi
  801254:	53                   	push   %ebx
  801255:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  801258:	8b 45 08             	mov    0x8(%ebp),%eax
  80125b:	e8 54 f5 ff ff       	call   8007b4 <get_socket>
  801260:	89 c6                	mov    %eax,%esi
  if (!sock)
  801262:	85 c0                	test   %eax,%eax
  801264:	74 68                	je     8012ce <lwip_listen+0x7e>
  801266:	85 db                	test   %ebx,%ebx
  801268:	b8 00 00 00 00       	mov    $0x0,%eax
  80126d:	0f 48 d8             	cmovs  %eax,%ebx
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  801270:	83 ec 08             	sub    $0x8,%esp
  801273:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  801279:	b0 ff                	mov    $0xff,%al
  80127b:	0f 4f d8             	cmovg  %eax,%ebx
  80127e:	0f b6 db             	movzbl %bl,%ebx
  801281:	53                   	push   %ebx
  801282:	ff 36                	pushl  (%esi)
  801284:	e8 23 9b 00 00       	call   80adac <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  801289:	83 c4 10             	add    $0x10,%esp
  80128c:	84 c0                	test   %al,%al
  80128e:	74 26                	je     8012b6 <lwip_listen+0x66>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801290:	0f be c0             	movsbl %al,%eax
  801293:	f7 d8                	neg    %eax
  801295:	ba 05 00 00 00       	mov    $0x5,%edx
  80129a:	83 f8 0e             	cmp    $0xe,%eax
  80129d:	77 07                	ja     8012a6 <lwip_listen+0x56>
  80129f:	8b 14 85 20 10 81 00 	mov    0x811020(,%eax,4),%edx
  8012a6:	89 56 10             	mov    %edx,0x10(%esi)
  8012a9:	89 15 20 b3 b3 00    	mov    %edx,0xb3b320
    return -1;
  8012af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012b4:	eb 1d                	jmp    8012d3 <lwip_listen+0x83>
  }

  sock_set_errno(sock, 0);
  8012b6:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8012bd:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  8012c4:	00 00 00 
  return 0;
  8012c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8012cc:	eb 05                	jmp    8012d3 <lwip_listen+0x83>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  8012ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  8012d3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8012d6:	5b                   	pop    %ebx
  8012d7:	5e                   	pop    %esi
  8012d8:	5d                   	pop    %ebp
  8012d9:	c3                   	ret    

008012da <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8012da:	55                   	push   %ebp
  8012db:	89 e5                	mov    %esp,%ebp
  8012dd:	57                   	push   %edi
  8012de:	56                   	push   %esi
  8012df:	53                   	push   %ebx
  8012e0:	83 ec 4c             	sub    $0x4c,%esp
  8012e3:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8012e6:	8b 45 08             	mov    0x8(%ebp),%eax
  8012e9:	e8 c6 f4 ff ff       	call   8007b4 <get_socket>
  8012ee:	89 c7                	mov    %eax,%edi
  if (!sock)
  8012f0:	85 c0                	test   %eax,%eax
  8012f2:	0f 84 02 02 00 00    	je     8014fa <lwip_recvfrom+0x220>
  8012f8:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8012fe:	89 d8                	mov    %ebx,%eax
  801300:	83 e0 08             	and    $0x8,%eax
  801303:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801306:	83 e3 01             	and    $0x1,%ebx
  801309:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80130c:	8b 77 04             	mov    0x4(%edi),%esi
  80130f:	85 f6                	test   %esi,%esi
  801311:	0f 85 80 00 00 00    	jne    801397 <lwip_recvfrom+0xbd>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801317:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  80131b:	75 06                	jne    801323 <lwip_recvfrom+0x49>
  80131d:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801321:	74 22                	je     801345 <lwip_recvfrom+0x6b>
  801323:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801328:	75 1b                	jne    801345 <lwip_recvfrom+0x6b>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  80132a:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  801331:	c7 05 20 b3 b3 00 0b 	movl   $0xb,0xb3b320
  801338:	00 00 00 
        return -1;
  80133b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801340:	e9 ba 01 00 00       	jmp    8014ff <lwip_recvfrom+0x225>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  801345:	83 ec 0c             	sub    $0xc,%esp
  801348:	ff 37                	pushl  (%edi)
  80134a:	e8 13 9b 00 00       	call   80ae62 <netconn_recv>
  80134f:	89 c6                	mov    %eax,%esi
  801351:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  801354:	83 c4 10             	add    $0x10,%esp
  801357:	85 c0                	test   %eax,%eax
  801359:	75 3c                	jne    801397 <lwip_recvfrom+0xbd>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  80135b:	8b 17                	mov    (%edi),%edx
  80135d:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  801361:	74 0b                	je     80136e <lwip_recvfrom+0x94>
  801363:	b8 6e 00 00 00       	mov    $0x6e,%eax
  801368:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  80136c:	74 17                	je     801385 <lwip_recvfrom+0xab>
  80136e:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  801372:	f7 da                	neg    %edx
  801374:	b8 05 00 00 00       	mov    $0x5,%eax
  801379:	83 fa 0e             	cmp    $0xe,%edx
  80137c:	77 07                	ja     801385 <lwip_recvfrom+0xab>
  80137e:	8b 04 95 20 10 81 00 	mov    0x811020(,%edx,4),%eax
  801385:	89 47 10             	mov    %eax,0x10(%edi)
  801388:	a3 20 b3 b3 00       	mov    %eax,0xb3b320
        return 0;
  80138d:	b8 00 00 00 00       	mov    $0x0,%eax
  801392:	e9 68 01 00 00       	jmp    8014ff <lwip_recvfrom+0x225>
      }
    }

    buflen = netbuf_len(buf);
  801397:	8b 16                	mov    (%esi),%edx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  801399:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80139d:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  8013a1:	29 c3                	sub    %eax,%ebx

    if (len > buflen) {
  8013a3:	0f b7 cb             	movzwl %bx,%ecx
  8013a6:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  8013a9:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  8013ac:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8013b1:	0f b7 cb             	movzwl %bx,%ecx
  8013b4:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8013b7:	0f b7 c0             	movzwl %ax,%eax
  8013ba:	50                   	push   %eax
  8013bb:	51                   	push   %ecx
  8013bc:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8013c0:	03 45 0c             	add    0xc(%ebp),%eax
  8013c3:	50                   	push   %eax
  8013c4:	52                   	push   %edx
  8013c5:	e8 7b 3b 00 00       	call   804f45 <pbuf_copy_partial>

    off += copylen;
  8013ca:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013ce:	83 c4 04             	add    $0x4,%esp
  8013d1:	ff 37                	pushl  (%edi)
  8013d3:	e8 3a 98 00 00       	call   80ac12 <netconn_type>
  8013d8:	83 c4 10             	add    $0x10,%esp
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  8013db:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013df:	83 f8 10             	cmp    $0x10,%eax
  8013e2:	75 1d                	jne    801401 <lwip_recvfrom+0x127>
      len -= copylen;
  8013e4:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8013e7:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8013ea:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8013ee:	7e 11                	jle    801401 <lwip_recvfrom+0x127>
  8013f0:	8b 06                	mov    (%esi),%eax
  8013f2:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8013f6:	75 09                	jne    801401 <lwip_recvfrom+0x127>
  8013f8:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8013fd:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801401:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  801405:	75 3d                	jne    801444 <lwip_recvfrom+0x16a>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801407:	8b 07                	mov    (%edi),%eax
  801409:	83 38 10             	cmpl   $0x10,(%eax)
  80140c:	75 13                	jne    801421 <lwip_recvfrom+0x147>
  80140e:	8b 45 bc             	mov    -0x44(%ebp),%eax
  801411:	2b 45 c0             	sub    -0x40(%ebp),%eax
  801414:	85 c0                	test   %eax,%eax
  801416:	7e 09                	jle    801421 <lwip_recvfrom+0x147>
        sock->lastdata = buf;
  801418:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  80141b:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  80141f:	eb 19                	jmp    80143a <lwip_recvfrom+0x160>
      } else {
        sock->lastdata = NULL;
  801421:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  801428:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80142e:	83 ec 0c             	sub    $0xc,%esp
  801431:	56                   	push   %esi
  801432:	e8 91 10 00 00       	call   8024c8 <netbuf_delete>
  801437:	83 c4 10             	add    $0x10,%esp
      }
    } else {
      done = 1;
    }
  } while (!done);
  80143a:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80143e:	0f 84 c8 fe ff ff    	je     80130c <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  801444:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801448:	0f 84 95 00 00 00    	je     8014e3 <lwip_recvfrom+0x209>
  80144e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801452:	0f 84 8b 00 00 00    	je     8014e3 <lwip_recvfrom+0x209>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801458:	83 ec 0c             	sub    $0xc,%esp
  80145b:	ff 37                	pushl  (%edi)
  80145d:	e8 b0 97 00 00       	call   80ac12 <netconn_type>
  801462:	83 c4 10             	add    $0x10,%esp
  801465:	83 f8 10             	cmp    $0x10,%eax
  801468:	75 19                	jne    801483 <lwip_recvfrom+0x1a9>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  80146a:	6a 00                	push   $0x0
  80146c:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  80146f:	50                   	push   %eax
  801470:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801473:	50                   	push   %eax
  801474:	ff 37                	pushl  (%edi)
  801476:	e8 bf 97 00 00       	call   80ac3a <netconn_getaddr>
  80147b:	83 c4 10             	add    $0x10,%esp
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80147e:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  801481:	eb 0b                	jmp    80148e <lwip_recvfrom+0x1b4>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  801483:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  801486:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80148a:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  80148e:	83 ec 04             	sub    $0x4,%esp
  801491:	6a 10                	push   $0x10
  801493:	6a 00                	push   $0x0
  801495:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801498:	50                   	push   %eax
  801499:	e8 e8 d6 00 00       	call   80eb86 <memset>
    sin.sin_len = sizeof(sin);
  80149e:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8014a2:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8014a6:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8014aa:	89 04 24             	mov    %eax,(%esp)
  8014ad:	e8 9b 61 00 00       	call   80764d <htons>
  8014b2:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8014b6:	8b 03                	mov    (%ebx),%eax
  8014b8:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8014bb:	83 c4 10             	add    $0x10,%esp
  8014be:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014c1:	83 38 10             	cmpl   $0x10,(%eax)
  8014c4:	76 06                	jbe    8014cc <lwip_recvfrom+0x1f2>
      *fromlen = sizeof(sin);
  8014c6:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  8014cc:	83 ec 04             	sub    $0x4,%esp
  8014cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014d2:	ff 30                	pushl  (%eax)
  8014d4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8014d7:	50                   	push   %eax
  8014d8:	ff 75 18             	pushl  0x18(%ebp)
  8014db:	e8 5b d7 00 00       	call   80ec3b <memcpy>
  8014e0:	83 c4 10             	add    $0x10,%esp
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8014e3:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8014ea:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  8014f1:	00 00 00 
  return off;
  8014f4:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8014f8:	eb 05                	jmp    8014ff <lwip_recvfrom+0x225>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  8014fa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  8014ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801502:	5b                   	pop    %ebx
  801503:	5e                   	pop    %esi
  801504:	5f                   	pop    %edi
  801505:	5d                   	pop    %ebp
  801506:	c3                   	ret    

00801507 <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  801507:	55                   	push   %ebp
  801508:	89 e5                	mov    %esp,%ebp
  80150a:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  80150d:	6a 00                	push   $0x0
  80150f:	6a 00                	push   $0x0
  801511:	6a 00                	push   $0x0
  801513:	ff 75 10             	pushl  0x10(%ebp)
  801516:	ff 75 0c             	pushl  0xc(%ebp)
  801519:	ff 75 08             	pushl  0x8(%ebp)
  80151c:	e8 b9 fd ff ff       	call   8012da <lwip_recvfrom>
}
  801521:	c9                   	leave  
  801522:	c3                   	ret    

00801523 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  801523:	55                   	push   %ebp
  801524:	89 e5                	mov    %esp,%ebp
  801526:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801529:	6a 00                	push   $0x0
  80152b:	6a 00                	push   $0x0
  80152d:	ff 75 14             	pushl  0x14(%ebp)
  801530:	ff 75 10             	pushl  0x10(%ebp)
  801533:	ff 75 0c             	pushl  0xc(%ebp)
  801536:	ff 75 08             	pushl  0x8(%ebp)
  801539:	e8 9c fd ff ff       	call   8012da <lwip_recvfrom>
}
  80153e:	c9                   	leave  
  80153f:	c3                   	ret    

00801540 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  801540:	55                   	push   %ebp
  801541:	89 e5                	mov    %esp,%ebp
  801543:	57                   	push   %edi
  801544:	56                   	push   %esi
  801545:	53                   	push   %ebx
  801546:	83 ec 2c             	sub    $0x2c,%esp
  801549:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80154c:	8b 7d 18             	mov    0x18(%ebp),%edi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80154f:	8b 45 08             	mov    0x8(%ebp),%eax
  801552:	e8 5d f2 ff ff       	call   8007b4 <get_socket>
  801557:	89 c6                	mov    %eax,%esi
  if (!sock)
  801559:	85 c0                	test   %eax,%eax
  80155b:	0f 84 22 01 00 00    	je     801683 <lwip_sendto+0x143>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  801561:	8b 00                	mov    (%eax),%eax
  801563:	83 38 10             	cmpl   $0x10,(%eax)
  801566:	75 17                	jne    80157f <lwip_sendto+0x3f>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  801568:	ff 75 14             	pushl  0x14(%ebp)
  80156b:	53                   	push   %ebx
  80156c:	ff 75 0c             	pushl  0xc(%ebp)
  80156f:	ff 75 08             	pushl  0x8(%ebp)
  801572:	e8 19 01 00 00       	call   801690 <lwip_send>
  801577:	83 c4 10             	add    $0x10,%esp
  80157a:	e9 09 01 00 00       	jmp    801688 <lwip_sendto+0x148>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  80157f:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  801585:	76 17                	jbe    80159e <lwip_sendto+0x5e>
  801587:	83 ec 04             	sub    $0x4,%esp
  80158a:	68 fc 0f 81 00       	push   $0x810ffc
  80158f:	68 97 02 00 00       	push   $0x297
  801594:	68 6e 0f 81 00       	push   $0x810f6e
  801599:	e8 43 ce 00 00       	call   80e3e1 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  80159e:	85 ff                	test   %edi,%edi
  8015a0:	0f 95 c0             	setne  %al
  8015a3:	75 06                	jne    8015ab <lwip_sendto+0x6b>
  8015a5:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8015a9:	74 23                	je     8015ce <lwip_sendto+0x8e>
  8015ab:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8015af:	75 06                	jne    8015b7 <lwip_sendto+0x77>
  8015b1:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  8015b5:	74 17                	je     8015ce <lwip_sendto+0x8e>
  8015b7:	83 ec 04             	sub    $0x4,%esp
  8015ba:	68 df 0f 81 00       	push   $0x810fdf
  8015bf:	68 9b 02 00 00       	push   $0x29b
  8015c4:	68 6e 0f 81 00       	push   $0x810f6e
  8015c9:	e8 13 ce 00 00       	call   80e3e1 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8015ce:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8015d5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  8015dc:	84 c0                	test   %al,%al
  8015de:	74 22                	je     801602 <lwip_sendto+0xc2>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8015e0:	8b 47 04             	mov    0x4(%edi),%eax
  8015e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8015e6:	83 ec 0c             	sub    $0xc,%esp
  8015e9:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8015ed:	50                   	push   %eax
  8015ee:	e8 67 60 00 00       	call   80765a <ntohs>
    buf.addr         = &remote_addr;
  8015f3:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8015f6:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  8015f9:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  8015fd:	83 c4 10             	add    $0x10,%esp
  801600:	eb 14                	jmp    801616 <lwip_sendto+0xd6>
  } else {
    remote_addr.addr = 0;
  801602:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801609:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801610:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801616:	83 ec 04             	sub    $0x4,%esp
  801619:	0f b7 c3             	movzwl %bx,%eax
  80161c:	50                   	push   %eax
  80161d:	ff 75 0c             	pushl  0xc(%ebp)
  801620:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801623:	50                   	push   %eax
  801624:	e8 a1 0f 00 00       	call   8025ca <netbuf_ref>
  801629:	0f be f8             	movsbl %al,%edi
  80162c:	83 c4 10             	add    $0x10,%esp
  80162f:	85 ff                	test   %edi,%edi
  801631:	75 14                	jne    801647 <lwip_sendto+0x107>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801633:	83 ec 08             	sub    $0x8,%esp
  801636:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801639:	50                   	push   %eax
  80163a:	ff 36                	pushl  (%esi)
  80163c:	e8 c1 99 00 00       	call   80b002 <netconn_send>
  801641:	0f be f8             	movsbl %al,%edi
  801644:	83 c4 10             	add    $0x10,%esp
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  801647:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80164a:	85 c0                	test   %eax,%eax
  80164c:	74 0c                	je     80165a <lwip_sendto+0x11a>
    pbuf_free(buf.p);
  80164e:	83 ec 0c             	sub    $0xc,%esp
  801651:	50                   	push   %eax
  801652:	e8 98 31 00 00       	call   8047ef <pbuf_free>
  801657:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  80165a:	89 fa                	mov    %edi,%edx
  80165c:	f7 da                	neg    %edx
  80165e:	b8 05 00 00 00       	mov    $0x5,%eax
  801663:	83 fa 0e             	cmp    $0xe,%edx
  801666:	77 07                	ja     80166f <lwip_sendto+0x12f>
  801668:	8b 04 95 20 10 81 00 	mov    0x811020(,%edx,4),%eax
  80166f:	89 46 10             	mov    %eax,0x10(%esi)
  801672:	a3 20 b3 b3 00       	mov    %eax,0xb3b320
  return (err==ERR_OK?size:-1);
  801677:	85 ff                	test   %edi,%edi
  801679:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80167e:	0f 44 c3             	cmove  %ebx,%eax
  801681:	eb 05                	jmp    801688 <lwip_sendto+0x148>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  801683:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801688:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80168b:	5b                   	pop    %ebx
  80168c:	5e                   	pop    %esi
  80168d:	5f                   	pop    %edi
  80168e:	5d                   	pop    %ebp
  80168f:	c3                   	ret    

00801690 <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  801690:	55                   	push   %ebp
  801691:	89 e5                	mov    %esp,%ebp
  801693:	57                   	push   %edi
  801694:	56                   	push   %esi
  801695:	53                   	push   %ebx
  801696:	83 ec 0c             	sub    $0xc,%esp
  801699:	8b 7d 08             	mov    0x8(%ebp),%edi
  80169c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80169f:	89 f8                	mov    %edi,%eax
  8016a1:	e8 0e f1 ff ff       	call   8007b4 <get_socket>
  8016a6:	89 c6                	mov    %eax,%esi
  if (!sock)
  8016a8:	85 c0                	test   %eax,%eax
  8016aa:	74 6a                	je     801716 <lwip_send+0x86>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8016ac:	8b 08                	mov    (%eax),%ecx
  8016ae:	83 39 10             	cmpl   $0x10,(%ecx)
  8016b1:	74 19                	je     8016cc <lwip_send+0x3c>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8016b3:	83 ec 08             	sub    $0x8,%esp
  8016b6:	6a 00                	push   $0x0
  8016b8:	6a 00                	push   $0x0
  8016ba:	ff 75 14             	pushl  0x14(%ebp)
  8016bd:	53                   	push   %ebx
  8016be:	ff 75 0c             	pushl  0xc(%ebp)
  8016c1:	57                   	push   %edi
  8016c2:	e8 79 fe ff ff       	call   801540 <lwip_sendto>
  8016c7:	83 c4 20             	add    $0x20,%esp
  8016ca:	eb 4f                	jmp    80171b <lwip_send+0x8b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8016cc:	8b 55 14             	mov    0x14(%ebp),%edx
  8016cf:	83 e2 10             	and    $0x10,%edx
  8016d2:	83 fa 01             	cmp    $0x1,%edx
  8016d5:	19 c0                	sbb    %eax,%eax
  8016d7:	83 e0 fe             	and    $0xfffffffe,%eax
  8016da:	83 c0 03             	add    $0x3,%eax
  8016dd:	50                   	push   %eax
  8016de:	53                   	push   %ebx
  8016df:	ff 75 0c             	pushl  0xc(%ebp)
  8016e2:	51                   	push   %ecx
  8016e3:	e8 96 99 00 00       	call   80b07e <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8016e8:	0f be d0             	movsbl %al,%edx
  8016eb:	f7 da                	neg    %edx
  8016ed:	83 c4 10             	add    $0x10,%esp
  8016f0:	b9 05 00 00 00       	mov    $0x5,%ecx
  8016f5:	83 fa 0e             	cmp    $0xe,%edx
  8016f8:	77 07                	ja     801701 <lwip_send+0x71>
  8016fa:	8b 0c 95 20 10 81 00 	mov    0x811020(,%edx,4),%ecx
  801701:	89 4e 10             	mov    %ecx,0x10(%esi)
  801704:	89 0d 20 b3 b3 00    	mov    %ecx,0xb3b320
  return (err==ERR_OK?size:-1);
  80170a:	84 c0                	test   %al,%al
  80170c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801711:	0f 44 c3             	cmove  %ebx,%eax
  801714:	eb 05                	jmp    80171b <lwip_send+0x8b>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801716:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  80171b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80171e:	5b                   	pop    %ebx
  80171f:	5e                   	pop    %esi
  801720:	5f                   	pop    %edi
  801721:	5d                   	pop    %ebp
  801722:	c3                   	ret    

00801723 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  801723:	55                   	push   %ebp
  801724:	89 e5                	mov    %esp,%ebp
  801726:	53                   	push   %ebx
  801727:	83 ec 04             	sub    $0x4,%esp
  80172a:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  80172d:	83 f8 02             	cmp    $0x2,%eax
  801730:	74 27                	je     801759 <lwip_socket+0x36>
  801732:	83 f8 03             	cmp    $0x3,%eax
  801735:	74 07                	je     80173e <lwip_socket+0x1b>
  801737:	83 f8 01             	cmp    $0x1,%eax
  80173a:	75 5c                	jne    801798 <lwip_socket+0x75>
  80173c:	eb 42                	jmp    801780 <lwip_socket+0x5d>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  80173e:	83 ec 04             	sub    $0x4,%esp
  801741:	68 ac 09 80 00       	push   $0x8009ac
  801746:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  80174a:	50                   	push   %eax
  80174b:	6a 40                	push   $0x40
  80174d:	e8 92 93 00 00       	call   80aae4 <netconn_new_with_proto_and_callback>
  801752:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801754:	83 c4 10             	add    $0x10,%esp
  801757:	eb 50                	jmp    8017a9 <lwip_socket+0x86>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801759:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  801760:	0f 94 c0             	sete   %al
  801763:	0f b6 c0             	movzbl %al,%eax
  801766:	83 c0 20             	add    $0x20,%eax
  801769:	83 ec 04             	sub    $0x4,%esp
  80176c:	68 ac 09 80 00       	push   $0x8009ac
  801771:	6a 00                	push   $0x0
  801773:	50                   	push   %eax
  801774:	e8 6b 93 00 00       	call   80aae4 <netconn_new_with_proto_and_callback>
  801779:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80177b:	83 c4 10             	add    $0x10,%esp
  80177e:	eb 29                	jmp    8017a9 <lwip_socket+0x86>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  801780:	83 ec 04             	sub    $0x4,%esp
  801783:	68 ac 09 80 00       	push   $0x8009ac
  801788:	6a 00                	push   $0x0
  80178a:	6a 10                	push   $0x10
  80178c:	e8 53 93 00 00       	call   80aae4 <netconn_new_with_proto_and_callback>
  801791:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801793:	83 c4 10             	add    $0x10,%esp
  801796:	eb 11                	jmp    8017a9 <lwip_socket+0x86>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  801798:	c7 05 20 b3 b3 00 16 	movl   $0x16,0xb3b320
  80179f:	00 00 00 
    return -1;
  8017a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017a7:	eb 4b                	jmp    8017f4 <lwip_socket+0xd1>
  }

  if (!conn) {
  8017a9:	85 db                	test   %ebx,%ebx
  8017ab:	75 11                	jne    8017be <lwip_socket+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  8017ad:	c7 05 20 b3 b3 00 69 	movl   $0x69,0xb3b320
  8017b4:	00 00 00 
    return -1;
  8017b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017bc:	eb 36                	jmp    8017f4 <lwip_socket+0xd1>
  }

  i = alloc_socket(conn);
  8017be:	89 d8                	mov    %ebx,%eax
  8017c0:	e8 87 f3 ff ff       	call   800b4c <alloc_socket>

  if (i == -1) {
  8017c5:	83 f8 ff             	cmp    $0xffffffff,%eax
  8017c8:	75 1d                	jne    8017e7 <lwip_socket+0xc4>
    netconn_delete(conn);
  8017ca:	83 ec 0c             	sub    $0xc,%esp
  8017cd:	53                   	push   %ebx
  8017ce:	e8 ff 93 00 00       	call   80abd2 <netconn_delete>
    set_errno(ENFILE);
  8017d3:	c7 05 20 b3 b3 00 17 	movl   $0x17,0xb3b320
  8017da:	00 00 00 
    return -1;
  8017dd:	83 c4 10             	add    $0x10,%esp
  8017e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017e5:	eb 0d                	jmp    8017f4 <lwip_socket+0xd1>
  }
  conn->socket = i;
  8017e7:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  8017ea:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  8017f1:	00 00 00 
  return i;
}
  8017f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8017f7:	c9                   	leave  
  8017f8:	c3                   	ret    

008017f9 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  8017f9:	55                   	push   %ebp
  8017fa:	89 e5                	mov    %esp,%ebp
  8017fc:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  8017ff:	6a 00                	push   $0x0
  801801:	ff 75 10             	pushl  0x10(%ebp)
  801804:	ff 75 0c             	pushl  0xc(%ebp)
  801807:	ff 75 08             	pushl  0x8(%ebp)
  80180a:	e8 81 fe ff ff       	call   801690 <lwip_send>
}
  80180f:	c9                   	leave  
  801810:	c3                   	ret    

00801811 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801811:	55                   	push   %ebp
  801812:	89 e5                	mov    %esp,%ebp
  801814:	57                   	push   %edi
  801815:	56                   	push   %esi
  801816:	53                   	push   %ebx
  801817:	83 ec 48             	sub    $0x48,%esp
  80181a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80181d:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801820:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801827:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  80182a:	8b 45 10             	mov    0x10(%ebp),%eax
  80182d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801830:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801833:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  80183a:	ff 35 80 50 81 00    	pushl  0x815080
  801840:	e8 6d 38 00 00       	call   8050b2 <sys_sem_wait>

  if (readset)
  801845:	83 c4 10             	add    $0x10,%esp
  801848:	85 ff                	test   %edi,%edi
  80184a:	74 07                	je     801853 <lwip_select+0x42>
    lreadset = *readset;
  80184c:	8b 07                	mov    (%edi),%eax
  80184e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801851:	eb 13                	jmp    801866 <lwip_select+0x55>
  else
    FD_ZERO(&lreadset);
  801853:	83 ec 04             	sub    $0x4,%esp
  801856:	6a 04                	push   $0x4
  801858:	6a 00                	push   $0x0
  80185a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80185d:	50                   	push   %eax
  80185e:	e8 23 d3 00 00       	call   80eb86 <memset>
  801863:	83 c4 10             	add    $0x10,%esp
  if (writeset)
  801866:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80186a:	74 0a                	je     801876 <lwip_select+0x65>
    lwriteset = *writeset;
  80186c:	8b 45 10             	mov    0x10(%ebp),%eax
  80186f:	8b 00                	mov    (%eax),%eax
  801871:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801874:	eb 13                	jmp    801889 <lwip_select+0x78>
  else
    FD_ZERO(&lwriteset);
  801876:	83 ec 04             	sub    $0x4,%esp
  801879:	6a 04                	push   $0x4
  80187b:	6a 00                	push   $0x0
  80187d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801880:	50                   	push   %eax
  801881:	e8 00 d3 00 00       	call   80eb86 <memset>
  801886:	83 c4 10             	add    $0x10,%esp
  if (exceptset)
  801889:	85 db                	test   %ebx,%ebx
  80188b:	74 07                	je     801894 <lwip_select+0x83>
    lexceptset = *exceptset;
  80188d:	8b 03                	mov    (%ebx),%eax
  80188f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801892:	eb 13                	jmp    8018a7 <lwip_select+0x96>
  else
    FD_ZERO(&lexceptset);
  801894:	83 ec 04             	sub    $0x4,%esp
  801897:	6a 04                	push   $0x4
  801899:	6a 00                	push   $0x0
  80189b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80189e:	50                   	push   %eax
  80189f:	e8 e2 d2 00 00       	call   80eb86 <memset>
  8018a4:	83 c4 10             	add    $0x10,%esp

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8018a7:	83 ec 0c             	sub    $0xc,%esp
  8018aa:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8018ad:	50                   	push   %eax
  8018ae:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8018b1:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8018b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8018b7:	e8 43 ef ff ff       	call   8007ff <lwip_selscan>
  8018bc:	89 c6                	mov    %eax,%esi

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8018be:	83 c4 10             	add    $0x10,%esp
  8018c1:	85 c0                	test   %eax,%eax
  8018c3:	0f 85 be 01 00 00    	jne    801a87 <lwip_select+0x276>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8018c9:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8018cd:	0f 84 56 02 00 00    	je     801b29 <lwip_select+0x318>
  8018d3:	8b 45 18             	mov    0x18(%ebp),%eax
  8018d6:	83 38 00             	cmpl   $0x0,(%eax)
  8018d9:	0f 85 ea 01 00 00    	jne    801ac9 <lwip_select+0x2b8>
  8018df:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8018e3:	0f 85 e0 01 00 00    	jne    801ac9 <lwip_select+0x2b8>
      sys_sem_signal(selectsem);
  8018e9:	83 ec 0c             	sub    $0xc,%esp
  8018ec:	ff 35 80 50 81 00    	pushl  0x815080
  8018f2:	e8 a4 86 00 00       	call   809f9b <sys_sem_signal>
      if (readset)
  8018f7:	83 c4 10             	add    $0x10,%esp
  8018fa:	85 ff                	test   %edi,%edi
  8018fc:	74 10                	je     80190e <lwip_select+0xfd>
        FD_ZERO(readset);
  8018fe:	83 ec 04             	sub    $0x4,%esp
  801901:	6a 04                	push   $0x4
  801903:	6a 00                	push   $0x0
  801905:	57                   	push   %edi
  801906:	e8 7b d2 00 00       	call   80eb86 <memset>
  80190b:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  80190e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801912:	74 12                	je     801926 <lwip_select+0x115>
        FD_ZERO(writeset);
  801914:	83 ec 04             	sub    $0x4,%esp
  801917:	6a 04                	push   $0x4
  801919:	6a 00                	push   $0x0
  80191b:	ff 75 10             	pushl  0x10(%ebp)
  80191e:	e8 63 d2 00 00       	call   80eb86 <memset>
  801923:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801926:	85 db                	test   %ebx,%ebx
  801928:	74 10                	je     80193a <lwip_select+0x129>
        FD_ZERO(exceptset);
  80192a:	83 ec 04             	sub    $0x4,%esp
  80192d:	6a 04                	push   $0x4
  80192f:	6a 00                	push   $0x0
  801931:	53                   	push   %ebx
  801932:	e8 4f d2 00 00       	call   80eb86 <memset>
  801937:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  80193a:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  801941:	00 00 00 
  
      return 0;
  801944:	b8 00 00 00 00       	mov    $0x0,%eax
  801949:	e9 13 02 00 00       	jmp    801b61 <lwip_select+0x350>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  80194e:	83 ec 08             	sub    $0x8,%esp
  801951:	56                   	push   %esi
  801952:	ff 75 d8             	pushl  -0x28(%ebp)
  801955:	e8 19 39 00 00       	call   805273 <sys_sem_wait_timeout>
  80195a:	89 c6                	mov    %eax,%esi
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  80195c:	83 c4 04             	add    $0x4,%esp
  80195f:	ff 35 80 50 81 00    	pushl  0x815080
  801965:	e8 48 37 00 00       	call   8050b2 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  80196a:	a1 88 50 81 00       	mov    0x815088,%eax
  80196f:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801972:	83 c4 10             	add    $0x10,%esp
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801975:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  801977:	39 d0                	cmp    %edx,%eax
  801979:	75 19                	jne    801994 <lwip_select+0x183>
      select_cb_list = select_cb.next;
  80197b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80197e:	a3 88 50 81 00       	mov    %eax,0x815088
  801983:	eb 13                	jmp    801998 <lwip_select+0x187>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801985:	8b 10                	mov    (%eax),%edx
  801987:	39 ca                	cmp    %ecx,%edx
  801989:	75 07                	jne    801992 <lwip_select+0x181>
          p_selcb->next = select_cb.next;
  80198b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  80198e:	89 10                	mov    %edx,(%eax)
          break;
  801990:	eb 06                	jmp    801998 <lwip_select+0x187>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801992:	89 d0                	mov    %edx,%eax
  801994:	85 c0                	test   %eax,%eax
  801996:	75 ed                	jne    801985 <lwip_select+0x174>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  801998:	83 ec 0c             	sub    $0xc,%esp
  80199b:	ff 35 80 50 81 00    	pushl  0x815080
  8019a1:	e8 f5 85 00 00       	call   809f9b <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  8019a6:	83 c4 04             	add    $0x4,%esp
  8019a9:	ff 75 d8             	pushl  -0x28(%ebp)
  8019ac:	e8 ba 83 00 00       	call   809d6b <sys_sem_free>
    if (i == 0)  {
  8019b1:	83 c4 10             	add    $0x10,%esp
  8019b4:	85 f6                	test   %esi,%esi
  8019b6:	75 54                	jne    801a0c <lwip_select+0x1fb>
      /* Timeout */
      if (readset)
  8019b8:	85 ff                	test   %edi,%edi
  8019ba:	74 10                	je     8019cc <lwip_select+0x1bb>
        FD_ZERO(readset);
  8019bc:	83 ec 04             	sub    $0x4,%esp
  8019bf:	6a 04                	push   $0x4
  8019c1:	6a 00                	push   $0x0
  8019c3:	57                   	push   %edi
  8019c4:	e8 bd d1 00 00       	call   80eb86 <memset>
  8019c9:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  8019cc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8019d0:	74 12                	je     8019e4 <lwip_select+0x1d3>
        FD_ZERO(writeset);
  8019d2:	83 ec 04             	sub    $0x4,%esp
  8019d5:	6a 04                	push   $0x4
  8019d7:	6a 00                	push   $0x0
  8019d9:	ff 75 10             	pushl  0x10(%ebp)
  8019dc:	e8 a5 d1 00 00       	call   80eb86 <memset>
  8019e1:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  8019e4:	85 db                	test   %ebx,%ebx
  8019e6:	74 10                	je     8019f8 <lwip_select+0x1e7>
        FD_ZERO(exceptset);
  8019e8:	83 ec 04             	sub    $0x4,%esp
  8019eb:	6a 04                	push   $0x4
  8019ed:	6a 00                	push   $0x0
  8019ef:	53                   	push   %ebx
  8019f0:	e8 91 d1 00 00       	call   80eb86 <memset>
  8019f5:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8019f8:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  8019ff:	00 00 00 
  
      return 0;
  801a02:	b8 00 00 00 00       	mov    $0x0,%eax
  801a07:	e9 55 01 00 00       	jmp    801b61 <lwip_select+0x350>
    }
    
    if (readset)
  801a0c:	85 ff                	test   %edi,%edi
  801a0e:	74 07                	je     801a17 <lwip_select+0x206>
      lreadset = *readset;
  801a10:	8b 07                	mov    (%edi),%eax
  801a12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801a15:	eb 13                	jmp    801a2a <lwip_select+0x219>
    else
      FD_ZERO(&lreadset);
  801a17:	83 ec 04             	sub    $0x4,%esp
  801a1a:	6a 04                	push   $0x4
  801a1c:	6a 00                	push   $0x0
  801a1e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a21:	50                   	push   %eax
  801a22:	e8 5f d1 00 00       	call   80eb86 <memset>
  801a27:	83 c4 10             	add    $0x10,%esp
    if (writeset)
  801a2a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801a2e:	74 0a                	je     801a3a <lwip_select+0x229>
      lwriteset = *writeset;
  801a30:	8b 45 10             	mov    0x10(%ebp),%eax
  801a33:	8b 00                	mov    (%eax),%eax
  801a35:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801a38:	eb 13                	jmp    801a4d <lwip_select+0x23c>
    else
      FD_ZERO(&lwriteset);
  801a3a:	83 ec 04             	sub    $0x4,%esp
  801a3d:	6a 04                	push   $0x4
  801a3f:	6a 00                	push   $0x0
  801a41:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a44:	50                   	push   %eax
  801a45:	e8 3c d1 00 00       	call   80eb86 <memset>
  801a4a:	83 c4 10             	add    $0x10,%esp
    if (exceptset)
  801a4d:	85 db                	test   %ebx,%ebx
  801a4f:	74 07                	je     801a58 <lwip_select+0x247>
      lexceptset = *exceptset;
  801a51:	8b 03                	mov    (%ebx),%eax
  801a53:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801a56:	eb 13                	jmp    801a6b <lwip_select+0x25a>
    else
      FD_ZERO(&lexceptset);
  801a58:	83 ec 04             	sub    $0x4,%esp
  801a5b:	6a 04                	push   $0x4
  801a5d:	6a 00                	push   $0x0
  801a5f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a62:	50                   	push   %eax
  801a63:	e8 1e d1 00 00       	call   80eb86 <memset>
  801a68:	83 c4 10             	add    $0x10,%esp
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a6b:	83 ec 0c             	sub    $0xc,%esp
  801a6e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a71:	50                   	push   %eax
  801a72:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801a75:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801a78:	8b 45 08             	mov    0x8(%ebp),%eax
  801a7b:	e8 7f ed ff ff       	call   8007ff <lwip_selscan>
  801a80:	89 c6                	mov    %eax,%esi
  801a82:	83 c4 10             	add    $0x10,%esp
  801a85:	eb 11                	jmp    801a98 <lwip_select+0x287>
  } else
    sys_sem_signal(selectsem);
  801a87:	83 ec 0c             	sub    $0xc,%esp
  801a8a:	ff 35 80 50 81 00    	pushl  0x815080
  801a90:	e8 06 85 00 00       	call   809f9b <sys_sem_signal>
  801a95:	83 c4 10             	add    $0x10,%esp
  
  if (readset)
  801a98:	85 ff                	test   %edi,%edi
  801a9a:	74 05                	je     801aa1 <lwip_select+0x290>
    *readset = lreadset;
  801a9c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a9f:	89 07                	mov    %eax,(%edi)
  if (writeset)
  801aa1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801aa5:	74 08                	je     801aaf <lwip_select+0x29e>
    *writeset = lwriteset;
  801aa7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801aaa:	8b 7d 10             	mov    0x10(%ebp),%edi
  801aad:	89 07                	mov    %eax,(%edi)
  if (exceptset)
  801aaf:	85 db                	test   %ebx,%ebx
  801ab1:	74 05                	je     801ab8 <lwip_select+0x2a7>
    *exceptset = lexceptset;
  801ab3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801ab6:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801ab8:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  801abf:	00 00 00 
  
  return nready;
  801ac2:	89 f0                	mov    %esi,%eax
  801ac4:	e9 98 00 00 00       	jmp    801b61 <lwip_select+0x350>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801ac9:	83 ec 0c             	sub    $0xc,%esp
  801acc:	6a 00                	push   $0x0
  801ace:	e8 17 82 00 00       	call   809cea <sys_sem_new>
  801ad3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801ad6:	a1 88 50 81 00       	mov    0x815088,%eax
  801adb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801ade:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801ae1:	a3 88 50 81 00       	mov    %eax,0x815088
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801ae6:	83 c4 04             	add    $0x4,%esp
  801ae9:	ff 35 80 50 81 00    	pushl  0x815080
  801aef:	e8 a7 84 00 00       	call   809f9b <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801af4:	8b 45 18             	mov    0x18(%ebp),%eax
  801af7:	69 30 e8 03 00 00    	imul   $0x3e8,(%eax),%esi
  801afd:	8b 48 04             	mov    0x4(%eax),%ecx
  801b00:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  801b06:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801b0b:	89 c8                	mov    %ecx,%eax
  801b0d:	f7 ea                	imul   %edx
  801b0f:	c1 fa 06             	sar    $0x6,%edx
  801b12:	c1 f9 1f             	sar    $0x1f,%ecx
  801b15:	29 ca                	sub    %ecx,%edx
      if(msectimeout == 0)
  801b17:	83 c4 10             	add    $0x10,%esp
  801b1a:	01 d6                	add    %edx,%esi
        msectimeout = 1;
  801b1c:	b8 01 00 00 00       	mov    $0x1,%eax
  801b21:	0f 44 f0             	cmove  %eax,%esi
  801b24:	e9 25 fe ff ff       	jmp    80194e <lwip_select+0x13d>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801b29:	83 ec 0c             	sub    $0xc,%esp
  801b2c:	6a 00                	push   $0x0
  801b2e:	e8 b7 81 00 00       	call   809cea <sys_sem_new>
  801b33:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801b36:	a1 88 50 81 00       	mov    0x815088,%eax
  801b3b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b3e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b41:	a3 88 50 81 00       	mov    %eax,0x815088
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801b46:	83 c4 04             	add    $0x4,%esp
  801b49:	ff 35 80 50 81 00    	pushl  0x815080
  801b4f:	e8 47 84 00 00       	call   809f9b <sys_sem_signal>
  801b54:	83 c4 10             	add    $0x10,%esp
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801b57:	be 00 00 00 00       	mov    $0x0,%esi
  801b5c:	e9 ed fd ff ff       	jmp    80194e <lwip_select+0x13d>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801b61:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801b64:	5b                   	pop    %ebx
  801b65:	5e                   	pop    %esi
  801b66:	5f                   	pop    %edi
  801b67:	5d                   	pop    %ebp
  801b68:	c3                   	ret    

00801b69 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801b69:	55                   	push   %ebp
  801b6a:	89 e5                	mov    %esp,%ebp
  801b6c:	83 ec 14             	sub    $0x14,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801b6f:	ff 75 08             	pushl  0x8(%ebp)
  801b72:	e8 9a f5 ff ff       	call   801111 <lwip_close>
}
  801b77:	c9                   	leave  
  801b78:	c3                   	ret    

00801b79 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801b79:	55                   	push   %ebp
  801b7a:	89 e5                	mov    %esp,%ebp
  801b7c:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801b7f:	6a 00                	push   $0x0
  801b81:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b84:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b87:	8b 45 08             	mov    0x8(%ebp),%eax
  801b8a:	e8 76 ed ff ff       	call   800905 <lwip_getaddrname>
}
  801b8f:	c9                   	leave  
  801b90:	c3                   	ret    

00801b91 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801b91:	55                   	push   %ebp
  801b92:	89 e5                	mov    %esp,%ebp
  801b94:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801b97:	6a 01                	push   $0x1
  801b99:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b9c:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b9f:	8b 45 08             	mov    0x8(%ebp),%eax
  801ba2:	e8 5e ed ff ff       	call   800905 <lwip_getaddrname>
}
  801ba7:	c9                   	leave  
  801ba8:	c3                   	ret    

00801ba9 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801ba9:	55                   	push   %ebp
  801baa:	89 e5                	mov    %esp,%ebp
  801bac:	57                   	push   %edi
  801bad:	56                   	push   %esi
  801bae:	53                   	push   %ebx
  801baf:	83 ec 2c             	sub    $0x2c,%esp
  801bb2:	8b 75 0c             	mov    0xc(%ebp),%esi
  801bb5:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801bb8:	8b 45 08             	mov    0x8(%ebp),%eax
  801bbb:	e8 f4 eb ff ff       	call   8007b4 <get_socket>
  801bc0:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801bc2:	85 c0                	test   %eax,%eax
  801bc4:	0f 84 7a 01 00 00    	je     801d44 <lwip_getsockopt+0x19b>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801bca:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801bce:	74 04                	je     801bd4 <lwip_getsockopt+0x2b>
  801bd0:	85 ff                	test   %edi,%edi
  801bd2:	75 1b                	jne    801bef <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801bd4:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801bdb:	c7 05 20 b3 b3 00 0e 	movl   $0xe,0xb3b320
  801be2:	00 00 00 
    return -1;
  801be5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801bea:	e9 95 01 00 00       	jmp    801d84 <lwip_getsockopt+0x1db>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801bef:	83 fe 06             	cmp    $0x6,%esi
  801bf2:	0f 84 9c 00 00 00    	je     801c94 <lwip_getsockopt+0xeb>
  801bf8:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801bfe:	74 0f                	je     801c0f <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801c00:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801c05:	85 f6                	test   %esi,%esi
  801c07:	0f 85 c4 00 00 00    	jne    801cd1 <lwip_getsockopt+0x128>
  801c0d:	eb 6f                	jmp    801c7e <lwip_getsockopt+0xd5>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801c0f:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801c13:	74 39                	je     801c4e <lwip_getsockopt+0xa5>
  801c15:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801c19:	7f 12                	jg     801c2d <lwip_getsockopt+0x84>
  801c1b:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801c1f:	74 2d                	je     801c4e <lwip_getsockopt+0xa5>
  801c21:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801c25:	0f 85 93 00 00 00    	jne    801cbe <lwip_getsockopt+0x115>
  801c2b:	eb 21                	jmp    801c4e <lwip_getsockopt+0xa5>
  801c2d:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801c34:	0f 8c 84 00 00 00    	jl     801cbe <lwip_getsockopt+0x115>
  801c3a:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801c41:	7e 0b                	jle    801c4e <lwip_getsockopt+0xa5>
  801c43:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801c4a:	74 10                	je     801c5c <lwip_getsockopt+0xb3>
  801c4c:	eb 70                	jmp    801cbe <lwip_getsockopt+0x115>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801c4e:	83 3f 03             	cmpl   $0x3,(%edi)
  801c51:	0f 86 f4 00 00 00    	jbe    801d4b <lwip_getsockopt+0x1a2>
  801c57:	e9 8e 00 00 00       	jmp    801cea <lwip_getsockopt+0x141>
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801c5c:	83 3f 04             	cmpl   $0x4,(%edi)
  801c5f:	19 c0                	sbb    %eax,%eax
  801c61:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801c64:	8b 13                	mov    (%ebx),%edx
  801c66:	83 3a 20             	cmpl   $0x20,(%edx)
  801c69:	0f 85 e3 00 00 00    	jne    801d52 <lwip_getsockopt+0x1a9>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c6f:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801c72:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801c76:	0f 85 e0 00 00 00    	jne    801d5c <lwip_getsockopt+0x1b3>
  801c7c:	eb 53                	jmp    801cd1 <lwip_getsockopt+0x128>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801c7e:	8b 45 10             	mov    0x10(%ebp),%eax
  801c81:	83 e8 01             	sub    $0x1,%eax
  801c84:	83 f8 01             	cmp    $0x1,%eax
  801c87:	77 3c                	ja     801cc5 <lwip_getsockopt+0x11c>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801c89:	83 3f 03             	cmpl   $0x3,(%edi)
  801c8c:	0f 86 d4 00 00 00    	jbe    801d66 <lwip_getsockopt+0x1bd>
  801c92:	eb 56                	jmp    801cea <lwip_getsockopt+0x141>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801c94:	83 3f 03             	cmpl   $0x3,(%edi)
  801c97:	0f 86 d3 00 00 00    	jbe    801d70 <lwip_getsockopt+0x1c7>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801c9d:	8b 10                	mov    (%eax),%edx
      return 0;
  801c9f:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801ca4:	83 3a 10             	cmpl   $0x10,(%edx)
  801ca7:	0f 85 d7 00 00 00    	jne    801d84 <lwip_getsockopt+0x1db>
      return 0;

    switch (optname) {
  801cad:	8b 45 10             	mov    0x10(%ebp),%eax
  801cb0:	83 e8 01             	sub    $0x1,%eax
  801cb3:	83 f8 01             	cmp    $0x1,%eax
  801cb6:	0f 87 be 00 00 00    	ja     801d7a <lwip_getsockopt+0x1d1>
  801cbc:	eb 0e                	jmp    801ccc <lwip_getsockopt+0x123>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801cbe:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cc3:	eb 0c                	jmp    801cd1 <lwip_getsockopt+0x128>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801cc5:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cca:	eb 05                	jmp    801cd1 <lwip_getsockopt+0x128>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801ccc:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801cd1:	84 c0                	test   %al,%al
  801cd3:	74 15                	je     801cea <lwip_getsockopt+0x141>
    sock_set_errno(sock, err);
  801cd5:	0f be c0             	movsbl %al,%eax
  801cd8:	89 43 10             	mov    %eax,0x10(%ebx)
  801cdb:	a3 20 b3 b3 00       	mov    %eax,0xb3b320
    return -1;
  801ce0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ce5:	e9 9a 00 00 00       	jmp    801d84 <lwip_getsockopt+0x1db>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801cea:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801ced:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801cf0:	8b 45 10             	mov    0x10(%ebp),%eax
  801cf3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801cf6:	8b 45 14             	mov    0x14(%ebp),%eax
  801cf9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801cfc:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801cff:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801d03:	83 ec 04             	sub    $0x4,%esp
  801d06:	6a 01                	push   $0x1
  801d08:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801d0b:	50                   	push   %eax
  801d0c:	68 fe 0b 80 00       	push   $0x800bfe
  801d11:	e8 d4 05 00 00       	call   8022ea <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801d16:	83 c4 08             	add    $0x8,%esp
  801d19:	6a 00                	push   $0x0
  801d1b:	8b 03                	mov    (%ebx),%eax
  801d1d:	ff 70 10             	pushl  0x10(%eax)
  801d20:	e8 e4 82 00 00       	call   80a009 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801d25:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801d29:	0f be d0             	movsbl %al,%edx
  801d2c:	89 53 10             	mov    %edx,0x10(%ebx)
  801d2f:	89 15 20 b3 b3 00    	mov    %edx,0xb3b320
  return err ? -1 : 0;
  801d35:	83 c4 10             	add    $0x10,%esp
  801d38:	84 c0                	test   %al,%al
  801d3a:	0f 95 c0             	setne  %al
  801d3d:	0f b6 c0             	movzbl %al,%eax
  801d40:	f7 d8                	neg    %eax
  801d42:	eb 40                	jmp    801d84 <lwip_getsockopt+0x1db>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801d44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d49:	eb 39                	jmp    801d84 <lwip_getsockopt+0x1db>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801d4b:	b8 16 00 00 00       	mov    $0x16,%eax
  801d50:	eb 83                	jmp    801cd5 <lwip_getsockopt+0x12c>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801d52:	b8 61 00 00 00       	mov    $0x61,%eax
  801d57:	e9 79 ff ff ff       	jmp    801cd5 <lwip_getsockopt+0x12c>
  801d5c:	b8 61 00 00 00       	mov    $0x61,%eax
  801d61:	e9 6f ff ff ff       	jmp    801cd5 <lwip_getsockopt+0x12c>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801d66:	b8 16 00 00 00       	mov    $0x16,%eax
  801d6b:	e9 65 ff ff ff       	jmp    801cd5 <lwip_getsockopt+0x12c>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  801d70:	b8 16 00 00 00       	mov    $0x16,%eax
  801d75:	e9 5b ff ff ff       	jmp    801cd5 <lwip_getsockopt+0x12c>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801d7a:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d7f:	e9 51 ff ff ff       	jmp    801cd5 <lwip_getsockopt+0x12c>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801d84:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801d87:	5b                   	pop    %ebx
  801d88:	5e                   	pop    %esi
  801d89:	5f                   	pop    %edi
  801d8a:	5d                   	pop    %ebp
  801d8b:	c3                   	ret    

00801d8c <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  801d8c:	55                   	push   %ebp
  801d8d:	89 e5                	mov    %esp,%ebp
  801d8f:	57                   	push   %edi
  801d90:	56                   	push   %esi
  801d91:	53                   	push   %ebx
  801d92:	83 ec 2c             	sub    $0x2c,%esp
  801d95:	8b 75 0c             	mov    0xc(%ebp),%esi
  801d98:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801d9b:	8b 45 08             	mov    0x8(%ebp),%eax
  801d9e:	e8 11 ea ff ff       	call   8007b4 <get_socket>
  801da3:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801da5:	85 c0                	test   %eax,%eax
  801da7:	0f 84 45 01 00 00    	je     801ef2 <lwip_setsockopt+0x166>
    return -1;

  if (NULL == optval) {
  801dad:	85 ff                	test   %edi,%edi
  801daf:	75 1b                	jne    801dcc <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  801db1:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801db8:	c7 05 20 b3 b3 00 0e 	movl   $0xe,0xb3b320
  801dbf:	00 00 00 
    return -1;
  801dc2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801dc7:	e9 63 01 00 00       	jmp    801f2f <lwip_setsockopt+0x1a3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801dcc:	83 fe 06             	cmp    $0x6,%esi
  801dcf:	74 7e                	je     801e4f <lwip_setsockopt+0xc3>
  801dd1:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801dd7:	74 0f                	je     801de8 <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  801dd9:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801dde:	85 f6                	test   %esi,%esi
  801de0:	0f 85 a0 00 00 00    	jne    801e86 <lwip_setsockopt+0xfa>
  801de6:	eb 50                	jmp    801e38 <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801de8:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801dec:	74 18                	je     801e06 <lwip_setsockopt+0x7a>
  801dee:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801df5:	74 1e                	je     801e15 <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801df7:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801dfc:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801e00:	0f 85 80 00 00 00    	jne    801e86 <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  801e06:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e0a:	0f 86 e9 00 00 00    	jbe    801ef9 <lwip_setsockopt+0x16d>
  801e10:	e9 87 00 00 00       	jmp    801e9c <lwip_setsockopt+0x110>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801e15:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801e19:	19 c0                	sbb    %eax,%eax
  801e1b:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801e1e:	8b 13                	mov    (%ebx),%edx
  801e20:	83 3a 20             	cmpl   $0x20,(%edx)
  801e23:	0f 85 d7 00 00 00    	jne    801f00 <lwip_setsockopt+0x174>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801e29:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801e2c:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801e30:	0f 85 d1 00 00 00    	jne    801f07 <lwip_setsockopt+0x17b>
  801e36:	eb 4e                	jmp    801e86 <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801e38:	8b 45 10             	mov    0x10(%ebp),%eax
  801e3b:	83 e8 01             	sub    $0x1,%eax
  801e3e:	83 f8 01             	cmp    $0x1,%eax
  801e41:	77 37                	ja     801e7a <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  801e43:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e47:	0f 86 c4 00 00 00    	jbe    801f11 <lwip_setsockopt+0x185>
  801e4d:	eb 4d                	jmp    801e9c <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  801e4f:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e53:	0f 86 c2 00 00 00    	jbe    801f1b <lwip_setsockopt+0x18f>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801e59:	8b 10                	mov    (%eax),%edx
      return 0;
  801e5b:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801e60:	83 3a 10             	cmpl   $0x10,(%edx)
  801e63:	0f 85 c6 00 00 00    	jne    801f2f <lwip_setsockopt+0x1a3>
      return 0;

    switch (optname) {
  801e69:	8b 45 10             	mov    0x10(%ebp),%eax
  801e6c:	83 e8 01             	sub    $0x1,%eax
  801e6f:	83 f8 01             	cmp    $0x1,%eax
  801e72:	0f 87 ad 00 00 00    	ja     801f25 <lwip_setsockopt+0x199>
  801e78:	eb 07                	jmp    801e81 <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  801e7a:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e7f:	eb 05                	jmp    801e86 <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  801e81:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  801e86:	85 c0                	test   %eax,%eax
  801e88:	74 12                	je     801e9c <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  801e8a:	89 43 10             	mov    %eax,0x10(%ebx)
  801e8d:	a3 20 b3 b3 00       	mov    %eax,0xb3b320
    return -1;
  801e92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e97:	e9 93 00 00 00       	jmp    801f2f <lwip_setsockopt+0x1a3>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  801e9c:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801e9f:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801ea2:	8b 45 10             	mov    0x10(%ebp),%eax
  801ea5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801ea8:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801eab:	8d 45 18             	lea    0x18(%ebp),%eax
  801eae:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801eb1:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801eb5:	83 ec 04             	sub    $0x4,%esp
  801eb8:	6a 01                	push   $0x1
  801eba:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801ebd:	50                   	push   %eax
  801ebe:	68 81 0d 80 00       	push   $0x800d81
  801ec3:	e8 22 04 00 00       	call   8022ea <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801ec8:	83 c4 08             	add    $0x8,%esp
  801ecb:	6a 00                	push   $0x0
  801ecd:	8b 03                	mov    (%ebx),%eax
  801ecf:	ff 70 10             	pushl  0x10(%eax)
  801ed2:	e8 32 81 00 00       	call   80a009 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  801ed7:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801edb:	89 43 10             	mov    %eax,0x10(%ebx)
  801ede:	a3 20 b3 b3 00       	mov    %eax,0xb3b320
  return err ? -1 : 0;
  801ee3:	83 c4 10             	add    $0x10,%esp
  801ee6:	85 c0                	test   %eax,%eax
  801ee8:	0f 95 c0             	setne  %al
  801eeb:	0f b6 c0             	movzbl %al,%eax
  801eee:	f7 d8                	neg    %eax
  801ef0:	eb 3d                	jmp    801f2f <lwip_setsockopt+0x1a3>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801ef2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ef7:	eb 36                	jmp    801f2f <lwip_setsockopt+0x1a3>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801ef9:	b8 16 00 00 00       	mov    $0x16,%eax
  801efe:	eb 8a                	jmp    801e8a <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801f00:	b8 61 00 00 00       	mov    $0x61,%eax
  801f05:	eb 83                	jmp    801e8a <lwip_setsockopt+0xfe>
  801f07:	b8 61 00 00 00       	mov    $0x61,%eax
  801f0c:	e9 79 ff ff ff       	jmp    801e8a <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801f11:	b8 16 00 00 00       	mov    $0x16,%eax
  801f16:	e9 6f ff ff ff       	jmp    801e8a <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  801f1b:	b8 16 00 00 00       	mov    $0x16,%eax
  801f20:	e9 65 ff ff ff       	jmp    801e8a <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801f25:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f2a:	e9 5b ff ff ff       	jmp    801e8a <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801f2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801f32:	5b                   	pop    %ebx
  801f33:	5e                   	pop    %esi
  801f34:	5f                   	pop    %edi
  801f35:	5d                   	pop    %ebp
  801f36:	c3                   	ret    

00801f37 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801f37:	55                   	push   %ebp
  801f38:	89 e5                	mov    %esp,%ebp
  801f3a:	56                   	push   %esi
  801f3b:	53                   	push   %ebx
  801f3c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801f3f:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801f42:	8b 45 08             	mov    0x8(%ebp),%eax
  801f45:	e8 6a e8 ff ff       	call   8007b4 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801f4a:	85 c0                	test   %eax,%eax
  801f4c:	0f 84 af 00 00 00    	je     802001 <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  801f52:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801f58:	74 60                	je     801fba <lwip_ioctl+0x83>
  801f5a:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801f60:	0f 85 83 00 00 00    	jne    801fe9 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  801f66:	85 f6                	test   %esi,%esi
  801f68:	75 1b                	jne    801f85 <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  801f6a:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801f71:	c7 05 20 b3 b3 00 16 	movl   $0x16,0xb3b320
  801f78:	00 00 00 
      return -1;
  801f7b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f80:	e9 81 00 00 00       	jmp    802006 <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801f85:	8b 10                	mov    (%eax),%edx
  801f87:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801f8b:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801f8e:	8b 48 04             	mov    0x4(%eax),%ecx
  801f91:	85 c9                	test   %ecx,%ecx
  801f93:	74 0d                	je     801fa2 <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  801f95:	8b 09                	mov    (%ecx),%ecx
  801f97:	66 03 51 08          	add    0x8(%ecx),%dx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801f9b:	66 2b 50 08          	sub    0x8(%eax),%dx
  801f9f:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801fa2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801fa9:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  801fb0:	00 00 00 
    return 0;
  801fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  801fb8:	eb 4c                	jmp    802006 <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801fba:	85 f6                	test   %esi,%esi
  801fbc:	74 0d                	je     801fcb <lwip_ioctl+0x94>
  801fbe:	83 3e 00             	cmpl   $0x0,(%esi)
  801fc1:	74 08                	je     801fcb <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  801fc3:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  801fc9:	eb 06                	jmp    801fd1 <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  801fcb:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801fd1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801fd8:	c7 05 20 b3 b3 00 00 	movl   $0x0,0xb3b320
  801fdf:	00 00 00 
    return 0;
  801fe2:	b8 00 00 00 00       	mov    $0x0,%eax
  801fe7:	eb 1d                	jmp    802006 <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801fe9:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801ff0:	c7 05 20 b3 b3 00 26 	movl   $0x26,0xb3b320
  801ff7:	00 00 00 
    return -1;
  801ffa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fff:	eb 05                	jmp    802006 <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  802001:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  802006:	5b                   	pop    %ebx
  802007:	5e                   	pop    %esi
  802008:	5d                   	pop    %ebp
  802009:	c3                   	ret    

0080200a <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  80200a:	55                   	push   %ebp
  80200b:	89 e5                	mov    %esp,%ebp
  80200d:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  802010:	e8 b2 40 00 00       	call   8060c7 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802015:	83 3d 7c b3 b3 00 00 	cmpl   $0x0,0xb3b37c
  80201c:	75 09                	jne    802027 <tcpip_tcp_timer+0x1d>
  80201e:	83 3d 90 b3 b3 00 00 	cmpl   $0x0,0xb3b390
  802025:	74 19                	je     802040 <tcpip_tcp_timer+0x36>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802027:	83 ec 04             	sub    $0x4,%esp
  80202a:	6a 00                	push   $0x0
  80202c:	68 0a 20 80 00       	push   $0x80200a
  802031:	68 fa 00 00 00       	push   $0xfa
  802036:	e8 05 31 00 00       	call   805140 <sys_timeout>
  80203b:	83 c4 10             	add    $0x10,%esp
  80203e:	eb 0a                	jmp    80204a <tcpip_tcp_timer+0x40>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  802040:	c7 05 40 53 81 00 00 	movl   $0x0,0x815340
  802047:	00 00 00 
  }
}
  80204a:	c9                   	leave  
  80204b:	c3                   	ret    

0080204c <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  80204c:	55                   	push   %ebp
  80204d:	89 e5                	mov    %esp,%ebp
  80204f:	53                   	push   %ebx
  802050:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802053:	6a 00                	push   $0x0
  802055:	68 02 22 80 00       	push   $0x802202
  80205a:	68 e8 03 00 00       	push   $0x3e8
  80205f:	e8 dc 30 00 00       	call   805140 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802064:	83 c4 0c             	add    $0xc,%esp
  802067:	6a 00                	push   $0x0
  802069:	68 de 21 80 00       	push   $0x8021de
  80206e:	68 88 13 00 00       	push   $0x1388
  802073:	e8 c8 30 00 00       	call   805140 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802078:	83 c4 0c             	add    $0xc,%esp
  80207b:	6a 00                	push   $0x0
  80207d:	68 ba 21 80 00       	push   $0x8021ba
  802082:	68 60 ea 00 00       	push   $0xea60
  802087:	e8 b4 30 00 00       	call   805140 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80208c:	83 c4 0c             	add    $0xc,%esp
  80208f:	6a 00                	push   $0x0
  802091:	68 96 21 80 00       	push   $0x802196
  802096:	68 f4 01 00 00       	push   $0x1f4
  80209b:	e8 a0 30 00 00       	call   805140 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8020a0:	a1 48 53 81 00       	mov    0x815348,%eax
  8020a5:	83 c4 10             	add    $0x10,%esp
  8020a8:	85 c0                	test   %eax,%eax
  8020aa:	74 0e                	je     8020ba <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  8020ac:	83 ec 0c             	sub    $0xc,%esp
  8020af:	ff 35 44 53 81 00    	pushl  0x815344
  8020b5:	ff d0                	call   *%eax
  8020b7:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8020ba:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8020bd:	83 ec 08             	sub    $0x8,%esp
  8020c0:	53                   	push   %ebx
  8020c1:	ff 35 00 40 81 00    	pushl  0x814000
  8020c7:	e8 52 2f 00 00       	call   80501e <sys_mbox_fetch>
    switch (msg->type) {
  8020cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8020cf:	83 c4 10             	add    $0x10,%esp
  8020d2:	8b 02                	mov    (%edx),%eax
  8020d4:	83 f8 01             	cmp    $0x1,%eax
  8020d7:	74 22                	je     8020fb <tcpip_thread+0xaf>
  8020d9:	83 f8 01             	cmp    $0x1,%eax
  8020dc:	72 0c                	jb     8020ea <tcpip_thread+0x9e>
  8020de:	83 f8 02             	cmp    $0x2,%eax
  8020e1:	74 53                	je     802136 <tcpip_thread+0xea>
  8020e3:	83 f8 03             	cmp    $0x3,%eax
  8020e6:	74 6c                	je     802154 <tcpip_thread+0x108>
  8020e8:	eb d3                	jmp    8020bd <tcpip_thread+0x71>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8020ea:	8b 42 08             	mov    0x8(%edx),%eax
  8020ed:	83 ec 0c             	sub    $0xc,%esp
  8020f0:	8d 50 04             	lea    0x4(%eax),%edx
  8020f3:	52                   	push   %edx
  8020f4:	ff 10                	call   *(%eax)
      break;
  8020f6:	83 c4 10             	add    $0x10,%esp
  8020f9:	eb c2                	jmp    8020bd <tcpip_thread+0x71>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8020fb:	8b 42 0c             	mov    0xc(%edx),%eax
  8020fe:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  802102:	74 11                	je     802115 <tcpip_thread+0xc9>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  802104:	83 ec 08             	sub    $0x8,%esp
  802107:	50                   	push   %eax
  802108:	ff 72 08             	pushl  0x8(%edx)
  80210b:	e8 34 7a 00 00       	call   809b44 <ethernet_input>
  802110:	83 c4 10             	add    $0x10,%esp
  802113:	eb 0f                	jmp    802124 <tcpip_thread+0xd8>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  802115:	83 ec 08             	sub    $0x8,%esp
  802118:	50                   	push   %eax
  802119:	ff 72 08             	pushl  0x8(%edx)
  80211c:	e8 b5 43 00 00       	call   8064d6 <ip_input>
  802121:	83 c4 10             	add    $0x10,%esp
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802124:	83 ec 08             	sub    $0x8,%esp
  802127:	ff 75 f4             	pushl  -0xc(%ebp)
  80212a:	6a 09                	push   $0x9
  80212c:	e8 4b 23 00 00       	call   80447c <memp_free>
      break;
  802131:	83 c4 10             	add    $0x10,%esp
  802134:	eb 87                	jmp    8020bd <tcpip_thread+0x71>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  802136:	83 ec 0c             	sub    $0xc,%esp
  802139:	ff 72 0c             	pushl  0xc(%edx)
  80213c:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80213f:	83 c4 08             	add    $0x8,%esp
  802142:	ff 75 f4             	pushl  -0xc(%ebp)
  802145:	6a 08                	push   $0x8
  802147:	e8 30 23 00 00       	call   80447c <memp_free>
      break;
  80214c:	83 c4 10             	add    $0x10,%esp
  80214f:	e9 69 ff ff ff       	jmp    8020bd <tcpip_thread+0x71>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  802154:	8b 42 08             	mov    0x8(%edx),%eax
  802157:	83 f8 ff             	cmp    $0xffffffff,%eax
  80215a:	74 14                	je     802170 <tcpip_thread+0x124>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  80215c:	83 ec 04             	sub    $0x4,%esp
  80215f:	ff 72 10             	pushl  0x10(%edx)
  802162:	ff 72 0c             	pushl  0xc(%edx)
  802165:	50                   	push   %eax
  802166:	e8 d5 2f 00 00       	call   805140 <sys_timeout>
  80216b:	83 c4 10             	add    $0x10,%esp
  80216e:	eb 11                	jmp    802181 <tcpip_thread+0x135>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802170:	83 ec 08             	sub    $0x8,%esp
  802173:	ff 72 10             	pushl  0x10(%edx)
  802176:	ff 72 0c             	pushl  0xc(%edx)
  802179:	e8 73 30 00 00       	call   8051f1 <sys_untimeout>
  80217e:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802181:	83 ec 08             	sub    $0x8,%esp
  802184:	ff 75 f4             	pushl  -0xc(%ebp)
  802187:	6a 08                	push   $0x8
  802189:	e8 ee 22 00 00       	call   80447c <memp_free>
      break;
  80218e:	83 c4 10             	add    $0x10,%esp
  802191:	e9 27 ff ff ff       	jmp    8020bd <tcpip_thread+0x71>

00802196 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  802196:	55                   	push   %ebp
  802197:	89 e5                	mov    %esp,%ebp
  802199:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  80219c:	e8 05 1b 00 00       	call   803ca6 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8021a1:	83 ec 04             	sub    $0x4,%esp
  8021a4:	6a 00                	push   $0x0
  8021a6:	68 96 21 80 00       	push   $0x802196
  8021ab:	68 f4 01 00 00       	push   $0x1f4
  8021b0:	e8 8b 2f 00 00       	call   805140 <sys_timeout>
  8021b5:	83 c4 10             	add    $0x10,%esp
}
  8021b8:	c9                   	leave  
  8021b9:	c3                   	ret    

008021ba <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8021ba:	55                   	push   %ebp
  8021bb:	89 e5                	mov    %esp,%ebp
  8021bd:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8021c0:	e8 1d 19 00 00       	call   803ae2 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8021c5:	83 ec 04             	sub    $0x4,%esp
  8021c8:	6a 00                	push   $0x0
  8021ca:	68 ba 21 80 00       	push   $0x8021ba
  8021cf:	68 60 ea 00 00       	push   $0xea60
  8021d4:	e8 67 2f 00 00       	call   805140 <sys_timeout>
  8021d9:	83 c4 10             	add    $0x10,%esp
}
  8021dc:	c9                   	leave  
  8021dd:	c3                   	ret    

008021de <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  8021de:	55                   	push   %ebp
  8021df:	89 e5                	mov    %esp,%ebp
  8021e1:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  8021e4:	e8 15 72 00 00       	call   8093fe <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8021e9:	83 ec 04             	sub    $0x4,%esp
  8021ec:	6a 00                	push   $0x0
  8021ee:	68 de 21 80 00       	push   $0x8021de
  8021f3:	68 88 13 00 00       	push   $0x1388
  8021f8:	e8 43 2f 00 00       	call   805140 <sys_timeout>
  8021fd:	83 c4 10             	add    $0x10,%esp
}
  802200:	c9                   	leave  
  802201:	c3                   	ret    

00802202 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  802202:	55                   	push   %ebp
  802203:	89 e5                	mov    %esp,%ebp
  802205:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  802208:	e8 9b 49 00 00       	call   806ba8 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80220d:	83 ec 04             	sub    $0x4,%esp
  802210:	6a 00                	push   $0x0
  802212:	68 02 22 80 00       	push   $0x802202
  802217:	68 e8 03 00 00       	push   $0x3e8
  80221c:	e8 1f 2f 00 00       	call   805140 <sys_timeout>
  802221:	83 c4 10             	add    $0x10,%esp
}
  802224:	c9                   	leave  
  802225:	c3                   	ret    

00802226 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802226:	55                   	push   %ebp
  802227:	89 e5                	mov    %esp,%ebp
  802229:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  80222c:	ff 75 08             	pushl  0x8(%ebp)
  80222f:	e8 bb 25 00 00       	call   8047ef <pbuf_free>
  802234:	83 c4 10             	add    $0x10,%esp
}
  802237:	c9                   	leave  
  802238:	c3                   	ret    

00802239 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  802239:	55                   	push   %ebp
  80223a:	89 e5                	mov    %esp,%ebp
  80223c:	83 ec 08             	sub    $0x8,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  80223f:	83 3d 40 53 81 00 00 	cmpl   $0x0,0x815340
  802246:	75 33                	jne    80227b <tcp_timer_needed+0x42>
  802248:	83 3d 7c b3 b3 00 00 	cmpl   $0x0,0xb3b37c
  80224f:	75 09                	jne    80225a <tcp_timer_needed+0x21>
  802251:	83 3d 90 b3 b3 00 00 	cmpl   $0x0,0xb3b390
  802258:	74 21                	je     80227b <tcp_timer_needed+0x42>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80225a:	c7 05 40 53 81 00 01 	movl   $0x1,0x815340
  802261:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802264:	83 ec 04             	sub    $0x4,%esp
  802267:	6a 00                	push   $0x0
  802269:	68 0a 20 80 00       	push   $0x80200a
  80226e:	68 fa 00 00 00       	push   $0xfa
  802273:	e8 c8 2e 00 00       	call   805140 <sys_timeout>
  802278:	83 c4 10             	add    $0x10,%esp
  }
}
  80227b:	c9                   	leave  
  80227c:	c3                   	ret    

0080227d <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80227d:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802284:	74 54                	je     8022da <tcpip_input+0x5d>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  802286:	55                   	push   %ebp
  802287:	89 e5                	mov    %esp,%ebp
  802289:	53                   	push   %ebx
  80228a:	83 ec 10             	sub    $0x10,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80228d:	6a 09                	push   $0x9
  80228f:	e8 92 21 00 00       	call   804426 <memp_malloc>
  802294:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802296:	83 c4 10             	add    $0x10,%esp
  802299:	85 c0                	test   %eax,%eax
  80229b:	74 43                	je     8022e0 <tcpip_input+0x63>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  80229d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8022a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8022a6:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8022a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8022ac:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022af:	83 ec 08             	sub    $0x8,%esp
  8022b2:	53                   	push   %ebx
  8022b3:	ff 35 00 40 81 00    	pushl  0x814000
  8022b9:	e8 58 7e 00 00       	call   80a116 <sys_mbox_trypost>
  8022be:	83 c4 10             	add    $0x10,%esp
  8022c1:	84 c0                	test   %al,%al
  8022c3:	74 20                	je     8022e5 <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8022c5:	83 ec 08             	sub    $0x8,%esp
  8022c8:	53                   	push   %ebx
  8022c9:	6a 09                	push   $0x9
  8022cb:	e8 ac 21 00 00       	call   80447c <memp_free>
      return ERR_MEM;
  8022d0:	83 c4 10             	add    $0x10,%esp
  8022d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022d8:	eb 0b                	jmp    8022e5 <tcpip_input+0x68>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8022da:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8022df:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  8022e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8022e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8022e8:	c9                   	leave  
  8022e9:	c3                   	ret    

008022ea <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  8022ea:	55                   	push   %ebp
  8022eb:	89 e5                	mov    %esp,%ebp
  8022ed:	56                   	push   %esi
  8022ee:	53                   	push   %ebx
  8022ef:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8022f2:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022f9:	74 6f                	je     80236a <tcpip_callback_with_block+0x80>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8022fb:	83 ec 0c             	sub    $0xc,%esp
  8022fe:	6a 08                	push   $0x8
  802300:	e8 21 21 00 00       	call   804426 <memp_malloc>
  802305:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802307:	83 c4 10             	add    $0x10,%esp
  80230a:	85 c0                	test   %eax,%eax
  80230c:	74 63                	je     802371 <tcpip_callback_with_block+0x87>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  80230e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802314:	8b 45 08             	mov    0x8(%ebp),%eax
  802317:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  80231a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80231d:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  802320:	89 f0                	mov    %esi,%eax
  802322:	84 c0                	test   %al,%al
  802324:	74 19                	je     80233f <tcpip_callback_with_block+0x55>
      sys_mbox_post(mbox, msg);
  802326:	83 ec 08             	sub    $0x8,%esp
  802329:	53                   	push   %ebx
  80232a:	ff 35 00 40 81 00    	pushl  0x814000
  802330:	e8 a4 7e 00 00       	call   80a1d9 <sys_mbox_post>
  802335:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802338:	b8 00 00 00 00       	mov    $0x0,%eax
  80233d:	eb 37                	jmp    802376 <tcpip_callback_with_block+0x8c>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80233f:	83 ec 08             	sub    $0x8,%esp
  802342:	53                   	push   %ebx
  802343:	ff 35 00 40 81 00    	pushl  0x814000
  802349:	e8 c8 7d 00 00       	call   80a116 <sys_mbox_trypost>
  80234e:	83 c4 10             	add    $0x10,%esp
  802351:	84 c0                	test   %al,%al
  802353:	74 21                	je     802376 <tcpip_callback_with_block+0x8c>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802355:	83 ec 08             	sub    $0x8,%esp
  802358:	53                   	push   %ebx
  802359:	6a 08                	push   $0x8
  80235b:	e8 1c 21 00 00       	call   80447c <memp_free>
        return ERR_MEM;
  802360:	83 c4 10             	add    $0x10,%esp
  802363:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802368:	eb 0c                	jmp    802376 <tcpip_callback_with_block+0x8c>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  80236a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80236f:	eb 05                	jmp    802376 <tcpip_callback_with_block+0x8c>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  802371:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  802376:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802379:	5b                   	pop    %ebx
  80237a:	5e                   	pop    %esi
  80237b:	5d                   	pop    %ebp
  80237c:	c3                   	ret    

0080237d <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80237d:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802384:	74 45                	je     8023cb <tcpip_timeout+0x4e>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  802386:	55                   	push   %ebp
  802387:	89 e5                	mov    %esp,%ebp
  802389:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80238c:	6a 08                	push   $0x8
  80238e:	e8 93 20 00 00       	call   804426 <memp_malloc>
    if (msg == NULL) {
  802393:	83 c4 10             	add    $0x10,%esp
  802396:	85 c0                	test   %eax,%eax
  802398:	74 37                	je     8023d1 <tcpip_timeout+0x54>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  80239a:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8023a0:	8b 55 08             	mov    0x8(%ebp),%edx
  8023a3:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8023a6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8023a9:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8023ac:	8b 55 10             	mov    0x10(%ebp),%edx
  8023af:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8023b2:	83 ec 08             	sub    $0x8,%esp
  8023b5:	50                   	push   %eax
  8023b6:	ff 35 00 40 81 00    	pushl  0x814000
  8023bc:	e8 18 7e 00 00       	call   80a1d9 <sys_mbox_post>
    return ERR_OK;
  8023c1:	83 c4 10             	add    $0x10,%esp
  8023c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8023c9:	eb 0b                	jmp    8023d6 <tcpip_timeout+0x59>
  }
  return ERR_VAL;
  8023cb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8023d0:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8023d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  8023d6:	c9                   	leave  
  8023d7:	c3                   	ret    

008023d8 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8023d8:	55                   	push   %ebp
  8023d9:	89 e5                	mov    %esp,%ebp
  8023db:	53                   	push   %ebx
  8023dc:	83 ec 24             	sub    $0x24,%esp
  8023df:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8023e2:	a1 00 40 81 00       	mov    0x814000,%eax
  8023e7:	83 f8 ff             	cmp    $0xffffffff,%eax
  8023ea:	74 31                	je     80241d <tcpip_apimsg+0x45>
    msg.type = TCPIP_MSG_API;
  8023ec:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  8023f3:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  8023f6:	83 ec 08             	sub    $0x8,%esp
  8023f9:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8023fc:	52                   	push   %edx
  8023fd:	50                   	push   %eax
  8023fe:	e8 d6 7d 00 00       	call   80a1d9 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802403:	83 c4 08             	add    $0x8,%esp
  802406:	6a 00                	push   $0x0
  802408:	8b 43 04             	mov    0x4(%ebx),%eax
  80240b:	ff 70 10             	pushl  0x10(%eax)
  80240e:	e8 f6 7b 00 00       	call   80a009 <sys_arch_sem_wait>
    return ERR_OK;
  802413:	83 c4 10             	add    $0x10,%esp
  802416:	b8 00 00 00 00       	mov    $0x0,%eax
  80241b:	eb 05                	jmp    802422 <tcpip_apimsg+0x4a>
  }
  return ERR_VAL;
  80241d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802422:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802425:	c9                   	leave  
  802426:	c3                   	ret    

00802427 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802427:	55                   	push   %ebp
  802428:	89 e5                	mov    %esp,%ebp
  80242a:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  80242d:	e8 6f 03 00 00       	call   8027a1 <lwip_init>

  tcpip_init_done = initfunc;
  802432:	8b 45 08             	mov    0x8(%ebp),%eax
  802435:	a3 48 53 81 00       	mov    %eax,0x815348
  tcpip_init_done_arg = arg;
  80243a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80243d:	a3 44 53 81 00       	mov    %eax,0x815344
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  802442:	83 ec 0c             	sub    $0xc,%esp
  802445:	6a 00                	push   $0x0
  802447:	e8 4c 7a 00 00       	call   809e98 <sys_mbox_new>
  80244c:	a3 00 40 81 00       	mov    %eax,0x814000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  802451:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  802458:	6a 00                	push   $0x0
  80245a:	6a 00                	push   $0x0
  80245c:	68 4c 20 80 00       	push   $0x80204c
  802461:	68 5c 10 81 00       	push   $0x81105c
  802466:	e8 9f 7e 00 00       	call   80a30a <sys_thread_new>
  80246b:	83 c4 20             	add    $0x20,%esp
}
  80246e:	c9                   	leave  
  80246f:	c3                   	ret    

00802470 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  802470:	55                   	push   %ebp
  802471:	89 e5                	mov    %esp,%ebp
  802473:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  802476:	6a 00                	push   $0x0
  802478:	ff 75 08             	pushl  0x8(%ebp)
  80247b:	68 26 22 80 00       	push   $0x802226
  802480:	e8 65 fe ff ff       	call   8022ea <tcpip_callback_with_block>
}
  802485:	c9                   	leave  
  802486:	c3                   	ret    

00802487 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  802487:	55                   	push   %ebp
  802488:	89 e5                	mov    %esp,%ebp
  80248a:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  80248d:	6a 00                	push   $0x0
  80248f:	ff 75 08             	pushl  0x8(%ebp)
  802492:	68 5d 3f 80 00       	push   $0x803f5d
  802497:	e8 4e fe ff ff       	call   8022ea <tcpip_callback_with_block>
}
  80249c:	c9                   	leave  
  80249d:	c3                   	ret    

0080249e <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  80249e:	55                   	push   %ebp
  80249f:	89 e5                	mov    %esp,%ebp
  8024a1:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8024a4:	6a 06                	push   $0x6
  8024a6:	e8 7b 1f 00 00       	call   804426 <memp_malloc>
  if (buf != NULL) {
  8024ab:	83 c4 10             	add    $0x10,%esp
  8024ae:	85 c0                	test   %eax,%eax
  8024b0:	74 14                	je     8024c6 <netbuf_new+0x28>
    buf->p = NULL;
  8024b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8024b8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8024bf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8024c6:	c9                   	leave  
  8024c7:	c3                   	ret    

008024c8 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8024c8:	55                   	push   %ebp
  8024c9:	89 e5                	mov    %esp,%ebp
  8024cb:	53                   	push   %ebx
  8024cc:	83 ec 04             	sub    $0x4,%esp
  8024cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8024d2:	85 db                	test   %ebx,%ebx
  8024d4:	74 2d                	je     802503 <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  8024d6:	8b 03                	mov    (%ebx),%eax
  8024d8:	85 c0                	test   %eax,%eax
  8024da:	74 19                	je     8024f5 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  8024dc:	83 ec 0c             	sub    $0xc,%esp
  8024df:	50                   	push   %eax
  8024e0:	e8 0a 23 00 00       	call   8047ef <pbuf_free>
      buf->p = buf->ptr = NULL;
  8024e5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8024ec:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  8024f2:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  8024f5:	83 ec 08             	sub    $0x8,%esp
  8024f8:	53                   	push   %ebx
  8024f9:	6a 06                	push   $0x6
  8024fb:	e8 7c 1f 00 00       	call   80447c <memp_free>
  802500:	83 c4 10             	add    $0x10,%esp
  }
}
  802503:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802506:	c9                   	leave  
  802507:	c3                   	ret    

00802508 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802508:	55                   	push   %ebp
  802509:	89 e5                	mov    %esp,%ebp
  80250b:	56                   	push   %esi
  80250c:	53                   	push   %ebx
  80250d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802510:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802513:	85 db                	test   %ebx,%ebx
  802515:	75 14                	jne    80252b <netbuf_alloc+0x23>
  802517:	83 ec 04             	sub    $0x4,%esp
  80251a:	68 69 10 81 00       	push   $0x811069
  80251f:	6a 63                	push   $0x63
  802521:	68 83 10 81 00       	push   $0x811083
  802526:	e8 b6 be 00 00       	call   80e3e1 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  80252b:	8b 03                	mov    (%ebx),%eax
  80252d:	85 c0                	test   %eax,%eax
  80252f:	74 0c                	je     80253d <netbuf_alloc+0x35>
    pbuf_free(buf->p);
  802531:	83 ec 0c             	sub    $0xc,%esp
  802534:	50                   	push   %eax
  802535:	e8 b5 22 00 00       	call   8047ef <pbuf_free>
  80253a:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  80253d:	83 ec 04             	sub    $0x4,%esp
  802540:	6a 00                	push   $0x0
  802542:	0f b7 c6             	movzwl %si,%eax
  802545:	50                   	push   %eax
  802546:	6a 00                	push   $0x0
  802548:	e8 68 23 00 00       	call   8048b5 <pbuf_alloc>
  80254d:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80254f:	83 c4 10             	add    $0x10,%esp
  802552:	85 c0                	test   %eax,%eax
  802554:	74 22                	je     802578 <netbuf_alloc+0x70>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802556:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80255a:	76 14                	jbe    802570 <netbuf_alloc+0x68>
  80255c:	83 ec 04             	sub    $0x4,%esp
  80255f:	68 50 11 81 00       	push   $0x811150
  802564:	6a 6e                	push   $0x6e
  802566:	68 83 10 81 00       	push   $0x811083
  80256b:	e8 71 be 00 00       	call   80e3e1 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  802570:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  802573:	8b 40 04             	mov    0x4(%eax),%eax
  802576:	eb 05                	jmp    80257d <netbuf_alloc+0x75>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  802578:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  80257d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802580:	5b                   	pop    %ebx
  802581:	5e                   	pop    %esi
  802582:	5d                   	pop    %ebp
  802583:	c3                   	ret    

00802584 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  802584:	55                   	push   %ebp
  802585:	89 e5                	mov    %esp,%ebp
  802587:	53                   	push   %ebx
  802588:	83 ec 04             	sub    $0x4,%esp
  80258b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80258e:	85 db                	test   %ebx,%ebx
  802590:	75 14                	jne    8025a6 <netbuf_free+0x22>
  802592:	83 ec 04             	sub    $0x4,%esp
  802595:	68 99 10 81 00       	push   $0x811099
  80259a:	6a 7b                	push   $0x7b
  80259c:	68 83 10 81 00       	push   $0x811083
  8025a1:	e8 3b be 00 00       	call   80e3e1 <_panic>
  if (buf->p != NULL) {
  8025a6:	8b 03                	mov    (%ebx),%eax
  8025a8:	85 c0                	test   %eax,%eax
  8025aa:	74 0c                	je     8025b8 <netbuf_free+0x34>
    pbuf_free(buf->p);
  8025ac:	83 ec 0c             	sub    $0xc,%esp
  8025af:	50                   	push   %eax
  8025b0:	e8 3a 22 00 00       	call   8047ef <pbuf_free>
  8025b5:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8025b8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8025bf:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8025c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025c8:	c9                   	leave  
  8025c9:	c3                   	ret    

008025ca <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8025ca:	55                   	push   %ebp
  8025cb:	89 e5                	mov    %esp,%ebp
  8025cd:	56                   	push   %esi
  8025ce:	53                   	push   %ebx
  8025cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025d2:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8025d5:	85 db                	test   %ebx,%ebx
  8025d7:	75 17                	jne    8025f0 <netbuf_ref+0x26>
  8025d9:	83 ec 04             	sub    $0x4,%esp
  8025dc:	68 b2 10 81 00       	push   $0x8110b2
  8025e1:	68 8e 00 00 00       	push   $0x8e
  8025e6:	68 83 10 81 00       	push   $0x811083
  8025eb:	e8 f1 bd 00 00       	call   80e3e1 <_panic>
  if (buf->p != NULL) {
  8025f0:	8b 03                	mov    (%ebx),%eax
  8025f2:	85 c0                	test   %eax,%eax
  8025f4:	74 0c                	je     802602 <netbuf_ref+0x38>
    pbuf_free(buf->p);
  8025f6:	83 ec 0c             	sub    $0xc,%esp
  8025f9:	50                   	push   %eax
  8025fa:	e8 f0 21 00 00       	call   8047ef <pbuf_free>
  8025ff:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802602:	83 ec 04             	sub    $0x4,%esp
  802605:	6a 02                	push   $0x2
  802607:	6a 00                	push   $0x0
  802609:	6a 00                	push   $0x0
  80260b:	e8 a5 22 00 00       	call   8048b5 <pbuf_alloc>
  802610:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802612:	83 c4 10             	add    $0x10,%esp
  802615:	85 c0                	test   %eax,%eax
  802617:	75 0e                	jne    802627 <netbuf_ref+0x5d>
    buf->ptr = NULL;
  802619:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  802620:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802625:	eb 1a                	jmp    802641 <netbuf_ref+0x77>
  }
  buf->p->payload = (void*)dataptr;
  802627:	8b 55 0c             	mov    0xc(%ebp),%edx
  80262a:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  80262d:	8b 03                	mov    (%ebx),%eax
  80262f:	66 89 70 08          	mov    %si,0x8(%eax)
  802633:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802637:	8b 03                	mov    (%ebx),%eax
  802639:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  80263c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802641:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802644:	5b                   	pop    %ebx
  802645:	5e                   	pop    %esi
  802646:	5d                   	pop    %ebp
  802647:	c3                   	ret    

00802648 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802648:	55                   	push   %ebp
  802649:	89 e5                	mov    %esp,%ebp
  80264b:	56                   	push   %esi
  80264c:	53                   	push   %ebx
  80264d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802650:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802653:	85 db                	test   %ebx,%ebx
  802655:	75 17                	jne    80266e <netbuf_chain+0x26>
  802657:	83 ec 04             	sub    $0x4,%esp
  80265a:	68 ca 10 81 00       	push   $0x8110ca
  80265f:	68 a6 00 00 00       	push   $0xa6
  802664:	68 83 10 81 00       	push   $0x811083
  802669:	e8 73 bd 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80266e:	85 f6                	test   %esi,%esi
  802670:	75 17                	jne    802689 <netbuf_chain+0x41>
  802672:	83 ec 04             	sub    $0x4,%esp
  802675:	68 e3 10 81 00       	push   $0x8110e3
  80267a:	68 a7 00 00 00       	push   $0xa7
  80267f:	68 83 10 81 00       	push   $0x811083
  802684:	e8 58 bd 00 00       	call   80e3e1 <_panic>
  pbuf_chain(head->p, tail->p);
  802689:	83 ec 08             	sub    $0x8,%esp
  80268c:	ff 36                	pushl  (%esi)
  80268e:	ff 33                	pushl  (%ebx)
  802690:	e8 41 26 00 00       	call   804cd6 <pbuf_chain>
  head->ptr = head->p;
  802695:	8b 03                	mov    (%ebx),%eax
  802697:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  80269a:	83 c4 08             	add    $0x8,%esp
  80269d:	56                   	push   %esi
  80269e:	6a 06                	push   $0x6
  8026a0:	e8 d7 1d 00 00       	call   80447c <memp_free>
  8026a5:	83 c4 10             	add    $0x10,%esp
}
  8026a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8026ab:	5b                   	pop    %ebx
  8026ac:	5e                   	pop    %esi
  8026ad:	5d                   	pop    %ebp
  8026ae:	c3                   	ret    

008026af <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8026af:	55                   	push   %ebp
  8026b0:	89 e5                	mov    %esp,%ebp
  8026b2:	53                   	push   %ebx
  8026b3:	83 ec 04             	sub    $0x4,%esp
  8026b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8026b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8026bc:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8026bf:	85 c0                	test   %eax,%eax
  8026c1:	75 17                	jne    8026da <netbuf_data+0x2b>
  8026c3:	83 ec 04             	sub    $0x4,%esp
  8026c6:	68 fe 10 81 00       	push   $0x8110fe
  8026cb:	68 b9 00 00 00       	push   $0xb9
  8026d0:	68 83 10 81 00       	push   $0x811083
  8026d5:	e8 07 bd 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8026da:	85 c9                	test   %ecx,%ecx
  8026dc:	75 17                	jne    8026f5 <netbuf_data+0x46>
  8026de:	83 ec 04             	sub    $0x4,%esp
  8026e1:	68 17 11 81 00       	push   $0x811117
  8026e6:	68 ba 00 00 00       	push   $0xba
  8026eb:	68 83 10 81 00       	push   $0x811083
  8026f0:	e8 ec bc 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8026f5:	85 d2                	test   %edx,%edx
  8026f7:	75 17                	jne    802710 <netbuf_data+0x61>
  8026f9:	83 ec 04             	sub    $0x4,%esp
  8026fc:	68 34 11 81 00       	push   $0x811134
  802701:	68 bb 00 00 00       	push   $0xbb
  802706:	68 83 10 81 00       	push   $0x811083
  80270b:	e8 d1 bc 00 00       	call   80e3e1 <_panic>

  if (buf->ptr == NULL) {
  802710:	8b 58 04             	mov    0x4(%eax),%ebx
  802713:	85 db                	test   %ebx,%ebx
  802715:	74 16                	je     80272d <netbuf_data+0x7e>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802717:	8b 5b 04             	mov    0x4(%ebx),%ebx
  80271a:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  80271c:	8b 40 04             	mov    0x4(%eax),%eax
  80271f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802723:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802726:	b8 00 00 00 00       	mov    $0x0,%eax
  80272b:	eb 05                	jmp    802732 <netbuf_data+0x83>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  80272d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  802732:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802735:	c9                   	leave  
  802736:	c3                   	ret    

00802737 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802737:	55                   	push   %ebp
  802738:	89 e5                	mov    %esp,%ebp
  80273a:	83 ec 08             	sub    $0x8,%esp
  80273d:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802740:	85 c0                	test   %eax,%eax
  802742:	75 17                	jne    80275b <netbuf_next+0x24>
  802744:	83 ec 04             	sub    $0x4,%esp
  802747:	68 99 10 81 00       	push   $0x811099
  80274c:	68 d2 00 00 00       	push   $0xd2
  802751:	68 83 10 81 00       	push   $0x811083
  802756:	e8 86 bc 00 00       	call   80e3e1 <_panic>
  if (buf->ptr->next == NULL) {
  80275b:	8b 50 04             	mov    0x4(%eax),%edx
  80275e:	8b 12                	mov    (%edx),%edx
  802760:	85 d2                	test   %edx,%edx
  802762:	74 0b                	je     80276f <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802764:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  802767:	83 3a 00             	cmpl   $0x0,(%edx)
  80276a:	0f 94 c0             	sete   %al
  80276d:	eb 05                	jmp    802774 <netbuf_next+0x3d>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  80276f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  802774:	c9                   	leave  
  802775:	c3                   	ret    

00802776 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802776:	55                   	push   %ebp
  802777:	89 e5                	mov    %esp,%ebp
  802779:	83 ec 08             	sub    $0x8,%esp
  80277c:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80277f:	85 c0                	test   %eax,%eax
  802781:	75 17                	jne    80279a <netbuf_first+0x24>
  802783:	83 ec 04             	sub    $0x4,%esp
  802786:	68 99 10 81 00       	push   $0x811099
  80278b:	68 e7 00 00 00       	push   $0xe7
  802790:	68 83 10 81 00       	push   $0x811083
  802795:	e8 47 bc 00 00       	call   80e3e1 <_panic>
  buf->ptr = buf->p;
  80279a:	8b 10                	mov    (%eax),%edx
  80279c:	89 50 04             	mov    %edx,0x4(%eax)
}
  80279f:	c9                   	leave  
  8027a0:	c3                   	ret    

008027a1 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8027a1:	55                   	push   %ebp
  8027a2:	89 e5                	mov    %esp,%ebp
  8027a4:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8027a7:	e8 a9 74 00 00       	call   809c55 <sys_init>
  mem_init();
  8027ac:	e8 46 17 00 00       	call   803ef7 <mem_init>
  memp_init();
  8027b1:	e8 18 1c 00 00       	call   8043ce <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8027b6:	e8 c9 e6 ff ff       	call   800e84 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8027bb:	c9                   	leave  
  8027bc:	c3                   	ret    

008027bd <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  8027bd:	55                   	push   %ebp
  8027be:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  8027c0:	38 10                	cmp    %dl,(%eax)
  8027c2:	74 06                	je     8027ca <dhcp_set_state+0xd>
    dhcp->state = new_state;
  8027c4:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  8027c6:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  8027ca:	5d                   	pop    %ebp
  8027cb:	c3                   	ret    

008027cc <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  8027cc:	55                   	push   %ebp
  8027cd:	89 e5                	mov    %esp,%ebp
  8027cf:	57                   	push   %edi
  8027d0:	56                   	push   %esi
  8027d1:	53                   	push   %ebx
  8027d2:	83 ec 08             	sub    $0x8,%esp
  8027d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  8027d8:	8b 70 14             	mov    0x14(%eax),%esi
  8027db:	85 f6                	test   %esi,%esi
  8027dd:	0f 84 d5 00 00 00    	je     8028b8 <dhcp_get_option_ptr+0xec>
  8027e3:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  8027e7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027ec:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  8027f0:	b8 00 00 00 00       	mov    $0x0,%eax
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  8027f5:	66 85 ff             	test   %di,%di
  8027f8:	0f 84 d2 00 00 00    	je     8028d0 <dhcp_get_option_ptr+0x104>
  8027fe:	eb 2d                	jmp    80282d <dhcp_get_option_ptr+0x61>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802800:	80 fb 34             	cmp    $0x34,%bl
  802803:	75 12                	jne    802817 <dhcp_get_option_ptr+0x4b>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802805:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802808:	83 c1 03             	add    $0x3,%ecx
  80280b:	0f b7 c0             	movzwl %ax,%eax
  80280e:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802812:	88 45 f0             	mov    %al,-0x10(%ebp)
  802815:	eb 16                	jmp    80282d <dhcp_get_option_ptr+0x61>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802817:	38 d3                	cmp    %dl,%bl
  802819:	0f 84 b1 00 00 00    	je     8028d0 <dhcp_get_option_ptr+0x104>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80281f:	8d 41 01             	lea    0x1(%ecx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802822:	0f b7 c0             	movzwl %ax,%eax
  802825:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802829:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80282d:	66 39 f9             	cmp    %di,%cx
  802830:	73 0d                	jae    80283f <dhcp_get_option_ptr+0x73>
  802832:	0f b7 c1             	movzwl %cx,%eax
  802835:	01 f0                	add    %esi,%eax
  802837:	0f b6 18             	movzbl (%eax),%ebx
  80283a:	80 fb ff             	cmp    $0xff,%bl
  80283d:	75 c1                	jne    802800 <dhcp_get_option_ptr+0x34>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80283f:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  802843:	84 c0                	test   %al,%al
  802845:	74 78                	je     8028bf <dhcp_get_option_ptr+0xf3>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802847:	3c 01                	cmp    $0x1,%al
  802849:	75 10                	jne    80285b <dhcp_get_option_ptr+0x8f>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80284b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80284e:	8b 58 10             	mov    0x10(%eax),%ebx
  802851:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  802854:	be 80 00 00 00       	mov    $0x80,%esi
  802859:	eb 24                	jmp    80287f <dhcp_get_option_ptr+0xb3>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80285b:	80 7d f0 02          	cmpb   $0x2,-0x10(%ebp)
  80285f:	75 10                	jne    802871 <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802861:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802864:	8b 58 10             	mov    0x10(%eax),%ebx
  802867:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  80286a:	be 40 00 00 00       	mov    $0x40,%esi
  80286f:	eb 0e                	jmp    80287f <dhcp_get_option_ptr+0xb3>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802871:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802874:	8b 58 10             	mov    0x10(%eax),%ebx
  802877:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80287a:	be c0 00 00 00       	mov    $0xc0,%esi
      }
      offset = 0;
  80287f:	b9 00 00 00 00       	mov    $0x0,%ecx
  802884:	89 d7                	mov    %edx,%edi

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802886:	eb 14                	jmp    80289c <dhcp_get_option_ptr+0xd0>
        if (options[offset] == option_type) {
  802888:	89 f8                	mov    %edi,%eax
  80288a:	38 d0                	cmp    %dl,%al
  80288c:	74 3f                	je     8028cd <dhcp_get_option_ptr+0x101>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80288e:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  802891:	0f b7 c0             	movzwl %ax,%eax
  802894:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  802898:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80289c:	66 39 f1             	cmp    %si,%cx
  80289f:	73 25                	jae    8028c6 <dhcp_get_option_ptr+0xfa>
  8028a1:	0f b7 c1             	movzwl %cx,%eax
  8028a4:	01 d8                	add    %ebx,%eax
  8028a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8028a9:	0f b6 10             	movzbl (%eax),%edx
  8028ac:	80 fa ff             	cmp    $0xff,%dl
  8028af:	75 d7                	jne    802888 <dhcp_get_option_ptr+0xbc>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  8028b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8028b6:	eb 18                	jmp    8028d0 <dhcp_get_option_ptr+0x104>
  8028b8:	b8 00 00 00 00       	mov    $0x0,%eax
  8028bd:	eb 11                	jmp    8028d0 <dhcp_get_option_ptr+0x104>
  8028bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8028c4:	eb 0a                	jmp    8028d0 <dhcp_get_option_ptr+0x104>
  8028c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8028cb:	eb 03                	jmp    8028d0 <dhcp_get_option_ptr+0x104>
  8028cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  8028d0:	83 c4 08             	add    $0x8,%esp
  8028d3:	5b                   	pop    %ebx
  8028d4:	5e                   	pop    %esi
  8028d5:	5f                   	pop    %edi
  8028d6:	5d                   	pop    %ebp
  8028d7:	c3                   	ret    

008028d8 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  8028d8:	55                   	push   %ebp
  8028d9:	89 e5                	mov    %esp,%ebp
  8028db:	89 c1                	mov    %eax,%ecx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  8028dd:	0f b6 10             	movzbl (%eax),%edx
  8028e0:	89 d0                	mov    %edx,%eax
  8028e2:	c1 e0 18             	shl    $0x18,%eax
  value |= (u32_t)(*ptr++) << 16;
  8028e5:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
  8028e9:	c1 e2 10             	shl    $0x10,%edx
  8028ec:	09 c2                	or     %eax,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  8028ee:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
  8028f2:	09 d0                	or     %edx,%eax
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  8028f4:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
  8028f8:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  8028fb:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  8028fd:	5d                   	pop    %ebp
  8028fe:	c3                   	ret    

008028ff <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  8028ff:	55                   	push   %ebp
  802900:	89 e5                	mov    %esp,%ebp
  802902:	56                   	push   %esi
  802903:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802904:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802908:	66 83 f9 43          	cmp    $0x43,%cx
  80290c:	76 17                	jbe    802925 <dhcp_option_byte+0x26>
  80290e:	83 ec 04             	sub    $0x4,%esp
  802911:	68 74 11 81 00       	push   $0x811174
  802916:	68 65 04 00 00       	push   $0x465
  80291b:	68 c2 14 81 00       	push   $0x8114c2
  802920:	e8 bc ba 00 00       	call   80e3e1 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802925:	8b 58 20             	mov    0x20(%eax),%ebx
  802928:	8d 71 01             	lea    0x1(%ecx),%esi
  80292b:	66 89 70 24          	mov    %si,0x24(%eax)
  80292f:	0f b7 c9             	movzwl %cx,%ecx
  802932:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802939:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80293c:	5b                   	pop    %ebx
  80293d:	5e                   	pop    %esi
  80293e:	5d                   	pop    %ebp
  80293f:	c3                   	ret    

00802940 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802940:	55                   	push   %ebp
  802941:	89 e5                	mov    %esp,%ebp
  802943:	57                   	push   %edi
  802944:	56                   	push   %esi
  802945:	53                   	push   %ebx
  802946:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802949:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  80294d:	0f b7 f3             	movzwl %bx,%esi
  802950:	8d 74 31 02          	lea    0x2(%ecx,%esi,1),%esi
  802954:	83 fe 44             	cmp    $0x44,%esi
  802957:	76 17                	jbe    802970 <dhcp_option+0x30>
  802959:	83 ec 04             	sub    $0x4,%esp
  80295c:	68 b0 11 81 00       	push   $0x8111b0
  802961:	68 5a 04 00 00       	push   $0x45a
  802966:	68 c2 14 81 00       	push   $0x8114c2
  80296b:	e8 71 ba 00 00       	call   80e3e1 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802970:	8b 70 20             	mov    0x20(%eax),%esi
  802973:	8d 7b 01             	lea    0x1(%ebx),%edi
  802976:	66 89 78 24          	mov    %di,0x24(%eax)
  80297a:	0f b7 db             	movzwl %bx,%ebx
  80297d:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802984:	8b 58 20             	mov    0x20(%eax),%ebx
  802987:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  80298b:	8d 72 01             	lea    0x1(%edx),%esi
  80298e:	66 89 70 24          	mov    %si,0x24(%eax)
  802992:	0f b7 d2             	movzwl %dx,%edx
  802995:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  80299c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80299f:	5b                   	pop    %ebx
  8029a0:	5e                   	pop    %esi
  8029a1:	5f                   	pop    %edi
  8029a2:	5d                   	pop    %ebp
  8029a3:	c3                   	ret    

008029a4 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  8029a4:	55                   	push   %ebp
  8029a5:	89 e5                	mov    %esp,%ebp
  8029a7:	56                   	push   %esi
  8029a8:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  8029a9:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8029ad:	0f b7 d9             	movzwl %cx,%ebx
  8029b0:	83 c3 02             	add    $0x2,%ebx
  8029b3:	83 fb 44             	cmp    $0x44,%ebx
  8029b6:	76 17                	jbe    8029cf <dhcp_option_short+0x2b>
  8029b8:	83 ec 04             	sub    $0x4,%esp
  8029bb:	68 f8 11 81 00       	push   $0x8111f8
  8029c0:	68 6c 04 00 00       	push   $0x46c
  8029c5:	68 c2 14 81 00       	push   $0x8114c2
  8029ca:	e8 12 ba 00 00       	call   80e3e1 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  8029cf:	8d 71 01             	lea    0x1(%ecx),%esi
  8029d2:	66 89 70 24          	mov    %si,0x24(%eax)
  8029d6:	0f b7 c9             	movzwl %cx,%ecx
  8029d9:	89 d3                	mov    %edx,%ebx
  8029db:	66 c1 eb 08          	shr    $0x8,%bx
  8029df:	8b 70 20             	mov    0x20(%eax),%esi
  8029e2:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  8029e9:	8b 58 20             	mov    0x20(%eax),%ebx
  8029ec:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8029f0:	8d 71 01             	lea    0x1(%ecx),%esi
  8029f3:	66 89 70 24          	mov    %si,0x24(%eax)
  8029f7:	0f b7 c9             	movzwl %cx,%ecx
  8029fa:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a01:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a04:	5b                   	pop    %ebx
  802a05:	5e                   	pop    %esi
  802a06:	5d                   	pop    %ebp
  802a07:	c3                   	ret    

00802a08 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802a08:	55                   	push   %ebp
  802a09:	89 e5                	mov    %esp,%ebp
  802a0b:	53                   	push   %ebx
  802a0c:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a0f:	85 c0                	test   %eax,%eax
  802a11:	75 17                	jne    802a2a <dhcp_option_trailer+0x22>
  802a13:	83 ec 04             	sub    $0x4,%esp
  802a16:	68 3c 12 81 00       	push   $0x81123c
  802a1b:	68 80 05 00 00       	push   $0x580
  802a20:	68 c2 14 81 00       	push   $0x8114c2
  802a25:	e8 b7 b9 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a2a:	8b 48 20             	mov    0x20(%eax),%ecx
  802a2d:	85 c9                	test   %ecx,%ecx
  802a2f:	75 17                	jne    802a48 <dhcp_option_trailer+0x40>
  802a31:	83 ec 04             	sub    $0x4,%esp
  802a34:	68 60 12 81 00       	push   $0x811260
  802a39:	68 81 05 00 00       	push   $0x581
  802a3e:	68 c2 14 81 00       	push   $0x8114c2
  802a43:	e8 99 b9 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a48:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a4c:	66 83 fa 43          	cmp    $0x43,%dx
  802a50:	76 17                	jbe    802a69 <dhcp_option_trailer+0x61>
  802a52:	83 ec 04             	sub    $0x4,%esp
  802a55:	68 8c 12 81 00       	push   $0x81128c
  802a5a:	68 82 05 00 00       	push   $0x582
  802a5f:	68 c2 14 81 00       	push   $0x8114c2
  802a64:	e8 78 b9 00 00       	call   80e3e1 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802a69:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a6c:	66 89 58 24          	mov    %bx,0x24(%eax)
  802a70:	0f b7 d2             	movzwl %dx,%edx
  802a73:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802a7a:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a7b:	eb 2c                	jmp    802aa9 <dhcp_option_trailer+0xa1>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a7d:	83 ec 04             	sub    $0x4,%esp
  802a80:	68 8c 12 81 00       	push   $0x81128c
  802a85:	68 87 05 00 00       	push   $0x587
  802a8a:	68 c2 14 81 00       	push   $0x8114c2
  802a8f:	e8 4d b9 00 00       	call   80e3e1 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802a94:	8b 48 20             	mov    0x20(%eax),%ecx
  802a97:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a9a:	66 89 58 24          	mov    %bx,0x24(%eax)
  802a9e:	0f b7 d2             	movzwl %dx,%edx
  802aa1:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802aa8:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802aa9:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802aad:	66 83 fa 43          	cmp    $0x43,%dx
  802ab1:	76 e1                	jbe    802a94 <dhcp_option_trailer+0x8c>
  802ab3:	f6 c2 03             	test   $0x3,%dl
  802ab6:	75 c5                	jne    802a7d <dhcp_option_trailer+0x75>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802ab8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802abb:	c9                   	leave  
  802abc:	c3                   	ret    

00802abd <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802abd:	55                   	push   %ebp
  802abe:	89 e5                	mov    %esp,%ebp
  802ac0:	56                   	push   %esi
  802ac1:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802ac2:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ac6:	0f b7 d9             	movzwl %cx,%ebx
  802ac9:	83 c3 04             	add    $0x4,%ebx
  802acc:	83 fb 44             	cmp    $0x44,%ebx
  802acf:	76 17                	jbe    802ae8 <dhcp_option_long+0x2b>
  802ad1:	83 ec 04             	sub    $0x4,%esp
  802ad4:	68 cc 12 81 00       	push   $0x8112cc
  802ad9:	68 74 04 00 00       	push   $0x474
  802ade:	68 c2 14 81 00       	push   $0x8114c2
  802ae3:	e8 f9 b8 00 00       	call   80e3e1 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802ae8:	8d 71 01             	lea    0x1(%ecx),%esi
  802aeb:	66 89 70 24          	mov    %si,0x24(%eax)
  802aef:	0f b7 c9             	movzwl %cx,%ecx
  802af2:	89 d3                	mov    %edx,%ebx
  802af4:	c1 eb 18             	shr    $0x18,%ebx
  802af7:	8b 70 20             	mov    0x20(%eax),%esi
  802afa:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802b01:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b05:	8d 71 01             	lea    0x1(%ecx),%esi
  802b08:	66 89 70 24          	mov    %si,0x24(%eax)
  802b0c:	0f b7 c9             	movzwl %cx,%ecx
  802b0f:	89 d3                	mov    %edx,%ebx
  802b11:	c1 eb 10             	shr    $0x10,%ebx
  802b14:	8b 70 20             	mov    0x20(%eax),%esi
  802b17:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802b1e:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b22:	8d 71 01             	lea    0x1(%ecx),%esi
  802b25:	66 89 70 24          	mov    %si,0x24(%eax)
  802b29:	0f b7 c9             	movzwl %cx,%ecx
  802b2c:	0f b6 de             	movzbl %dh,%ebx
  802b2f:	8b 70 20             	mov    0x20(%eax),%esi
  802b32:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802b39:	8b 58 20             	mov    0x20(%eax),%ebx
  802b3c:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b40:	8d 71 01             	lea    0x1(%ecx),%esi
  802b43:	66 89 70 24          	mov    %si,0x24(%eax)
  802b47:	0f b7 c9             	movzwl %cx,%ecx
  802b4a:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b51:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b54:	5b                   	pop    %ebx
  802b55:	5e                   	pop    %esi
  802b56:	5d                   	pop    %ebp
  802b57:	c3                   	ret    

00802b58 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802b58:	55                   	push   %ebp
  802b59:	89 e5                	mov    %esp,%ebp
  802b5b:	57                   	push   %edi
  802b5c:	56                   	push   %esi
  802b5d:	53                   	push   %ebx
  802b5e:	83 ec 1c             	sub    $0x1c,%esp
  802b61:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802b63:	85 c0                	test   %eax,%eax
  802b65:	75 17                	jne    802b7e <dhcp_create_request+0x26>
  802b67:	83 ec 04             	sub    $0x4,%esp
  802b6a:	68 0c 13 81 00       	push   $0x81130c
  802b6f:	68 2d 05 00 00       	push   $0x52d
  802b74:	68 c2 14 81 00       	push   $0x8114c2
  802b79:	e8 63 b8 00 00       	call   80e3e1 <_panic>
  dhcp = netif->dhcp;
  802b7e:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802b81:	85 db                	test   %ebx,%ebx
  802b83:	75 17                	jne    802b9c <dhcp_create_request+0x44>
  802b85:	83 ec 04             	sub    $0x4,%esp
  802b88:	68 30 13 81 00       	push   $0x811330
  802b8d:	68 2f 05 00 00       	push   $0x52f
  802b92:	68 c2 14 81 00       	push   $0x8114c2
  802b97:	e8 45 b8 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802b9c:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802ba0:	74 17                	je     802bb9 <dhcp_create_request+0x61>
  802ba2:	83 ec 04             	sub    $0x4,%esp
  802ba5:	68 54 13 81 00       	push   $0x811354
  802baa:	68 30 05 00 00       	push   $0x530
  802baf:	68 c2 14 81 00       	push   $0x8114c2
  802bb4:	e8 28 b8 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802bb9:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802bbd:	74 17                	je     802bd6 <dhcp_create_request+0x7e>
  802bbf:	83 ec 04             	sub    $0x4,%esp
  802bc2:	68 80 13 81 00       	push   $0x811380
  802bc7:	68 31 05 00 00       	push   $0x531
  802bcc:	68 c2 14 81 00       	push   $0x8114c2
  802bd1:	e8 0b b8 00 00       	call   80e3e1 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802bd6:	83 ec 04             	sub    $0x4,%esp
  802bd9:	6a 00                	push   $0x0
  802bdb:	68 34 01 00 00       	push   $0x134
  802be0:	6a 00                	push   $0x0
  802be2:	e8 ce 1c 00 00       	call   8048b5 <pbuf_alloc>
  802be7:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802bea:	83 c4 10             	add    $0x10,%esp
  802bed:	85 c0                	test   %eax,%eax
  802bef:	0f 84 31 01 00 00    	je     802d26 <dhcp_create_request+0x1ce>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802bf5:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802bfb:	77 17                	ja     802c14 <dhcp_create_request+0xbc>
  802bfd:	83 ec 04             	sub    $0x4,%esp
  802c00:	68 ac 13 81 00       	push   $0x8113ac
  802c05:	68 38 05 00 00       	push   $0x538
  802c0a:	68 c2 14 81 00       	push   $0x8114c2
  802c0f:	e8 cd b7 00 00       	call   80e3e1 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  802c14:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802c1a:	8d 4a 01             	lea    0x1(%edx),%ecx
  802c1d:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802c23:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802c26:	8b 40 04             	mov    0x4(%eax),%eax
  802c29:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802c2c:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802c2f:	8b 43 20             	mov    0x20(%ebx),%eax
  802c32:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802c36:	8b 43 20             	mov    0x20(%ebx),%eax
  802c39:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802c3d:	8b 43 20             	mov    0x20(%ebx),%eax
  802c40:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802c44:	8b 73 20             	mov    0x20(%ebx),%esi
  802c47:	83 ec 0c             	sub    $0xc,%esp
  802c4a:	ff 73 04             	pushl  0x4(%ebx)
  802c4d:	e8 15 4a 00 00       	call   807667 <htonl>
  802c52:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  802c55:	8b 43 20             	mov    0x20(%ebx),%eax
  802c58:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802c5e:	8b 43 20             	mov    0x20(%ebx),%eax
  802c61:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802c67:	8b 43 20             	mov    0x20(%ebx),%eax
  802c6a:	8b 57 04             	mov    0x4(%edi),%edx
  802c6d:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802c70:	8b 43 20             	mov    0x20(%ebx),%eax
  802c73:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802c7a:	8b 43 20             	mov    0x20(%ebx),%eax
  802c7d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802c84:	8b 43 20             	mov    0x20(%ebx),%eax
  802c87:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802c8e:	83 c4 10             	add    $0x10,%esp
  802c91:	b8 00 00 00 00       	mov    $0x0,%eax
  802c96:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c99:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  802c9c:	8b 59 20             	mov    0x20(%ecx),%ebx
  802c9f:	89 c1                	mov    %eax,%ecx
  802ca1:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  802ca5:	ba 00 00 00 00       	mov    $0x0,%edx
  802caa:	66 39 c6             	cmp    %ax,%si
  802cad:	76 05                	jbe    802cb4 <dhcp_create_request+0x15c>
  802caf:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  802cb4:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  802cb8:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802cbb:	83 f8 10             	cmp    $0x10,%eax
  802cbe:	75 d9                	jne    802c99 <dhcp_create_request+0x141>
  802cc0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  802cc3:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  802cc5:	8b 53 20             	mov    0x20(%ebx),%edx
  802cc8:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802ccd:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802cd0:	83 f8 40             	cmp    $0x40,%eax
  802cd3:	75 f0                	jne    802cc5 <dhcp_create_request+0x16d>
  802cd5:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  802cd7:	8b 53 20             	mov    0x20(%ebx),%edx
  802cda:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802cdf:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802ce2:	3d 80 00 00 00       	cmp    $0x80,%eax
  802ce7:	75 ee                	jne    802cd7 <dhcp_create_request+0x17f>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802ce9:	8b 73 20             	mov    0x20(%ebx),%esi
  802cec:	83 ec 0c             	sub    $0xc,%esp
  802cef:	68 63 53 82 63       	push   $0x63825363
  802cf4:	e8 6e 49 00 00       	call   807667 <htonl>
  802cf9:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802cff:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802d05:	83 c4 10             	add    $0x10,%esp
  802d08:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802d0d:	8b 53 20             	mov    0x20(%ebx),%edx
  802d10:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802d17:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802d1a:	83 f8 44             	cmp    $0x44,%eax
  802d1d:	75 ee                	jne    802d0d <dhcp_create_request+0x1b5>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  802d1f:	b8 00 00 00 00       	mov    $0x0,%eax
  802d24:	eb 05                	jmp    802d2b <dhcp_create_request+0x1d3>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  802d26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  802d2b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802d2e:	5b                   	pop    %ebx
  802d2f:	5e                   	pop    %esi
  802d30:	5f                   	pop    %edi
  802d31:	5d                   	pop    %ebp
  802d32:	c3                   	ret    

00802d33 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802d33:	55                   	push   %ebp
  802d34:	89 e5                	mov    %esp,%ebp
  802d36:	53                   	push   %ebx
  802d37:	83 ec 04             	sub    $0x4,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d3a:	85 c0                	test   %eax,%eax
  802d3c:	75 17                	jne    802d55 <dhcp_delete_request+0x22>
  802d3e:	83 ec 04             	sub    $0x4,%esp
  802d41:	68 f0 13 81 00       	push   $0x8113f0
  802d46:	68 69 05 00 00       	push   $0x569
  802d4b:	68 c2 14 81 00       	push   $0x8114c2
  802d50:	e8 8c b6 00 00       	call   80e3e1 <_panic>
  dhcp = netif->dhcp;
  802d55:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d58:	85 db                	test   %ebx,%ebx
  802d5a:	75 17                	jne    802d73 <dhcp_delete_request+0x40>
  802d5c:	83 ec 04             	sub    $0x4,%esp
  802d5f:	68 14 14 81 00       	push   $0x811414
  802d64:	68 6b 05 00 00       	push   $0x56b
  802d69:	68 c2 14 81 00       	push   $0x8114c2
  802d6e:	e8 6e b6 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802d73:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802d76:	85 c0                	test   %eax,%eax
  802d78:	75 17                	jne    802d91 <dhcp_delete_request+0x5e>
  802d7a:	83 ec 04             	sub    $0x4,%esp
  802d7d:	68 38 14 81 00       	push   $0x811438
  802d82:	68 6c 05 00 00       	push   $0x56c
  802d87:	68 c2 14 81 00       	push   $0x8114c2
  802d8c:	e8 50 b6 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802d91:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802d95:	75 17                	jne    802dae <dhcp_delete_request+0x7b>
  802d97:	83 ec 04             	sub    $0x4,%esp
  802d9a:	68 64 14 81 00       	push   $0x811464
  802d9f:	68 6d 05 00 00       	push   $0x56d
  802da4:	68 c2 14 81 00       	push   $0x8114c2
  802da9:	e8 33 b6 00 00       	call   80e3e1 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  802dae:	83 ec 0c             	sub    $0xc,%esp
  802db1:	50                   	push   %eax
  802db2:	e8 38 1a 00 00       	call   8047ef <pbuf_free>
  }
  dhcp->p_out = NULL;
  802db7:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802dbe:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802dc5:	83 c4 10             	add    $0x10,%esp
}
  802dc8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802dcb:	c9                   	leave  
  802dcc:	c3                   	ret    

00802dcd <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  802dcd:	55                   	push   %ebp
  802dce:	89 e5                	mov    %esp,%ebp
  802dd0:	57                   	push   %edi
  802dd1:	56                   	push   %esi
  802dd2:	53                   	push   %ebx
  802dd3:	83 ec 0c             	sub    $0xc,%esp
  802dd6:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802dd8:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802ddb:	ba 04 00 00 00       	mov    $0x4,%edx
  802de0:	89 d8                	mov    %ebx,%eax
  802de2:	e8 d6 f9 ff ff       	call   8027bd <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802de7:	89 f8                	mov    %edi,%eax
  802de9:	e8 6a fd ff ff       	call   802b58 <dhcp_create_request>
  802dee:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802df0:	84 c0                	test   %al,%al
  802df2:	0f 85 89 00 00 00    	jne    802e81 <dhcp_rebind+0xb4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802df8:	b9 01 00 00 00       	mov    $0x1,%ecx
  802dfd:	ba 35 00 00 00       	mov    $0x35,%edx
  802e02:	89 d8                	mov    %ebx,%eax
  802e04:	e8 37 fb ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802e09:	ba 03 00 00 00       	mov    $0x3,%edx
  802e0e:	89 d8                	mov    %ebx,%eax
  802e10:	e8 ea fa ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802e15:	b9 02 00 00 00       	mov    $0x2,%ecx
  802e1a:	ba 39 00 00 00       	mov    $0x39,%edx
  802e1f:	89 d8                	mov    %ebx,%eax
  802e21:	e8 1a fb ff ff       	call   802940 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802e26:	ba 40 02 00 00       	mov    $0x240,%edx
  802e2b:	89 d8                	mov    %ebx,%eax
  802e2d:	e8 72 fb ff ff       	call   8029a4 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  802e32:	89 d8                	mov    %ebx,%eax
  802e34:	e8 cf fb ff ff       	call   802a08 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802e39:	83 ec 08             	sub    $0x8,%esp
  802e3c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802e40:	66 05 f0 00          	add    $0xf0,%ax
  802e44:	0f b7 c0             	movzwl %ax,%eax
  802e47:	50                   	push   %eax
  802e48:	ff 73 1c             	pushl  0x1c(%ebx)
  802e4b:	e8 e4 1c 00 00       	call   804b34 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802e50:	83 c4 0c             	add    $0xc,%esp
  802e53:	6a 43                	push   $0x43
  802e55:	68 80 1d 81 00       	push   $0x811d80
  802e5a:	ff 73 08             	pushl  0x8(%ebx)
  802e5d:	e8 dd 5f 00 00       	call   808e3f <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802e62:	89 3c 24             	mov    %edi,(%esp)
  802e65:	6a 43                	push   $0x43
  802e67:	68 7c 1d 81 00       	push   $0x811d7c
  802e6c:	ff 73 1c             	pushl  0x1c(%ebx)
  802e6f:	ff 73 08             	pushl  0x8(%ebx)
  802e72:	e8 e2 5d 00 00       	call   808c59 <udp_sendto_if>
    dhcp_delete_request(netif);
  802e77:	83 c4 20             	add    $0x20,%esp
  802e7a:	89 f8                	mov    %edi,%eax
  802e7c:	e8 b2 fe ff ff       	call   802d33 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802e81:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802e85:	8d 48 01             	lea    0x1(%eax),%ecx
  802e88:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802e8b:	b8 10 27 00 00       	mov    $0x2710,%eax
  802e90:	80 f9 09             	cmp    $0x9,%cl
  802e93:	77 08                	ja     802e9d <dhcp_rebind+0xd0>
  802e95:	0f b6 c9             	movzbl %cl,%ecx
  802e98:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e9d:	0f b7 c8             	movzwl %ax,%ecx
  802ea0:	81 c1 f3 01 00 00    	add    $0x1f3,%ecx
  802ea6:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802eab:	89 c8                	mov    %ecx,%eax
  802ead:	f7 ea                	imul   %edx
  802eaf:	c1 fa 05             	sar    $0x5,%edx
  802eb2:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802eb6:	89 f0                	mov    %esi,%eax
  802eb8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ebb:	5b                   	pop    %ebx
  802ebc:	5e                   	pop    %esi
  802ebd:	5f                   	pop    %edi
  802ebe:	5d                   	pop    %ebp
  802ebf:	c3                   	ret    

00802ec0 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  802ec0:	55                   	push   %ebp
  802ec1:	89 e5                	mov    %esp,%ebp
  802ec3:	57                   	push   %edi
  802ec4:	56                   	push   %esi
  802ec5:	53                   	push   %ebx
  802ec6:	83 ec 0c             	sub    $0xc,%esp
  802ec9:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802ecb:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802ece:	a1 80 1d 81 00       	mov    0x811d80,%eax
  802ed3:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802ed6:	89 f8                	mov    %edi,%eax
  802ed8:	e8 7b fc ff ff       	call   802b58 <dhcp_create_request>
  802edd:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802edf:	84 c0                	test   %al,%al
  802ee1:	0f 85 d6 00 00 00    	jne    802fbd <dhcp_discover+0xfd>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802ee7:	b9 01 00 00 00       	mov    $0x1,%ecx
  802eec:	ba 35 00 00 00       	mov    $0x35,%edx
  802ef1:	89 d8                	mov    %ebx,%eax
  802ef3:	e8 48 fa ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802ef8:	ba 01 00 00 00       	mov    $0x1,%edx
  802efd:	89 d8                	mov    %ebx,%eax
  802eff:	e8 fb f9 ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802f04:	b9 02 00 00 00       	mov    $0x2,%ecx
  802f09:	ba 39 00 00 00       	mov    $0x39,%edx
  802f0e:	89 d8                	mov    %ebx,%eax
  802f10:	e8 2b fa ff ff       	call   802940 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802f15:	ba 40 02 00 00       	mov    $0x240,%edx
  802f1a:	89 d8                	mov    %ebx,%eax
  802f1c:	e8 83 fa ff ff       	call   8029a4 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802f21:	b9 04 00 00 00       	mov    $0x4,%ecx
  802f26:	ba 37 00 00 00       	mov    $0x37,%edx
  802f2b:	89 d8                	mov    %ebx,%eax
  802f2d:	e8 0e fa ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802f32:	ba 01 00 00 00       	mov    $0x1,%edx
  802f37:	89 d8                	mov    %ebx,%eax
  802f39:	e8 c1 f9 ff ff       	call   8028ff <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802f3e:	ba 03 00 00 00       	mov    $0x3,%edx
  802f43:	89 d8                	mov    %ebx,%eax
  802f45:	e8 b5 f9 ff ff       	call   8028ff <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802f4a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802f4f:	89 d8                	mov    %ebx,%eax
  802f51:	e8 a9 f9 ff ff       	call   8028ff <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802f56:	ba 06 00 00 00       	mov    $0x6,%edx
  802f5b:	89 d8                	mov    %ebx,%eax
  802f5d:	e8 9d f9 ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  802f62:	89 d8                	mov    %ebx,%eax
  802f64:	e8 9f fa ff ff       	call   802a08 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802f69:	83 ec 08             	sub    $0x8,%esp
  802f6c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802f70:	66 05 f0 00          	add    $0xf0,%ax
  802f74:	0f b7 c0             	movzwl %ax,%eax
  802f77:	50                   	push   %eax
  802f78:	ff 73 1c             	pushl  0x1c(%ebx)
  802f7b:	e8 b4 1b 00 00       	call   804b34 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802f80:	83 c4 0c             	add    $0xc,%esp
  802f83:	6a 43                	push   $0x43
  802f85:	68 80 1d 81 00       	push   $0x811d80
  802f8a:	ff 73 08             	pushl  0x8(%ebx)
  802f8d:	e8 ad 5e 00 00       	call   808e3f <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802f92:	89 3c 24             	mov    %edi,(%esp)
  802f95:	6a 43                	push   $0x43
  802f97:	68 7c 1d 81 00       	push   $0x811d7c
  802f9c:	ff 73 1c             	pushl  0x1c(%ebx)
  802f9f:	ff 73 08             	pushl  0x8(%ebx)
  802fa2:	e8 b2 5c 00 00       	call   808c59 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  802fa7:	83 c4 20             	add    $0x20,%esp
  802faa:	89 f8                	mov    %edi,%eax
  802fac:	e8 82 fd ff ff       	call   802d33 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802fb1:	ba 06 00 00 00       	mov    $0x6,%edx
  802fb6:	89 d8                	mov    %ebx,%eax
  802fb8:	e8 00 f8 ff ff       	call   8027bd <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802fbd:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802fc1:	8d 48 01             	lea    0x1(%eax),%ecx
  802fc4:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802fc7:	b8 10 27 00 00       	mov    $0x2710,%eax
  802fcc:	80 f9 03             	cmp    $0x3,%cl
  802fcf:	77 0b                	ja     802fdc <dhcp_discover+0x11c>
  802fd1:	0f b6 c9             	movzbl %cl,%ecx
  802fd4:	83 c1 01             	add    $0x1,%ecx
  802fd7:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802fdc:	0f b7 c8             	movzwl %ax,%ecx
  802fdf:	81 c1 f3 01 00 00    	add    $0x1f3,%ecx
  802fe5:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802fea:	89 c8                	mov    %ecx,%eax
  802fec:	f7 ea                	imul   %edx
  802fee:	c1 fa 05             	sar    $0x5,%edx
  802ff1:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802ff5:	89 f0                	mov    %esi,%eax
  802ff7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ffa:	5b                   	pop    %ebx
  802ffb:	5e                   	pop    %esi
  802ffc:	5f                   	pop    %edi
  802ffd:	5d                   	pop    %ebp
  802ffe:	c3                   	ret    

00802fff <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  802fff:	55                   	push   %ebp
  803000:	89 e5                	mov    %esp,%ebp
  803002:	57                   	push   %edi
  803003:	56                   	push   %esi
  803004:	53                   	push   %ebx
  803005:	83 ec 0c             	sub    $0xc,%esp
  803008:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80300a:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80300d:	e8 46 fb ff ff       	call   802b58 <dhcp_create_request>
  803012:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803014:	84 c0                	test   %al,%al
  803016:	0f 85 20 01 00 00    	jne    80313c <dhcp_select+0x13d>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80301c:	b9 01 00 00 00       	mov    $0x1,%ecx
  803021:	ba 35 00 00 00       	mov    $0x35,%edx
  803026:	89 d8                	mov    %ebx,%eax
  803028:	e8 13 f9 ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80302d:	ba 03 00 00 00       	mov    $0x3,%edx
  803032:	89 d8                	mov    %ebx,%eax
  803034:	e8 c6 f8 ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803039:	b9 02 00 00 00       	mov    $0x2,%ecx
  80303e:	ba 39 00 00 00       	mov    $0x39,%edx
  803043:	89 d8                	mov    %ebx,%eax
  803045:	e8 f6 f8 ff ff       	call   802940 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80304a:	ba 40 02 00 00       	mov    $0x240,%edx
  80304f:	89 d8                	mov    %ebx,%eax
  803051:	e8 4e f9 ff ff       	call   8029a4 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803056:	b9 04 00 00 00       	mov    $0x4,%ecx
  80305b:	ba 32 00 00 00       	mov    $0x32,%edx
  803060:	89 d8                	mov    %ebx,%eax
  803062:	e8 d9 f8 ff ff       	call   802940 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803067:	83 ec 0c             	sub    $0xc,%esp
  80306a:	ff 73 30             	pushl  0x30(%ebx)
  80306d:	e8 2c 48 00 00       	call   80789e <ntohl>
  803072:	89 c2                	mov    %eax,%edx
  803074:	89 d8                	mov    %ebx,%eax
  803076:	e8 42 fa ff ff       	call   802abd <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80307b:	b9 04 00 00 00       	mov    $0x4,%ecx
  803080:	ba 36 00 00 00       	mov    $0x36,%edx
  803085:	89 d8                	mov    %ebx,%eax
  803087:	e8 b4 f8 ff ff       	call   802940 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80308c:	83 c4 04             	add    $0x4,%esp
  80308f:	ff 73 2c             	pushl  0x2c(%ebx)
  803092:	e8 07 48 00 00       	call   80789e <ntohl>
  803097:	89 c2                	mov    %eax,%edx
  803099:	89 d8                	mov    %ebx,%eax
  80309b:	e8 1d fa ff ff       	call   802abd <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8030a0:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030a5:	ba 37 00 00 00       	mov    $0x37,%edx
  8030aa:	89 d8                	mov    %ebx,%eax
  8030ac:	e8 8f f8 ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8030b1:	ba 01 00 00 00       	mov    $0x1,%edx
  8030b6:	89 d8                	mov    %ebx,%eax
  8030b8:	e8 42 f8 ff ff       	call   8028ff <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8030bd:	ba 03 00 00 00       	mov    $0x3,%edx
  8030c2:	89 d8                	mov    %ebx,%eax
  8030c4:	e8 36 f8 ff ff       	call   8028ff <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8030c9:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8030ce:	89 d8                	mov    %ebx,%eax
  8030d0:	e8 2a f8 ff ff       	call   8028ff <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8030d5:	ba 06 00 00 00       	mov    $0x6,%edx
  8030da:	89 d8                	mov    %ebx,%eax
  8030dc:	e8 1e f8 ff ff       	call   8028ff <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8030e1:	89 d8                	mov    %ebx,%eax
  8030e3:	e8 20 f9 ff ff       	call   802a08 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8030e8:	83 c4 08             	add    $0x8,%esp
  8030eb:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8030ef:	66 05 f0 00          	add    $0xf0,%ax
  8030f3:	0f b7 c0             	movzwl %ax,%eax
  8030f6:	50                   	push   %eax
  8030f7:	ff 73 1c             	pushl  0x1c(%ebx)
  8030fa:	e8 35 1a 00 00       	call   804b34 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8030ff:	89 3c 24             	mov    %edi,(%esp)
  803102:	6a 43                	push   $0x43
  803104:	68 7c 1d 81 00       	push   $0x811d7c
  803109:	ff 73 1c             	pushl  0x1c(%ebx)
  80310c:	ff 73 08             	pushl  0x8(%ebx)
  80310f:	e8 45 5b 00 00       	call   808c59 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803114:	83 c4 1c             	add    $0x1c,%esp
  803117:	6a 43                	push   $0x43
  803119:	68 80 1d 81 00       	push   $0x811d80
  80311e:	ff 73 08             	pushl  0x8(%ebx)
  803121:	e8 19 5d 00 00       	call   808e3f <udp_connect>
    dhcp_delete_request(netif);
  803126:	89 f8                	mov    %edi,%eax
  803128:	e8 06 fc ff ff       	call   802d33 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80312d:	ba 01 00 00 00       	mov    $0x1,%edx
  803132:	89 d8                	mov    %ebx,%eax
  803134:	e8 84 f6 ff ff       	call   8027bd <dhcp_set_state>
  803139:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80313c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803140:	8d 48 01             	lea    0x1(%eax),%ecx
  803143:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803146:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  80314b:	80 f9 03             	cmp    $0x3,%cl
  80314e:	77 08                	ja     803158 <dhcp_select+0x159>
  803150:	0f b6 c9             	movzbl %cl,%ecx
  803153:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803158:	0f b7 c8             	movzwl %ax,%ecx
  80315b:	81 c1 f3 01 00 00    	add    $0x1f3,%ecx
  803161:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803166:	89 c8                	mov    %ecx,%eax
  803168:	f7 ea                	imul   %edx
  80316a:	c1 fa 05             	sar    $0x5,%edx
  80316d:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803171:	89 f0                	mov    %esi,%eax
  803173:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803176:	5b                   	pop    %ebx
  803177:	5e                   	pop    %esi
  803178:	5f                   	pop    %edi
  803179:	5d                   	pop    %ebp
  80317a:	c3                   	ret    

0080317b <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  80317b:	55                   	push   %ebp
  80317c:	89 e5                	mov    %esp,%ebp
  80317e:	53                   	push   %ebx
  80317f:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  803182:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  803185:	6a 00                	push   $0x0
  803187:	8d 53 30             	lea    0x30(%ebx),%edx
  80318a:	52                   	push   %edx
  80318b:	50                   	push   %eax
  80318c:	e8 7d 66 00 00       	call   80980e <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  803191:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803195:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80319b:	ba 08 00 00 00       	mov    $0x8,%edx
  8031a0:	89 d8                	mov    %ebx,%eax
  8031a2:	e8 16 f6 ff ff       	call   8027bd <dhcp_set_state>
  8031a7:	83 c4 10             	add    $0x10,%esp
}
  8031aa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8031ad:	c9                   	leave  
  8031ae:	c3                   	ret    

008031af <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8031af:	55                   	push   %ebp
  8031b0:	89 e5                	mov    %esp,%ebp
  8031b2:	56                   	push   %esi
  8031b3:	53                   	push   %ebx
  8031b4:	83 ec 10             	sub    $0x10,%esp
  8031b7:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8031b9:	85 c0                	test   %eax,%eax
  8031bb:	75 17                	jne    8031d4 <dhcp_bind+0x25>
  8031bd:	83 ec 04             	sub    $0x4,%esp
  8031c0:	68 d7 14 81 00       	push   $0x8114d7
  8031c5:	68 3d 03 00 00       	push   $0x33d
  8031ca:	68 c2 14 81 00       	push   $0x8114c2
  8031cf:	e8 0d b2 00 00       	call   80e3e1 <_panic>
  dhcp = netif->dhcp;
  8031d4:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8031d7:	85 db                	test   %ebx,%ebx
  8031d9:	75 17                	jne    8031f2 <dhcp_bind+0x43>
  8031db:	83 ec 04             	sub    $0x4,%esp
  8031de:	68 f0 14 81 00       	push   $0x8114f0
  8031e3:	68 3f 03 00 00       	push   $0x33f
  8031e8:	68 c2 14 81 00       	push   $0x8114c2
  8031ed:	e8 ef b1 00 00       	call   80e3e1 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  8031f2:	8b 53 50             	mov    0x50(%ebx),%edx
  8031f5:	83 fa ff             	cmp    $0xffffffff,%edx
  8031f8:	74 2c                	je     803226 <dhcp_bind+0x77>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8031fa:	83 c2 1e             	add    $0x1e,%edx
  8031fd:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803202:	89 d0                	mov    %edx,%eax
  803204:	f7 e1                	mul    %ecx
  803206:	c1 ea 05             	shr    $0x5,%edx
  803209:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  80320f:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803214:	0f 47 d0             	cmova  %eax,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  803217:	66 85 d2             	test   %dx,%dx
  80321a:	b8 01 00 00 00       	mov    $0x1,%eax
  80321f:	0f 44 d0             	cmove  %eax,%edx
  803222:	66 89 53 28          	mov    %dx,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803226:	8b 53 54             	mov    0x54(%ebx),%edx
  803229:	83 fa ff             	cmp    $0xffffffff,%edx
  80322c:	74 2c                	je     80325a <dhcp_bind+0xab>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80322e:	83 c2 1e             	add    $0x1e,%edx
  803231:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803236:	89 d0                	mov    %edx,%eax
  803238:	f7 e1                	mul    %ecx
  80323a:	c1 ea 05             	shr    $0x5,%edx
  80323d:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803243:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803248:	0f 47 d0             	cmova  %eax,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80324b:	66 85 d2             	test   %dx,%dx
  80324e:	b8 01 00 00 00       	mov    $0x1,%eax
  803253:	0f 44 d0             	cmove  %eax,%edx
  803256:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80325a:	83 fb cc             	cmp    $0xffffffcc,%ebx
  80325d:	0f 84 c4 00 00 00    	je     803327 <dhcp_bind+0x178>
  803263:	8b 43 34             	mov    0x34(%ebx),%eax
  803266:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  803269:	85 c0                	test   %eax,%eax
  80326b:	75 55                	jne    8032c2 <dhcp_bind+0x113>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80326d:	83 ec 0c             	sub    $0xc,%esp
  803270:	6a 00                	push   $0x0
  803272:	e8 27 46 00 00       	call   80789e <ntohl>
  803277:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  80327a:	83 c4 10             	add    $0x10,%esp
  80327d:	84 c0                	test   %al,%al
  80327f:	78 15                	js     803296 <dhcp_bind+0xe7>
      sn_mask.addr = htonl(0xff000000);
  803281:	83 ec 0c             	sub    $0xc,%esp
  803284:	68 00 00 00 ff       	push   $0xff000000
  803289:	e8 d9 43 00 00       	call   807667 <htonl>
  80328e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803291:	83 c4 10             	add    $0x10,%esp
  803294:	eb 2c                	jmp    8032c2 <dhcp_bind+0x113>
    } else if (first_octet >= 192) {
  803296:	3c bf                	cmp    $0xbf,%al
  803298:	76 15                	jbe    8032af <dhcp_bind+0x100>
      sn_mask.addr = htonl(0xffffff00);
  80329a:	83 ec 0c             	sub    $0xc,%esp
  80329d:	68 00 ff ff ff       	push   $0xffffff00
  8032a2:	e8 c0 43 00 00       	call   807667 <htonl>
  8032a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032aa:	83 c4 10             	add    $0x10,%esp
  8032ad:	eb 13                	jmp    8032c2 <dhcp_bind+0x113>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  8032af:	83 ec 0c             	sub    $0xc,%esp
  8032b2:	68 00 00 ff ff       	push   $0xffff0000
  8032b7:	e8 ab 43 00 00       	call   807667 <htonl>
  8032bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032bf:	83 c4 10             	add    $0x10,%esp
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8032c2:	83 fb c8             	cmp    $0xffffffc8,%ebx
  8032c5:	74 0a                	je     8032d1 <dhcp_bind+0x122>
  8032c7:	8b 43 38             	mov    0x38(%ebx),%eax
  8032ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  8032cd:	85 c0                	test   %eax,%eax
  8032cf:	75 19                	jne    8032ea <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8032d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8032d4:	23 43 30             	and    0x30(%ebx),%eax
  8032d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  8032da:	83 ec 0c             	sub    $0xc,%esp
  8032dd:	6a 01                	push   $0x1
  8032df:	e8 83 43 00 00       	call   807667 <htonl>
  8032e4:	09 45 f0             	or     %eax,-0x10(%ebp)
  8032e7:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8032ea:	83 ec 08             	sub    $0x8,%esp
  8032ed:	8d 43 30             	lea    0x30(%ebx),%eax
  8032f0:	50                   	push   %eax
  8032f1:	56                   	push   %esi
  8032f2:	e8 45 12 00 00       	call   80453c <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  8032f7:	83 c4 08             	add    $0x8,%esp
  8032fa:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8032fd:	50                   	push   %eax
  8032fe:	56                   	push   %esi
  8032ff:	e8 9b 13 00 00       	call   80469f <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  803304:	83 c4 08             	add    $0x8,%esp
  803307:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80330a:	50                   	push   %eax
  80330b:	56                   	push   %esi
  80330c:	e8 73 13 00 00       	call   804684 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  803311:	89 34 24             	mov    %esi,(%esp)
  803314:	e8 ae 13 00 00       	call   8046c7 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  803319:	ba 0a 00 00 00       	mov    $0xa,%edx
  80331e:	89 d8                	mov    %ebx,%eax
  803320:	e8 98 f4 ff ff       	call   8027bd <dhcp_set_state>
  803325:	eb 0c                	jmp    803333 <dhcp_bind+0x184>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803327:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  80332e:	e9 3a ff ff ff       	jmp    80326d <dhcp_bind+0xbe>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  803333:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803336:	5b                   	pop    %ebx
  803337:	5e                   	pop    %esi
  803338:	5d                   	pop    %ebp
  803339:	c3                   	ret    

0080333a <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80333a:	55                   	push   %ebp
  80333b:	89 e5                	mov    %esp,%ebp
  80333d:	53                   	push   %ebx
  80333e:	83 ec 04             	sub    $0x4,%esp
  803341:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803343:	8b 40 10             	mov    0x10(%eax),%eax
  803346:	85 c0                	test   %eax,%eax
  803348:	74 13                	je     80335d <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  80334a:	83 ec 0c             	sub    $0xc,%esp
  80334d:	50                   	push   %eax
  80334e:	e8 0a 0c 00 00       	call   803f5d <mem_free>
    dhcp->msg_in = NULL;
  803353:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80335a:	83 c4 10             	add    $0x10,%esp
  }
  if (dhcp->options_in) {
  80335d:	8b 43 14             	mov    0x14(%ebx),%eax
  803360:	85 c0                	test   %eax,%eax
  803362:	74 19                	je     80337d <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803364:	83 ec 0c             	sub    $0xc,%esp
  803367:	50                   	push   %eax
  803368:	e8 f0 0b 00 00       	call   803f5d <mem_free>
    dhcp->options_in = NULL;
  80336d:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803374:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  80337a:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80337d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803380:	c9                   	leave  
  803381:	c3                   	ret    

00803382 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  803382:	55                   	push   %ebp
  803383:	89 e5                	mov    %esp,%ebp
  803385:	57                   	push   %edi
  803386:	56                   	push   %esi
  803387:	53                   	push   %ebx
  803388:	83 ec 1c             	sub    $0x1c,%esp
  80338b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  80338e:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803391:	8b 45 10             	mov    0x10(%ebp),%eax
  803394:	8b 48 04             	mov    0x4(%eax),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  803397:	89 46 0c             	mov    %eax,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80339a:	80 39 02             	cmpb   $0x2,(%ecx)
  80339d:	0f 85 b8 03 00 00    	jne    80375b <dhcp_recv+0x3d9>
  8033a3:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8033a7:	ba 00 00 00 00       	mov    $0x0,%edx
  8033ac:	eb 12                	jmp    8033c0 <dhcp_recv+0x3e>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8033ae:	0f b6 44 13 25       	movzbl 0x25(%ebx,%edx,1),%eax
  8033b3:	83 c2 01             	add    $0x1,%edx
  8033b6:	3a 44 11 1b          	cmp    0x1b(%ecx,%edx,1),%al
  8033ba:	0f 85 9b 03 00 00    	jne    80375b <dhcp_recv+0x3d9>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8033c0:	39 fa                	cmp    %edi,%edx
  8033c2:	75 ea                	jne    8033ae <dhcp_recv+0x2c>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8033c4:	83 ec 0c             	sub    $0xc,%esp
  8033c7:	ff 71 04             	pushl  0x4(%ecx)
  8033ca:	e8 cf 44 00 00       	call   80789e <ntohl>
  8033cf:	83 c4 10             	add    $0x10,%esp
  8033d2:	3b 46 04             	cmp    0x4(%esi),%eax
  8033d5:	0f 85 80 03 00 00    	jne    80375b <dhcp_recv+0x3d9>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  8033db:	85 f6                	test   %esi,%esi
  8033dd:	75 17                	jne    8033f6 <dhcp_recv+0x74>
  8033df:	83 ec 04             	sub    $0x4,%esp
  8033e2:	68 fb 14 81 00       	push   $0x8114fb
  8033e7:	68 89 04 00 00       	push   $0x489
  8033ec:	68 c2 14 81 00       	push   $0x8114c2
  8033f1:	e8 eb af 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8033f6:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  8033fa:	75 17                	jne    803413 <dhcp_recv+0x91>
  8033fc:	83 ec 04             	sub    $0x4,%esp
  8033ff:	68 08 15 81 00       	push   $0x811508
  803404:	68 8a 04 00 00       	push   $0x48a
  803409:	68 c2 14 81 00       	push   $0x8114c2
  80340e:	e8 ce af 00 00       	call   80e3e1 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  803413:	89 f0                	mov    %esi,%eax
  803415:	e8 20 ff ff ff       	call   80333a <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80341a:	8b 46 0c             	mov    0xc(%esi),%eax
  80341d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803421:	66 3d f0 00          	cmp    $0xf0,%ax
  803425:	76 22                	jbe    803449 <dhcp_recv+0xc7>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803427:	66 2d f0 00          	sub    $0xf0,%ax
  80342b:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80342f:	83 ec 0c             	sub    $0xc,%esp
  803432:	0f b7 c0             	movzwl %ax,%eax
  803435:	50                   	push   %eax
  803436:	e8 d4 0d 00 00       	call   80420f <mem_malloc>
  80343b:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  80343e:	83 c4 10             	add    $0x10,%esp
  803441:	85 c0                	test   %eax,%eax
  803443:	0f 84 12 03 00 00    	je     80375b <dhcp_recv+0x3d9>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803449:	83 ec 0c             	sub    $0xc,%esp
  80344c:	68 f0 00 00 00       	push   $0xf0
  803451:	e8 b9 0d 00 00       	call   80420f <mem_malloc>
  803456:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  803459:	83 c4 10             	add    $0x10,%esp
  80345c:	85 c0                	test   %eax,%eax
  80345e:	75 1a                	jne    80347a <dhcp_recv+0xf8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  803460:	83 ec 0c             	sub    $0xc,%esp
  803463:	ff 76 14             	pushl  0x14(%esi)
  803466:	e8 f2 0a 00 00       	call   803f5d <mem_free>
    dhcp->options_in = NULL;
  80346b:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  803472:	83 c4 10             	add    $0x10,%esp
  803475:	e9 e1 02 00 00       	jmp    80375b <dhcp_recv+0x3d9>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80347a:	6a 00                	push   $0x0
  80347c:	68 f0 00 00 00       	push   $0xf0
  803481:	50                   	push   %eax
  803482:	ff 76 0c             	pushl  0xc(%esi)
  803485:	e8 bb 1a 00 00       	call   804f45 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80348a:	83 c4 10             	add    $0x10,%esp
  80348d:	66 3d f0 00          	cmp    $0xf0,%ax
  803491:	74 17                	je     8034aa <dhcp_recv+0x128>
  803493:	83 ec 04             	sub    $0x4,%esp
  803496:	68 90 14 81 00       	push   $0x811490
  80349b:	68 a0 04 00 00       	push   $0x4a0
  8034a0:	68 c2 14 81 00       	push   $0x8114c2
  8034a5:	e8 37 af 00 00       	call   80e3e1 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8034aa:	8b 46 14             	mov    0x14(%esi),%eax
  8034ad:	85 c0                	test   %eax,%eax
  8034af:	0f 84 ba 02 00 00    	je     80376f <dhcp_recv+0x3ed>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034b5:	68 f0 00 00 00       	push   $0xf0
  8034ba:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  8034be:	52                   	push   %edx
  8034bf:	50                   	push   %eax
  8034c0:	ff 76 0c             	pushl  0xc(%esi)
  8034c3:	e8 7d 1a 00 00       	call   804f45 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8034c8:	83 c4 10             	add    $0x10,%esp
  8034cb:	66 3b 46 18          	cmp    0x18(%esi),%ax
  8034cf:	0f 84 9a 02 00 00    	je     80376f <dhcp_recv+0x3ed>
  8034d5:	83 ec 04             	sub    $0x4,%esp
  8034d8:	68 18 15 81 00       	push   $0x811518
  8034dd:	68 a7 04 00 00       	push   $0x4a7
  8034e2:	68 c2 14 81 00       	push   $0x8114c2
  8034e7:	e8 f5 ae 00 00       	call   80e3e1 <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  8034ec:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  8034f0:	3c 05                	cmp    $0x5,%al
  8034f2:	0f 85 a3 01 00 00    	jne    80369b <dhcp_recv+0x319>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  8034f8:	0f b6 06             	movzbl (%esi),%eax
  8034fb:	3c 01                	cmp    $0x1,%al
  8034fd:	0f 85 7b 01 00 00    	jne    80367e <dhcp_recv+0x2fc>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803503:	8b 7b 20             	mov    0x20(%ebx),%edi
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  803506:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%edi)
  dhcp->offered_gw_addr.addr = 0;
  80350d:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  dhcp->offered_bc_addr.addr = 0;
  803514:	c7 47 3c 00 00 00 00 	movl   $0x0,0x3c(%edi)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80351b:	ba 33 00 00 00       	mov    $0x33,%edx
  803520:	89 f8                	mov    %edi,%eax
  803522:	e8 a5 f2 ff ff       	call   8027cc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803527:	85 c0                	test   %eax,%eax
  803529:	74 0b                	je     803536 <dhcp_recv+0x1b4>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80352b:	83 c0 02             	add    $0x2,%eax
  80352e:	e8 a5 f3 ff ff       	call   8028d8 <dhcp_get_option_long>
  803533:	89 47 4c             	mov    %eax,0x4c(%edi)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803536:	ba 3a 00 00 00       	mov    $0x3a,%edx
  80353b:	89 f8                	mov    %edi,%eax
  80353d:	e8 8a f2 ff ff       	call   8027cc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803542:	85 c0                	test   %eax,%eax
  803544:	74 0d                	je     803553 <dhcp_recv+0x1d1>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  803546:	83 c0 02             	add    $0x2,%eax
  803549:	e8 8a f3 ff ff       	call   8028d8 <dhcp_get_option_long>
  80354e:	89 47 50             	mov    %eax,0x50(%edi)
  803551:	eb 08                	jmp    80355b <dhcp_recv+0x1d9>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803553:	8b 47 4c             	mov    0x4c(%edi),%eax
  803556:	d1 e8                	shr    %eax
  803558:	89 47 50             	mov    %eax,0x50(%edi)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  80355b:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803560:	89 f8                	mov    %edi,%eax
  803562:	e8 65 f2 ff ff       	call   8027cc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803567:	85 c0                	test   %eax,%eax
  803569:	74 0d                	je     803578 <dhcp_recv+0x1f6>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  80356b:	83 c0 02             	add    $0x2,%eax
  80356e:	e8 65 f3 ff ff       	call   8028d8 <dhcp_get_option_long>
  803573:	89 47 54             	mov    %eax,0x54(%edi)
  803576:	eb 06                	jmp    80357e <dhcp_recv+0x1fc>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803578:	8b 47 4c             	mov    0x4c(%edi),%eax
  80357b:	89 47 54             	mov    %eax,0x54(%edi)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  80357e:	8b 47 10             	mov    0x10(%edi),%eax
  803581:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803584:	74 05                	je     80358b <dhcp_recv+0x209>
  803586:	8b 40 10             	mov    0x10(%eax),%eax
  803589:	eb 05                	jmp    803590 <dhcp_recv+0x20e>
  80358b:	b8 00 00 00 00       	mov    $0x0,%eax
  803590:	89 47 30             	mov    %eax,0x30(%edi)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  803593:	ba 01 00 00 00       	mov    $0x1,%edx
  803598:	89 f8                	mov    %edi,%eax
  80359a:	e8 2d f2 ff ff       	call   8027cc <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  80359f:	85 c0                	test   %eax,%eax
  8035a1:	74 17                	je     8035ba <dhcp_recv+0x238>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035a3:	83 c0 02             	add    $0x2,%eax
  8035a6:	e8 2d f3 ff ff       	call   8028d8 <dhcp_get_option_long>
  8035ab:	83 ec 0c             	sub    $0xc,%esp
  8035ae:	50                   	push   %eax
  8035af:	e8 b3 40 00 00       	call   807667 <htonl>
  8035b4:	89 47 34             	mov    %eax,0x34(%edi)
  8035b7:	83 c4 10             	add    $0x10,%esp
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8035ba:	ba 03 00 00 00       	mov    $0x3,%edx
  8035bf:	89 f8                	mov    %edi,%eax
  8035c1:	e8 06 f2 ff ff       	call   8027cc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035c6:	85 c0                	test   %eax,%eax
  8035c8:	74 17                	je     8035e1 <dhcp_recv+0x25f>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035ca:	83 c0 02             	add    $0x2,%eax
  8035cd:	e8 06 f3 ff ff       	call   8028d8 <dhcp_get_option_long>
  8035d2:	83 ec 0c             	sub    $0xc,%esp
  8035d5:	50                   	push   %eax
  8035d6:	e8 8c 40 00 00       	call   807667 <htonl>
  8035db:	89 47 38             	mov    %eax,0x38(%edi)
  8035de:	83 c4 10             	add    $0x10,%esp
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  8035e1:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8035e6:	89 f8                	mov    %edi,%eax
  8035e8:	e8 df f1 ff ff       	call   8027cc <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035ed:	85 c0                	test   %eax,%eax
  8035ef:	74 17                	je     803608 <dhcp_recv+0x286>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035f1:	83 c0 02             	add    $0x2,%eax
  8035f4:	e8 df f2 ff ff       	call   8028d8 <dhcp_get_option_long>
  8035f9:	83 ec 0c             	sub    $0xc,%esp
  8035fc:	50                   	push   %eax
  8035fd:	e8 65 40 00 00       	call   807667 <htonl>
  803602:	89 47 3c             	mov    %eax,0x3c(%edi)
  803605:	83 c4 10             	add    $0x10,%esp
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803608:	ba 06 00 00 00       	mov    $0x6,%edx
  80360d:	89 f8                	mov    %edi,%eax
  80360f:	e8 b8 f1 ff ff       	call   8027cc <dhcp_get_option_ptr>
  803614:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (option_ptr != NULL) {
  803617:	85 c0                	test   %eax,%eax
  803619:	74 51                	je     80366c <dhcp_recv+0x2ea>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  80361b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  80361f:	c0 e8 02             	shr    $0x2,%al
  803622:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  803625:	83 f8 03             	cmp    $0x3,%eax
  803628:	ba 02 00 00 00       	mov    $0x2,%edx
  80362d:	0f 43 c2             	cmovae %edx,%eax
  803630:	89 47 40             	mov    %eax,0x40(%edi)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803633:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  803637:	89 5d 08             	mov    %ebx,0x8(%ebp)
  80363a:	eb 24                	jmp    803660 <dhcp_recv+0x2de>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  80363c:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  803640:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  803643:	8d 44 99 02          	lea    0x2(%ecx,%ebx,4),%eax
  803647:	e8 8c f2 ff ff       	call   8028d8 <dhcp_get_option_long>
  80364c:	83 ec 0c             	sub    $0xc,%esp
  80364f:	50                   	push   %eax
  803650:	e8 12 40 00 00       	call   807667 <htonl>
  803655:	89 44 9f 44          	mov    %eax,0x44(%edi,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  803659:	80 45 e7 01          	addb   $0x1,-0x19(%ebp)
  80365d:	83 c4 10             	add    $0x10,%esp
  803660:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  803664:	3b 47 40             	cmp    0x40(%edi),%eax
  803667:	72 d3                	jb     80363c <dhcp_recv+0x2ba>
  803669:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  80366c:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803672:	89 d8                	mov    %ebx,%eax
  803674:	e8 02 fb ff ff       	call   80317b <dhcp_check>
  803679:	e9 dd 00 00 00       	jmp    80375b <dhcp_recv+0x3d9>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80367e:	83 e8 03             	sub    $0x3,%eax
  803681:	3c 02                	cmp    $0x2,%al
  803683:	0f 87 d2 00 00 00    	ja     80375b <dhcp_recv+0x3d9>
      dhcp->request_timeout = 0;
  803689:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  80368f:	89 d8                	mov    %ebx,%eax
  803691:	e8 19 fb ff ff       	call   8031af <dhcp_bind>
  803696:	e9 c0 00 00 00       	jmp    80375b <dhcp_recv+0x3d9>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80369b:	3c 06                	cmp    $0x6,%al
  80369d:	75 67                	jne    803706 <dhcp_recv+0x384>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80369f:	0f b6 06             	movzbl (%esi),%eax
  8036a2:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8036a5:	80 fa 02             	cmp    $0x2,%dl
  8036a8:	76 08                	jbe    8036b2 <dhcp_recv+0x330>
  8036aa:	3c 01                	cmp    $0x1,%al
  8036ac:	0f 85 a9 00 00 00    	jne    80375b <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  8036b2:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8036b8:	8b 7b 20             	mov    0x20(%ebx),%edi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  8036bb:	83 ec 0c             	sub    $0xc,%esp
  8036be:	53                   	push   %ebx
  8036bf:	e8 34 10 00 00       	call   8046f8 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8036c4:	83 c4 08             	add    $0x8,%esp
  8036c7:	68 80 1d 81 00       	push   $0x811d80
  8036cc:	53                   	push   %ebx
  8036cd:	e8 6a 0e 00 00       	call   80453c <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8036d2:	83 c4 08             	add    $0x8,%esp
  8036d5:	68 80 1d 81 00       	push   $0x811d80
  8036da:	53                   	push   %ebx
  8036db:	e8 a4 0f 00 00       	call   804684 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  8036e0:	83 c4 08             	add    $0x8,%esp
  8036e3:	68 80 1d 81 00       	push   $0x811d80
  8036e8:	53                   	push   %ebx
  8036e9:	e8 b1 0f 00 00       	call   80469f <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8036ee:	ba 0c 00 00 00       	mov    $0xc,%edx
  8036f3:	89 f8                	mov    %edi,%eax
  8036f5:	e8 c3 f0 ff ff       	call   8027bd <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  8036fa:	89 d8                	mov    %ebx,%eax
  8036fc:	e8 bf f7 ff ff       	call   802ec0 <dhcp_discover>
  803701:	83 c4 10             	add    $0x10,%esp
  803704:	eb 55                	jmp    80375b <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803706:	3c 02                	cmp    $0x2,%al
  803708:	75 51                	jne    80375b <dhcp_recv+0x3d9>
  80370a:	80 3e 06             	cmpb   $0x6,(%esi)
  80370d:	75 4c                	jne    80375b <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80370f:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803715:	8b 7b 20             	mov    0x20(%ebx),%edi
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803718:	ba 36 00 00 00       	mov    $0x36,%edx
  80371d:	89 f8                	mov    %edi,%eax
  80371f:	e8 a8 f0 ff ff       	call   8027cc <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  803724:	85 c0                	test   %eax,%eax
  803726:	74 33                	je     80375b <dhcp_recv+0x3d9>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803728:	83 c0 02             	add    $0x2,%eax
  80372b:	e8 a8 f1 ff ff       	call   8028d8 <dhcp_get_option_long>
  803730:	83 ec 0c             	sub    $0xc,%esp
  803733:	50                   	push   %eax
  803734:	e8 2e 3f 00 00       	call   807667 <htonl>
  803739:	89 47 2c             	mov    %eax,0x2c(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  80373c:	8b 47 10             	mov    0x10(%edi),%eax
  80373f:	83 c4 10             	add    $0x10,%esp
  803742:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803745:	74 05                	je     80374c <dhcp_recv+0x3ca>
  803747:	8b 40 10             	mov    0x10(%eax),%eax
  80374a:	eb 05                	jmp    803751 <dhcp_recv+0x3cf>
  80374c:	b8 00 00 00 00       	mov    $0x0,%eax
  803751:	89 47 30             	mov    %eax,0x30(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  803754:	89 d8                	mov    %ebx,%eax
  803756:	e8 a4 f8 ff ff       	call   802fff <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  80375b:	83 ec 0c             	sub    $0xc,%esp
  80375e:	ff 75 10             	pushl  0x10(%ebp)
  803761:	e8 89 10 00 00       	call   8047ef <pbuf_free>
  dhcp->p = NULL;
  803766:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  80376d:	eb 16                	jmp    803785 <dhcp_recv+0x403>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80376f:	ba 35 00 00 00       	mov    $0x35,%edx
  803774:	89 f0                	mov    %esi,%eax
  803776:	e8 51 f0 ff ff       	call   8027cc <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  80377b:	85 c0                	test   %eax,%eax
  80377d:	0f 85 69 fd ff ff    	jne    8034ec <dhcp_recv+0x16a>
  803783:	eb d6                	jmp    80375b <dhcp_recv+0x3d9>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  803785:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803788:	5b                   	pop    %ebx
  803789:	5e                   	pop    %esi
  80378a:	5f                   	pop    %edi
  80378b:	5d                   	pop    %ebp
  80378c:	c3                   	ret    

0080378d <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  80378d:	55                   	push   %ebp
  80378e:	89 e5                	mov    %esp,%ebp
  803790:	57                   	push   %edi
  803791:	56                   	push   %esi
  803792:	53                   	push   %ebx
  803793:	83 ec 18             	sub    $0x18,%esp
  803796:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803799:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  80379c:	6a 58                	push   $0x58
  80379e:	e8 6c 0a 00 00       	call   80420f <mem_malloc>
  8037a3:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  8037a5:	83 c4 10             	add    $0x10,%esp
  8037a8:	85 c0                	test   %eax,%eax
  8037aa:	0f 84 1b 01 00 00    	je     8038cb <dhcp_inform+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  8037b0:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  8037b3:	83 ec 04             	sub    $0x4,%esp
  8037b6:	6a 58                	push   $0x58
  8037b8:	6a 00                	push   $0x0
  8037ba:	50                   	push   %eax
  8037bb:	e8 c6 b3 00 00       	call   80eb86 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  8037c0:	e8 60 57 00 00       	call   808f25 <udp_new>
  8037c5:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8037c8:	83 c4 10             	add    $0x10,%esp
  8037cb:	85 c0                	test   %eax,%eax
  8037cd:	75 11                	jne    8037e0 <dhcp_inform+0x53>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  8037cf:	83 ec 0c             	sub    $0xc,%esp
  8037d2:	53                   	push   %ebx
  8037d3:	e8 85 07 00 00       	call   803f5d <mem_free>
    return;
  8037d8:	83 c4 10             	add    $0x10,%esp
  8037db:	e9 eb 00 00 00       	jmp    8038cb <dhcp_inform+0x13e>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8037e0:	89 f0                	mov    %esi,%eax
  8037e2:	e8 71 f3 ff ff       	call   802b58 <dhcp_create_request>
  if (result == ERR_OK) {
  8037e7:	84 c0                	test   %al,%al
  8037e9:	0f 85 d3 00 00 00    	jne    8038c2 <dhcp_inform+0x135>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8037ef:	b9 01 00 00 00       	mov    $0x1,%ecx
  8037f4:	ba 35 00 00 00       	mov    $0x35,%edx
  8037f9:	89 d8                	mov    %ebx,%eax
  8037fb:	e8 40 f1 ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803800:	ba 08 00 00 00       	mov    $0x8,%edx
  803805:	89 d8                	mov    %ebx,%eax
  803807:	e8 f3 f0 ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80380c:	b9 02 00 00 00       	mov    $0x2,%ecx
  803811:	ba 39 00 00 00       	mov    $0x39,%edx
  803816:	89 d8                	mov    %ebx,%eax
  803818:	e8 23 f1 ff ff       	call   802940 <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  80381d:	ba 40 02 00 00       	mov    $0x240,%edx
  803822:	89 d8                	mov    %ebx,%eax
  803824:	e8 7b f1 ff ff       	call   8029a4 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803829:	89 d8                	mov    %ebx,%eax
  80382b:	e8 d8 f1 ff ff       	call   802a08 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803830:	83 ec 08             	sub    $0x8,%esp
  803833:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803837:	66 05 f0 00          	add    $0xf0,%ax
  80383b:	0f b7 c0             	movzwl %ax,%eax
  80383e:	50                   	push   %eax
  80383f:	ff 73 1c             	pushl  0x1c(%ebx)
  803842:	e8 ed 12 00 00       	call   804b34 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803847:	83 c4 0c             	add    $0xc,%esp
  80384a:	6a 44                	push   $0x44
  80384c:	68 80 1d 81 00       	push   $0x811d80
  803851:	ff 73 08             	pushl  0x8(%ebx)
  803854:	e8 33 53 00 00       	call   808b8c <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803859:	83 c4 0c             	add    $0xc,%esp
  80385c:	6a 43                	push   $0x43
  80385e:	68 7c 1d 81 00       	push   $0x811d7c
  803863:	ff 73 08             	pushl  0x8(%ebx)
  803866:	e8 d4 55 00 00       	call   808e3f <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80386b:	89 34 24             	mov    %esi,(%esp)
  80386e:	6a 43                	push   $0x43
  803870:	68 7c 1d 81 00       	push   $0x811d7c
  803875:	ff 73 1c             	pushl  0x1c(%ebx)
  803878:	ff 73 08             	pushl  0x8(%ebx)
  80387b:	e8 d9 53 00 00       	call   808c59 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803880:	83 c4 1c             	add    $0x1c,%esp
  803883:	6a 43                	push   $0x43
  803885:	68 80 1d 81 00       	push   $0x811d80
  80388a:	ff 73 08             	pushl  0x8(%ebx)
  80388d:	e8 ad 55 00 00       	call   808e3f <udp_connect>
    dhcp_delete_request(netif);
  803892:	89 f0                	mov    %esi,%eax
  803894:	e8 9a f4 ff ff       	call   802d33 <dhcp_delete_request>
  803899:	83 c4 10             	add    $0x10,%esp
  80389c:	eb 24                	jmp    8038c2 <dhcp_inform+0x135>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  80389e:	83 ec 0c             	sub    $0xc,%esp
  8038a1:	50                   	push   %eax
  8038a2:	e8 3a 56 00 00       	call   808ee1 <udp_remove>
  8038a7:	83 c4 10             	add    $0x10,%esp
    }
    dhcp->pcb = NULL;
  8038aa:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8038b1:	83 ec 0c             	sub    $0xc,%esp
  8038b4:	53                   	push   %ebx
  8038b5:	e8 a3 06 00 00       	call   803f5d <mem_free>
    netif->dhcp = old_dhcp;
  8038ba:	89 7e 20             	mov    %edi,0x20(%esi)
  8038bd:	83 c4 10             	add    $0x10,%esp
  8038c0:	eb 09                	jmp    8038cb <dhcp_inform+0x13e>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  8038c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8038c5:	85 c0                	test   %eax,%eax
  8038c7:	75 d5                	jne    80389e <dhcp_inform+0x111>
  8038c9:	eb df                	jmp    8038aa <dhcp_inform+0x11d>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  8038cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8038ce:	5b                   	pop    %ebx
  8038cf:	5e                   	pop    %esi
  8038d0:	5f                   	pop    %edi
  8038d1:	5d                   	pop    %ebp
  8038d2:	c3                   	ret    

008038d3 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  8038d3:	55                   	push   %ebp
  8038d4:	89 e5                	mov    %esp,%ebp
  8038d6:	56                   	push   %esi
  8038d7:	53                   	push   %ebx
  8038d8:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8038db:	85 f6                	test   %esi,%esi
  8038dd:	75 17                	jne    8038f6 <dhcp_arp_reply+0x23>
  8038df:	83 ec 04             	sub    $0x4,%esp
  8038e2:	68 e2 14 81 00       	push   $0x8114e2
  8038e7:	68 b5 02 00 00       	push   $0x2b5
  8038ec:	68 c2 14 81 00       	push   $0x8114c2
  8038f1:	e8 eb aa 00 00       	call   80e3e1 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  8038f6:	8b 5e 20             	mov    0x20(%esi),%ebx
  8038f9:	85 db                	test   %ebx,%ebx
  8038fb:	0f 84 ea 00 00 00    	je     8039eb <dhcp_arp_reply+0x118>
  803901:	80 3b 08             	cmpb   $0x8,(%ebx)
  803904:	0f 85 e1 00 00 00    	jne    8039eb <dhcp_arp_reply+0x118>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80390a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80390d:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803910:	39 08                	cmp    %ecx,(%eax)
  803912:	0f 85 d3 00 00 00    	jne    8039eb <dhcp_arp_reply+0x118>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803918:	ba 0c 00 00 00       	mov    $0xc,%edx
  80391d:	89 d8                	mov    %ebx,%eax
  80391f:	e8 99 ee ff ff       	call   8027bd <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803924:	89 f0                	mov    %esi,%eax
  803926:	e8 2d f2 ff ff       	call   802b58 <dhcp_create_request>
  if (result == ERR_OK) {
  80392b:	84 c0                	test   %al,%al
  80392d:	0f 85 ae 00 00 00    	jne    8039e1 <dhcp_arp_reply+0x10e>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803933:	b9 01 00 00 00       	mov    $0x1,%ecx
  803938:	ba 35 00 00 00       	mov    $0x35,%edx
  80393d:	89 d8                	mov    %ebx,%eax
  80393f:	e8 fc ef ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803944:	ba 04 00 00 00       	mov    $0x4,%edx
  803949:	89 d8                	mov    %ebx,%eax
  80394b:	e8 af ef ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803950:	b9 02 00 00 00       	mov    $0x2,%ecx
  803955:	ba 39 00 00 00       	mov    $0x39,%edx
  80395a:	89 d8                	mov    %ebx,%eax
  80395c:	e8 df ef ff ff       	call   802940 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803961:	ba 40 02 00 00       	mov    $0x240,%edx
  803966:	89 d8                	mov    %ebx,%eax
  803968:	e8 37 f0 ff ff       	call   8029a4 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80396d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803972:	ba 32 00 00 00       	mov    $0x32,%edx
  803977:	89 d8                	mov    %ebx,%eax
  803979:	e8 c2 ef ff ff       	call   802940 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80397e:	83 ec 0c             	sub    $0xc,%esp
  803981:	ff 73 30             	pushl  0x30(%ebx)
  803984:	e8 15 3f 00 00       	call   80789e <ntohl>
  803989:	89 c2                	mov    %eax,%edx
  80398b:	89 d8                	mov    %ebx,%eax
  80398d:	e8 2b f1 ff ff       	call   802abd <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  803992:	89 d8                	mov    %ebx,%eax
  803994:	e8 6f f0 ff ff       	call   802a08 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803999:	83 c4 08             	add    $0x8,%esp
  80399c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8039a0:	66 05 f0 00          	add    $0xf0,%ax
  8039a4:	0f b7 c0             	movzwl %ax,%eax
  8039a7:	50                   	push   %eax
  8039a8:	ff 73 1c             	pushl  0x1c(%ebx)
  8039ab:	e8 84 11 00 00       	call   804b34 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8039b0:	83 c4 0c             	add    $0xc,%esp
  8039b3:	6a 43                	push   $0x43
  8039b5:	68 80 1d 81 00       	push   $0x811d80
  8039ba:	ff 73 08             	pushl  0x8(%ebx)
  8039bd:	e8 7d 54 00 00       	call   808e3f <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8039c2:	89 34 24             	mov    %esi,(%esp)
  8039c5:	6a 43                	push   $0x43
  8039c7:	68 7c 1d 81 00       	push   $0x811d7c
  8039cc:	ff 73 1c             	pushl  0x1c(%ebx)
  8039cf:	ff 73 08             	pushl  0x8(%ebx)
  8039d2:	e8 82 52 00 00       	call   808c59 <udp_sendto_if>
    dhcp_delete_request(netif);
  8039d7:	83 c4 20             	add    $0x20,%esp
  8039da:	89 f0                	mov    %esi,%eax
  8039dc:	e8 52 f3 ff ff       	call   802d33 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8039e1:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8039e5:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  8039eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8039ee:	5b                   	pop    %ebx
  8039ef:	5e                   	pop    %esi
  8039f0:	5d                   	pop    %ebp
  8039f1:	c3                   	ret    

008039f2 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  8039f2:	55                   	push   %ebp
  8039f3:	89 e5                	mov    %esp,%ebp
  8039f5:	57                   	push   %edi
  8039f6:	56                   	push   %esi
  8039f7:	53                   	push   %ebx
  8039f8:	83 ec 1c             	sub    $0x1c,%esp
  8039fb:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  8039fe:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803a01:	ba 05 00 00 00       	mov    $0x5,%edx
  803a06:	89 d8                	mov    %ebx,%eax
  803a08:	e8 b0 ed ff ff       	call   8027bd <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803a0d:	89 f8                	mov    %edi,%eax
  803a0f:	e8 44 f1 ff ff       	call   802b58 <dhcp_create_request>
  803a14:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803a16:	84 c0                	test   %al,%al
  803a18:	0f 85 89 00 00 00    	jne    803aa7 <dhcp_renew+0xb5>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a1e:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a23:	ba 35 00 00 00       	mov    $0x35,%edx
  803a28:	89 d8                	mov    %ebx,%eax
  803a2a:	e8 11 ef ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803a2f:	ba 03 00 00 00       	mov    $0x3,%edx
  803a34:	89 d8                	mov    %ebx,%eax
  803a36:	e8 c4 ee ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a3b:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a40:	ba 39 00 00 00       	mov    $0x39,%edx
  803a45:	89 d8                	mov    %ebx,%eax
  803a47:	e8 f4 ee ff ff       	call   802940 <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803a4c:	ba 40 02 00 00       	mov    $0x240,%edx
  803a51:	89 d8                	mov    %ebx,%eax
  803a53:	e8 4c ef ff ff       	call   8029a4 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803a58:	89 d8                	mov    %ebx,%eax
  803a5a:	e8 a9 ef ff ff       	call   802a08 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a5f:	83 ec 08             	sub    $0x8,%esp
  803a62:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a66:	66 05 f0 00          	add    $0xf0,%ax
  803a6a:	0f b7 c0             	movzwl %ax,%eax
  803a6d:	50                   	push   %eax
  803a6e:	ff 73 1c             	pushl  0x1c(%ebx)
  803a71:	e8 be 10 00 00       	call   804b34 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803a76:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803a79:	83 c4 0c             	add    $0xc,%esp
  803a7c:	6a 43                	push   $0x43
  803a7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803a81:	50                   	push   %eax
  803a82:	ff 73 08             	pushl  0x8(%ebx)
  803a85:	e8 b5 53 00 00       	call   808e3f <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803a8a:	89 3c 24             	mov    %edi,(%esp)
  803a8d:	6a 43                	push   $0x43
  803a8f:	ff 75 e4             	pushl  -0x1c(%ebp)
  803a92:	ff 73 1c             	pushl  0x1c(%ebx)
  803a95:	ff 73 08             	pushl  0x8(%ebx)
  803a98:	e8 bc 51 00 00       	call   808c59 <udp_sendto_if>
    dhcp_delete_request(netif);
  803a9d:	83 c4 20             	add    $0x20,%esp
  803aa0:	89 f8                	mov    %edi,%eax
  803aa2:	e8 8c f2 ff ff       	call   802d33 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803aa7:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803aab:	83 c0 01             	add    $0x1,%eax
  803aae:	88 43 01             	mov    %al,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803ab1:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803ab6:	3c 09                	cmp    $0x9,%al
  803ab8:	77 08                	ja     803ac2 <dhcp_renew+0xd0>
  803aba:	0f b6 c0             	movzbl %al,%eax
  803abd:	66 69 d0 d0 07       	imul   $0x7d0,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803ac2:	0f b7 c2             	movzwl %dx,%eax
  803ac5:	05 f3 01 00 00       	add    $0x1f3,%eax
  803aca:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803acf:	f7 ea                	imul   %edx
  803ad1:	c1 fa 05             	sar    $0x5,%edx
  803ad4:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803ad8:	89 f0                	mov    %esi,%eax
  803ada:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803add:	5b                   	pop    %ebx
  803ade:	5e                   	pop    %esi
  803adf:	5f                   	pop    %edi
  803ae0:	5d                   	pop    %ebp
  803ae1:	c3                   	ret    

00803ae2 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  803ae2:	55                   	push   %ebp
  803ae3:	89 e5                	mov    %esp,%ebp
  803ae5:	53                   	push   %ebx
  803ae6:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803ae9:	8b 1d 74 b3 b3 00    	mov    0xb3b374,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803aef:	eb 6b                	jmp    803b5c <dhcp_coarse_tmr+0x7a>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803af1:	8b 43 20             	mov    0x20(%ebx),%eax
  803af4:	85 c0                	test   %eax,%eax
  803af6:	74 62                	je     803b5a <dhcp_coarse_tmr+0x78>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803af8:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803afc:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803aff:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803b03:	66 83 fa 01          	cmp    $0x1,%dx
  803b07:	75 1d                	jne    803b26 <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b09:	8b 43 20             	mov    0x20(%ebx),%eax
  803b0c:	0f b6 00             	movzbl (%eax),%eax
  803b0f:	89 c2                	mov    %eax,%edx
  803b11:	83 e2 fb             	and    $0xfffffffb,%edx
  803b14:	80 fa 01             	cmp    $0x1,%dl
  803b17:	74 04                	je     803b1d <dhcp_coarse_tmr+0x3b>
  803b19:	3c 0a                	cmp    $0xa,%al
  803b1b:	75 3d                	jne    803b5a <dhcp_coarse_tmr+0x78>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  803b1d:	89 d8                	mov    %ebx,%eax
  803b1f:	e8 a9 f2 ff ff       	call   802dcd <dhcp_rebind>
  803b24:	eb 34                	jmp    803b5a <dhcp_coarse_tmr+0x78>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803b26:	8b 53 20             	mov    0x20(%ebx),%edx
  803b29:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803b2d:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803b30:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803b34:	66 83 f8 01          	cmp    $0x1,%ax
  803b38:	75 20                	jne    803b5a <dhcp_coarse_tmr+0x78>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b3a:	8b 43 20             	mov    0x20(%ebx),%eax
  803b3d:	0f b6 00             	movzbl (%eax),%eax
  803b40:	89 c2                	mov    %eax,%edx
  803b42:	83 e2 fb             	and    $0xfffffffb,%edx
  803b45:	80 fa 01             	cmp    $0x1,%dl
  803b48:	74 04                	je     803b4e <dhcp_coarse_tmr+0x6c>
  803b4a:	3c 0a                	cmp    $0xa,%al
  803b4c:	75 0c                	jne    803b5a <dhcp_coarse_tmr+0x78>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  803b4e:	83 ec 0c             	sub    $0xc,%esp
  803b51:	53                   	push   %ebx
  803b52:	e8 9b fe ff ff       	call   8039f2 <dhcp_renew>
  803b57:	83 c4 10             	add    $0x10,%esp
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  803b5a:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803b5c:	85 db                	test   %ebx,%ebx
  803b5e:	75 91                	jne    803af1 <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  803b60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803b63:	c9                   	leave  
  803b64:	c3                   	ret    

00803b65 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  803b65:	55                   	push   %ebp
  803b66:	89 e5                	mov    %esp,%ebp
  803b68:	57                   	push   %edi
  803b69:	56                   	push   %esi
  803b6a:	53                   	push   %ebx
  803b6b:	83 ec 1c             	sub    $0x1c,%esp
  803b6e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803b71:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  803b74:	ba 0d 00 00 00       	mov    $0xd,%edx
  803b79:	89 d8                	mov    %ebx,%eax
  803b7b:	e8 3d ec ff ff       	call   8027bd <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  803b80:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803b87:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803b8e:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803b95:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803b9c:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803ba3:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803baa:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803bb1:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803bb8:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803bbf:	89 f0                	mov    %esi,%eax
  803bc1:	e8 92 ef ff ff       	call   802b58 <dhcp_create_request>
  803bc6:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803bc8:	84 c0                	test   %al,%al
  803bca:	75 6c                	jne    803c38 <dhcp_release+0xd3>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803bcc:	b9 01 00 00 00       	mov    $0x1,%ecx
  803bd1:	ba 35 00 00 00       	mov    $0x35,%edx
  803bd6:	89 d8                	mov    %ebx,%eax
  803bd8:	e8 63 ed ff ff       	call   802940 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803bdd:	ba 07 00 00 00       	mov    $0x7,%edx
  803be2:	89 d8                	mov    %ebx,%eax
  803be4:	e8 16 ed ff ff       	call   8028ff <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  803be9:	89 d8                	mov    %ebx,%eax
  803beb:	e8 18 ee ff ff       	call   802a08 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803bf0:	83 ec 08             	sub    $0x8,%esp
  803bf3:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803bf7:	66 05 f0 00          	add    $0xf0,%ax
  803bfb:	0f b7 c0             	movzwl %ax,%eax
  803bfe:	50                   	push   %eax
  803bff:	ff 73 1c             	pushl  0x1c(%ebx)
  803c02:	e8 2d 0f 00 00       	call   804b34 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c07:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c0a:	83 c4 0c             	add    $0xc,%esp
  803c0d:	6a 43                	push   $0x43
  803c0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c12:	50                   	push   %eax
  803c13:	ff 73 08             	pushl  0x8(%ebx)
  803c16:	e8 24 52 00 00       	call   808e3f <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c1b:	89 34 24             	mov    %esi,(%esp)
  803c1e:	6a 43                	push   $0x43
  803c20:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c23:	ff 73 1c             	pushl  0x1c(%ebx)
  803c26:	ff 73 08             	pushl  0x8(%ebx)
  803c29:	e8 2b 50 00 00       	call   808c59 <udp_sendto_if>
    dhcp_delete_request(netif);
  803c2e:	83 c4 20             	add    $0x20,%esp
  803c31:	89 f0                	mov    %esi,%eax
  803c33:	e8 fb f0 ff ff       	call   802d33 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803c38:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803c3c:	83 c0 01             	add    $0x1,%eax
  803c3f:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803c42:	ba 10 27 00 00       	mov    $0x2710,%edx
  803c47:	3c 09                	cmp    $0x9,%al
  803c49:	77 08                	ja     803c53 <dhcp_release+0xee>
  803c4b:	0f b6 c0             	movzbl %al,%eax
  803c4e:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803c53:	0f b7 c2             	movzwl %dx,%eax
  803c56:	05 f3 01 00 00       	add    $0x1f3,%eax
  803c5b:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803c60:	f7 ea                	imul   %edx
  803c62:	c1 fa 05             	sar    $0x5,%edx
  803c65:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  803c69:	83 ec 0c             	sub    $0xc,%esp
  803c6c:	56                   	push   %esi
  803c6d:	e8 86 0a 00 00       	call   8046f8 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803c72:	83 c4 08             	add    $0x8,%esp
  803c75:	68 80 1d 81 00       	push   $0x811d80
  803c7a:	56                   	push   %esi
  803c7b:	e8 bc 08 00 00       	call   80453c <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803c80:	83 c4 08             	add    $0x8,%esp
  803c83:	68 80 1d 81 00       	push   $0x811d80
  803c88:	56                   	push   %esi
  803c89:	e8 f6 09 00 00       	call   804684 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803c8e:	83 c4 08             	add    $0x8,%esp
  803c91:	68 80 1d 81 00       	push   $0x811d80
  803c96:	56                   	push   %esi
  803c97:	e8 03 0a 00 00       	call   80469f <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  803c9c:	89 f8                	mov    %edi,%eax
  803c9e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803ca1:	5b                   	pop    %ebx
  803ca2:	5e                   	pop    %esi
  803ca3:	5f                   	pop    %edi
  803ca4:	5d                   	pop    %ebp
  803ca5:	c3                   	ret    

00803ca6 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  803ca6:	55                   	push   %ebp
  803ca7:	89 e5                	mov    %esp,%ebp
  803ca9:	53                   	push   %ebx
  803caa:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803cad:	8b 1d 74 b3 b3 00    	mov    0xb3b374,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  803cb3:	e9 c6 00 00 00       	jmp    803d7e <dhcp_fine_tmr+0xd8>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803cb8:	8b 53 20             	mov    0x20(%ebx),%edx
  803cbb:	85 d2                	test   %edx,%edx
  803cbd:	0f 84 b9 00 00 00    	je     803d7c <dhcp_fine_tmr+0xd6>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  803cc3:	0f b7 42 26          	movzwl 0x26(%edx),%eax
  803cc7:	66 83 f8 01          	cmp    $0x1,%ax
  803ccb:	76 0c                	jbe    803cd9 <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  803ccd:	83 e8 01             	sub    $0x1,%eax
  803cd0:	66 89 42 26          	mov    %ax,0x26(%edx)
  803cd4:	e9 a3 00 00 00       	jmp    803d7c <dhcp_fine_tmr+0xd6>
      }
      else if (netif->dhcp->request_timeout == 1) {
  803cd9:	66 83 f8 01          	cmp    $0x1,%ax
  803cdd:	0f 85 99 00 00 00    	jne    803d7c <dhcp_fine_tmr+0xd6>
        netif->dhcp->request_timeout--;
  803ce3:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803ce9:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803cec:	0f b6 02             	movzbl (%edx),%eax
  803cef:	3c 06                	cmp    $0x6,%al
  803cf1:	74 04                	je     803cf7 <dhcp_fine_tmr+0x51>
  803cf3:	3c 0c                	cmp    $0xc,%al
  803cf5:	75 09                	jne    803d00 <dhcp_fine_tmr+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  803cf7:	89 d8                	mov    %ebx,%eax
  803cf9:	e8 c2 f1 ff ff       	call   802ec0 <dhcp_discover>
  803cfe:	eb 7c                	jmp    803d7c <dhcp_fine_tmr+0xd6>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  803d00:	3c 01                	cmp    $0x1,%al
  803d02:	75 24                	jne    803d28 <dhcp_fine_tmr+0x82>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  803d04:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803d08:	77 09                	ja     803d13 <dhcp_fine_tmr+0x6d>
      dhcp_select(netif);
  803d0a:	89 d8                	mov    %ebx,%eax
  803d0c:	e8 ee f2 ff ff       	call   802fff <dhcp_select>
  803d11:	eb 69                	jmp    803d7c <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  803d13:	83 ec 0c             	sub    $0xc,%esp
  803d16:	53                   	push   %ebx
  803d17:	e8 49 fe ff ff       	call   803b65 <dhcp_release>
      dhcp_discover(netif);
  803d1c:	89 d8                	mov    %ebx,%eax
  803d1e:	e8 9d f1 ff ff       	call   802ec0 <dhcp_discover>
  803d23:	83 c4 10             	add    $0x10,%esp
  803d26:	eb 54                	jmp    803d7c <dhcp_fine_tmr+0xd6>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  803d28:	3c 08                	cmp    $0x8,%al
  803d2a:	75 18                	jne    803d44 <dhcp_fine_tmr+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  803d2c:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803d30:	77 09                	ja     803d3b <dhcp_fine_tmr+0x95>
      dhcp_check(netif);
  803d32:	89 d8                	mov    %ebx,%eax
  803d34:	e8 42 f4 ff ff       	call   80317b <dhcp_check>
  803d39:	eb 41                	jmp    803d7c <dhcp_fine_tmr+0xd6>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  803d3b:	89 d8                	mov    %ebx,%eax
  803d3d:	e8 6d f4 ff ff       	call   8031af <dhcp_bind>
  803d42:	eb 38                	jmp    803d7c <dhcp_fine_tmr+0xd6>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  803d44:	3c 05                	cmp    $0x5,%al
  803d46:	75 0e                	jne    803d56 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  803d48:	83 ec 0c             	sub    $0xc,%esp
  803d4b:	53                   	push   %ebx
  803d4c:	e8 a1 fc ff ff       	call   8039f2 <dhcp_renew>
  803d51:	83 c4 10             	add    $0x10,%esp
  803d54:	eb 26                	jmp    803d7c <dhcp_fine_tmr+0xd6>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  803d56:	3c 04                	cmp    $0x4,%al
  803d58:	75 22                	jne    803d7c <dhcp_fine_tmr+0xd6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  803d5a:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803d5e:	77 09                	ja     803d69 <dhcp_fine_tmr+0xc3>
      dhcp_rebind(netif);
  803d60:	89 d8                	mov    %ebx,%eax
  803d62:	e8 66 f0 ff ff       	call   802dcd <dhcp_rebind>
  803d67:	eb 13                	jmp    803d7c <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  803d69:	83 ec 0c             	sub    $0xc,%esp
  803d6c:	53                   	push   %ebx
  803d6d:	e8 f3 fd ff ff       	call   803b65 <dhcp_release>
      dhcp_discover(netif);
  803d72:	89 d8                	mov    %ebx,%eax
  803d74:	e8 47 f1 ff ff       	call   802ec0 <dhcp_discover>
  803d79:	83 c4 10             	add    $0x10,%esp
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  803d7c:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  803d7e:	85 db                	test   %ebx,%ebx
  803d80:	0f 85 32 ff ff ff    	jne    803cb8 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  803d86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803d89:	c9                   	leave  
  803d8a:	c3                   	ret    

00803d8b <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  803d8b:	55                   	push   %ebp
  803d8c:	89 e5                	mov    %esp,%ebp
  803d8e:	56                   	push   %esi
  803d8f:	53                   	push   %ebx
  803d90:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803d93:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803d96:	85 f6                	test   %esi,%esi
  803d98:	75 17                	jne    803db1 <dhcp_stop+0x26>
  803d9a:	83 ec 04             	sub    $0x4,%esp
  803d9d:	68 34 15 81 00       	push   $0x811534
  803da2:	68 2c 04 00 00       	push   $0x42c
  803da7:	68 c2 14 81 00       	push   $0x8114c2
  803dac:	e8 30 a6 00 00       	call   80e3e1 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803db1:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  803db5:	85 db                	test   %ebx,%ebx
  803db7:	74 4e                	je     803e07 <dhcp_stop+0x7c>
    if (dhcp->pcb != NULL) {
  803db9:	8b 43 08             	mov    0x8(%ebx),%eax
  803dbc:	85 c0                	test   %eax,%eax
  803dbe:	74 13                	je     803dd3 <dhcp_stop+0x48>
      udp_remove(dhcp->pcb);
  803dc0:	83 ec 0c             	sub    $0xc,%esp
  803dc3:	50                   	push   %eax
  803dc4:	e8 18 51 00 00       	call   808ee1 <udp_remove>
      dhcp->pcb = NULL;
  803dc9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803dd0:	83 c4 10             	add    $0x10,%esp
    }
    if (dhcp->p != NULL) {
  803dd3:	8b 43 0c             	mov    0xc(%ebx),%eax
  803dd6:	85 c0                	test   %eax,%eax
  803dd8:	74 13                	je     803ded <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  803dda:	83 ec 0c             	sub    $0xc,%esp
  803ddd:	50                   	push   %eax
  803dde:	e8 0c 0a 00 00       	call   8047ef <pbuf_free>
      dhcp->p = NULL;
  803de3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803dea:	83 c4 10             	add    $0x10,%esp
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  803ded:	89 d8                	mov    %ebx,%eax
  803def:	e8 46 f5 ff ff       	call   80333a <dhcp_free_reply>
    mem_free((void *)dhcp);
  803df4:	83 ec 0c             	sub    $0xc,%esp
  803df7:	53                   	push   %ebx
  803df8:	e8 60 01 00 00       	call   803f5d <mem_free>
    netif->dhcp = NULL;
  803dfd:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803e04:	83 c4 10             	add    $0x10,%esp
  }
}
  803e07:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e0a:	5b                   	pop    %ebx
  803e0b:	5e                   	pop    %esi
  803e0c:	5d                   	pop    %ebp
  803e0d:	c3                   	ret    

00803e0e <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  803e0e:	55                   	push   %ebp
  803e0f:	89 e5                	mov    %esp,%ebp
  803e11:	56                   	push   %esi
  803e12:	53                   	push   %ebx
  803e13:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e16:	85 db                	test   %ebx,%ebx
  803e18:	75 17                	jne    803e31 <dhcp_start+0x23>
  803e1a:	83 ec 04             	sub    $0x4,%esp
  803e1d:	68 e2 14 81 00       	push   $0x8114e2
  803e22:	68 38 02 00 00       	push   $0x238
  803e27:	68 c2 14 81 00       	push   $0x8114c2
  803e2c:	e8 b0 a5 00 00       	call   80e3e1 <_panic>
  dhcp = netif->dhcp;
  803e31:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803e34:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  803e38:	85 f6                	test   %esi,%esi
  803e3a:	75 1a                	jne    803e56 <dhcp_start+0x48>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  803e3c:	83 ec 0c             	sub    $0xc,%esp
  803e3f:	6a 58                	push   $0x58
  803e41:	e8 c9 03 00 00       	call   80420f <mem_malloc>
  803e46:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803e48:	83 c4 10             	add    $0x10,%esp
  803e4b:	85 c0                	test   %eax,%eax
  803e4d:	0f 84 98 00 00 00    	je     803eeb <dhcp_start+0xdd>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  803e53:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  803e56:	83 ec 04             	sub    $0x4,%esp
  803e59:	6a 58                	push   $0x58
  803e5b:	6a 00                	push   $0x0
  803e5d:	56                   	push   %esi
  803e5e:	e8 23 ad 00 00       	call   80eb86 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  803e63:	e8 bd 50 00 00       	call   808f25 <udp_new>
  803e68:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803e6b:	83 c4 10             	add    $0x10,%esp
  803e6e:	85 c0                	test   %eax,%eax
  803e70:	75 1a                	jne    803e8c <dhcp_start+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  803e72:	83 ec 0c             	sub    $0xc,%esp
  803e75:	56                   	push   %esi
  803e76:	e8 e2 00 00 00       	call   803f5d <mem_free>
    netif->dhcp = dhcp = NULL;
  803e7b:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803e82:	83 c4 10             	add    $0x10,%esp
  803e85:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e8a:	eb 64                	jmp    803ef0 <dhcp_start+0xe2>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803e8c:	83 ec 04             	sub    $0x4,%esp
  803e8f:	6a 44                	push   $0x44
  803e91:	68 80 1d 81 00       	push   $0x811d80
  803e96:	50                   	push   %eax
  803e97:	e8 f0 4c 00 00       	call   808b8c <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803e9c:	83 c4 0c             	add    $0xc,%esp
  803e9f:	6a 43                	push   $0x43
  803ea1:	68 80 1d 81 00       	push   $0x811d80
  803ea6:	ff 76 08             	pushl  0x8(%esi)
  803ea9:	e8 91 4f 00 00       	call   808e3f <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803eae:	83 c4 0c             	add    $0xc,%esp
  803eb1:	53                   	push   %ebx
  803eb2:	68 82 33 80 00       	push   $0x803382
  803eb7:	ff 76 08             	pushl  0x8(%esi)
  803eba:	e8 0e 50 00 00       	call   808ecd <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  803ebf:	89 d8                	mov    %ebx,%eax
  803ec1:	e8 fa ef ff ff       	call   802ec0 <dhcp_discover>
  if (result != ERR_OK) {
  803ec6:	83 c4 10             	add    $0x10,%esp
  803ec9:	84 c0                	test   %al,%al
  803ecb:	74 13                	je     803ee0 <dhcp_start+0xd2>
    /* free resources allocated above */
    dhcp_stop(netif);
  803ecd:	83 ec 0c             	sub    $0xc,%esp
  803ed0:	53                   	push   %ebx
  803ed1:	e8 b5 fe ff ff       	call   803d8b <dhcp_stop>
    return ERR_MEM;
  803ed6:	83 c4 10             	add    $0x10,%esp
  803ed9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803ede:	eb 10                	jmp    803ef0 <dhcp_start+0xe2>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  803ee0:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  803ee4:	b8 00 00 00 00       	mov    $0x0,%eax
  803ee9:	eb 05                	jmp    803ef0 <dhcp_start+0xe2>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  803eeb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  803ef0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803ef3:	5b                   	pop    %ebx
  803ef4:	5e                   	pop    %esi
  803ef5:	5d                   	pop    %ebp
  803ef6:	c3                   	ret    

00803ef7 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803ef7:	55                   	push   %ebp
  803ef8:	89 e5                	mov    %esp,%ebp
  803efa:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803efd:	b8 c3 53 81 00       	mov    $0x8153c3,%eax
  803f02:	83 e0 fc             	and    $0xfffffffc,%eax
  803f05:	a3 8c 53 81 00       	mov    %eax,0x81538c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803f0a:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803f10:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803f17:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803f1b:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803f21:	89 15 88 53 81 00    	mov    %edx,0x815388
  ram_end->used = 1;
  803f27:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803f2e:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803f35:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803f38:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803f3f:	00 22 00 

  mem_sem = sys_sem_new(1);
  803f42:	6a 01                	push   $0x1
  803f44:	e8 a1 5d 00 00       	call   809cea <sys_sem_new>
  803f49:	a3 80 53 81 00       	mov    %eax,0x815380

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803f4e:	a1 8c 53 81 00       	mov    0x81538c,%eax
  803f53:	a3 84 53 81 00       	mov    %eax,0x815384
  803f58:	83 c4 10             	add    $0x10,%esp

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803f5b:	c9                   	leave  
  803f5c:	c3                   	ret    

00803f5d <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803f5d:	55                   	push   %ebp
  803f5e:	89 e5                	mov    %esp,%ebp
  803f60:	56                   	push   %esi
  803f61:	53                   	push   %ebx
  803f62:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803f65:	85 db                	test   %ebx,%ebx
  803f67:	0f 84 52 01 00 00    	je     8040bf <mem_free+0x162>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803f6d:	f6 c3 03             	test   $0x3,%bl
  803f70:	74 17                	je     803f89 <mem_free+0x2c>
  803f72:	83 ec 04             	sub    $0x4,%esp
  803f75:	68 50 15 81 00       	push   $0x811550
  803f7a:	68 30 01 00 00       	push   $0x130
  803f7f:	68 47 16 81 00       	push   $0x811647
  803f84:	e8 58 a4 00 00       	call   80e3e1 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803f89:	3b 1d 8c 53 81 00    	cmp    0x81538c,%ebx
  803f8f:	72 08                	jb     803f99 <mem_free+0x3c>
  803f91:	3b 1d 88 53 81 00    	cmp    0x815388,%ebx
  803f97:	72 17                	jb     803fb0 <mem_free+0x53>
  803f99:	83 ec 04             	sub    $0x4,%esp
  803f9c:	68 5b 16 81 00       	push   $0x81165b
  803fa1:	68 33 01 00 00       	push   $0x133
  803fa6:	68 47 16 81 00       	push   $0x811647
  803fab:	e8 31 a4 00 00       	call   80e3e1 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803fb0:	83 ec 08             	sub    $0x8,%esp
  803fb3:	6a 00                	push   $0x0
  803fb5:	ff 35 80 53 81 00    	pushl  0x815380
  803fbb:	e8 49 60 00 00       	call   80a009 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803fc0:	83 c4 10             	add    $0x10,%esp
  803fc3:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803fc7:	75 17                	jne    803fe0 <mem_free+0x83>
  803fc9:	83 ec 04             	sub    $0x4,%esp
  803fcc:	68 72 16 81 00       	push   $0x811672
  803fd1:	68 43 01 00 00       	push   $0x143
  803fd6:	68 47 16 81 00       	push   $0x811647
  803fdb:	e8 01 a4 00 00       	call   80e3e1 <_panic>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803fe0:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  803fe3:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803fe7:	3b 15 84 53 81 00    	cmp    0x815384,%edx
  803fed:	73 06                	jae    803ff5 <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  803fef:	89 15 84 53 81 00    	mov    %edx,0x815384
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  803ff5:	8b 0d 8c 53 81 00    	mov    0x81538c,%ecx
  803ffb:	39 ca                	cmp    %ecx,%edx
  803ffd:	73 17                	jae    804016 <mem_free+0xb9>
  803fff:	83 ec 04             	sub    $0x4,%esp
  804002:	68 86 16 81 00       	push   $0x811686
  804007:	68 e3 00 00 00       	push   $0xe3
  80400c:	68 47 16 81 00       	push   $0x811647
  804011:	e8 cb a3 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804016:	8b 35 88 53 81 00    	mov    0x815388,%esi
  80401c:	39 f2                	cmp    %esi,%edx
  80401e:	72 17                	jb     804037 <mem_free+0xda>
  804020:	83 ec 04             	sub    $0x4,%esp
  804023:	68 9d 16 81 00       	push   $0x81169d
  804028:	68 e4 00 00 00       	push   $0xe4
  80402d:	68 47 16 81 00       	push   $0x811647
  804032:	e8 aa a3 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804037:	8b 43 f4             	mov    -0xc(%ebx),%eax
  80403a:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80403f:	76 17                	jbe    804058 <mem_free+0xfb>
  804041:	83 ec 04             	sub    $0x4,%esp
  804044:	68 74 15 81 00       	push   $0x811574
  804049:	68 e8 00 00 00       	push   $0xe8
  80404e:	68 47 16 81 00       	push   $0x811647
  804053:	e8 89 a3 00 00       	call   80e3e1 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  804058:	01 c8                	add    %ecx,%eax
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80405a:	39 c2                	cmp    %eax,%edx
  80405c:	74 27                	je     804085 <mem_free+0x128>
  80405e:	39 c6                	cmp    %eax,%esi
  804060:	74 23                	je     804085 <mem_free+0x128>
  804062:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804066:	75 1d                	jne    804085 <mem_free+0x128>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  804068:	3b 05 84 53 81 00    	cmp    0x815384,%eax
  80406e:	75 06                	jne    804076 <mem_free+0x119>
      lfree = mem;
  804070:	89 15 84 53 81 00    	mov    %edx,0x815384
    }
    mem->next = nmem->next;
  804076:	8b 30                	mov    (%eax),%esi
  804078:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80407b:	8b 00                	mov    (%eax),%eax
  80407d:	89 d6                	mov    %edx,%esi
  80407f:	29 ce                	sub    %ecx,%esi
  804081:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  804085:	8b 73 f8             	mov    -0x8(%ebx),%esi
  804088:	8d 04 31             	lea    (%ecx,%esi,1),%eax
  if (pmem != mem && pmem->used == 0) {
  80408b:	39 c2                	cmp    %eax,%edx
  80408d:	74 1f                	je     8040ae <mem_free+0x151>
  80408f:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804093:	75 19                	jne    8040ae <mem_free+0x151>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  804095:	3b 15 84 53 81 00    	cmp    0x815384,%edx
  80409b:	75 05                	jne    8040a2 <mem_free+0x145>
      lfree = pmem;
  80409d:	a3 84 53 81 00       	mov    %eax,0x815384
    }
    pmem->next = mem->next;
  8040a2:	8b 53 f4             	mov    -0xc(%ebx),%edx
  8040a5:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8040a7:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8040aa:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8040ae:	83 ec 0c             	sub    $0xc,%esp
  8040b1:	ff 35 80 53 81 00    	pushl  0x815380
  8040b7:	e8 df 5e 00 00       	call   809f9b <sys_sem_signal>
  8040bc:	83 c4 10             	add    $0x10,%esp
}
  8040bf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8040c2:	5b                   	pop    %ebx
  8040c3:	5e                   	pop    %esi
  8040c4:	5d                   	pop    %ebp
  8040c5:	c3                   	ret    

008040c6 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8040c6:	55                   	push   %ebp
  8040c7:	89 e5                	mov    %esp,%ebp
  8040c9:	57                   	push   %edi
  8040ca:	56                   	push   %esi
  8040cb:	53                   	push   %ebx
  8040cc:	83 ec 1c             	sub    $0x1c,%esp
  8040cf:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8040d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8040d5:	8d 58 03             	lea    0x3(%eax),%ebx
  8040d8:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8040db:	83 fb 0b             	cmp    $0xb,%ebx
  8040de:	76 0d                	jbe    8040ed <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8040e0:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8040e6:	76 0a                	jbe    8040f2 <mem_realloc+0x2c>
  8040e8:	e9 15 01 00 00       	jmp    804202 <mem_realloc+0x13c>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  8040ed:	bb 0c 00 00 00       	mov    $0xc,%ebx

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8040f2:	a1 8c 53 81 00       	mov    0x81538c,%eax
  8040f7:	39 f0                	cmp    %esi,%eax
  8040f9:	77 08                	ja     804103 <mem_realloc+0x3d>
  8040fb:	3b 35 88 53 81 00    	cmp    0x815388,%esi
  804101:	72 17                	jb     80411a <mem_realloc+0x54>
  804103:	83 ec 04             	sub    $0x4,%esp
  804106:	68 b7 16 81 00       	push   $0x8116b7
  80410b:	68 79 01 00 00       	push   $0x179
  804110:	68 47 16 81 00       	push   $0x811647
  804115:	e8 c7 a2 00 00       	call   80e3e1 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80411a:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80411d:	29 c2                	sub    %eax,%edx
  80411f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  804122:	8b 46 f4             	mov    -0xc(%esi),%eax
  804125:	8d 78 f4             	lea    -0xc(%eax),%edi

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  804128:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80412a:	39 df                	cmp    %ebx,%edi
  80412c:	73 17                	jae    804145 <mem_realloc+0x7f>
  80412e:	83 ec 04             	sub    $0x4,%esp
  804131:	68 a0 15 81 00       	push   $0x8115a0
  804136:	68 8a 01 00 00       	push   $0x18a
  80413b:	68 47 16 81 00       	push   $0x811647
  804140:	e8 9c a2 00 00       	call   80e3e1 <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  804145:	89 f0                	mov    %esi,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804147:	39 fb                	cmp    %edi,%ebx
  804149:	0f 84 b8 00 00 00    	je     804207 <mem_realloc+0x141>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80414f:	83 ec 08             	sub    $0x8,%esp
  804152:	6a 00                	push   $0x0
  804154:	ff 35 80 53 81 00    	pushl  0x815380
  80415a:	e8 aa 5e 00 00       	call   80a009 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80415f:	a1 8c 53 81 00       	mov    0x81538c,%eax
  804164:	89 c2                	mov    %eax,%edx
  804166:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804169:	83 c4 10             	add    $0x10,%esp
  80416c:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804170:	75 3c                	jne    8041ae <mem_realloc+0xe8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804172:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804174:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804177:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  80417b:	39 15 84 53 81 00    	cmp    %edx,0x815384
  804181:	75 09                	jne    80418c <mem_realloc+0xc6>
      lfree = (struct mem *)&ram[ptr2];
  804183:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  804186:	89 15 84 53 81 00    	mov    %edx,0x815384
    }
    mem2 = (struct mem *)&ram[ptr2];
  80418c:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  80418f:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804193:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804195:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804198:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  80419b:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80419e:	8b 12                	mov    (%edx),%edx
  8041a0:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041a6:	74 45                	je     8041ed <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041a8:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  8041ac:	eb 3f                	jmp    8041ed <mem_realloc+0x127>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8041ae:	8d 53 18             	lea    0x18(%ebx),%edx
  8041b1:	39 d7                	cmp    %edx,%edi
  8041b3:	72 38                	jb     8041ed <mem_realloc+0x127>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8041b5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041b8:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8041bc:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8041bf:	3b 15 84 53 81 00    	cmp    0x815384,%edx
  8041c5:	73 06                	jae    8041cd <mem_realloc+0x107>
      lfree = mem2;
  8041c7:	89 15 84 53 81 00    	mov    %edx,0x815384
    }
    mem2->used = 0;
  8041cd:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8041d1:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8041d4:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8041d6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8041d9:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8041dc:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8041df:	8b 12                	mov    (%edx),%edx
  8041e1:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041e7:	74 04                	je     8041ed <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041e9:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8041ed:	83 ec 0c             	sub    $0xc,%esp
  8041f0:	ff 35 80 53 81 00    	pushl  0x815380
  8041f6:	e8 a0 5d 00 00       	call   809f9b <sys_sem_signal>
  return rmem;
  8041fb:	83 c4 10             	add    $0x10,%esp
  8041fe:	89 f0                	mov    %esi,%eax
  804200:	eb 05                	jmp    804207 <mem_realloc+0x141>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  804202:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  804207:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80420a:	5b                   	pop    %ebx
  80420b:	5e                   	pop    %esi
  80420c:	5f                   	pop    %edi
  80420d:	5d                   	pop    %ebp
  80420e:	c3                   	ret    

0080420f <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80420f:	55                   	push   %ebp
  804210:	89 e5                	mov    %esp,%ebp
  804212:	57                   	push   %edi
  804213:	56                   	push   %esi
  804214:	53                   	push   %ebx
  804215:	83 ec 1c             	sub    $0x1c,%esp
  804218:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80421b:	85 f6                	test   %esi,%esi
  80421d:	0f 84 61 01 00 00    	je     804384 <mem_malloc+0x175>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804223:	83 c6 03             	add    $0x3,%esi
  804226:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  804229:	83 fe 0b             	cmp    $0xb,%esi
  80422c:	76 0d                	jbe    80423b <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80422e:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  804234:	76 0a                	jbe    804240 <mem_malloc+0x31>
  804236:	e9 50 01 00 00       	jmp    80438b <mem_malloc+0x17c>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80423b:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804240:	83 ec 08             	sub    $0x8,%esp
  804243:	6a 00                	push   $0x0
  804245:	ff 35 80 53 81 00    	pushl  0x815380
  80424b:	e8 b9 5d 00 00       	call   80a009 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804250:	8b 15 8c 53 81 00    	mov    0x81538c,%edx
  804256:	a1 84 53 81 00       	mov    0x815384,%eax
  80425b:	29 d0                	sub    %edx,%eax
  80425d:	83 c4 10             	add    $0x10,%esp
  804260:	bf 00 00 22 00       	mov    $0x220000,%edi
  804265:	29 f7                	sub    %esi,%edi
  804267:	e9 f8 00 00 00       	jmp    804364 <mem_malloc+0x155>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80426c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80426f:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804273:	0f 85 e9 00 00 00    	jne    804362 <mem_malloc+0x153>
  804279:	8b 0b                	mov    (%ebx),%ecx
  80427b:	83 e9 0c             	sub    $0xc,%ecx
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80427e:	29 c1                	sub    %eax,%ecx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804280:	39 f1                	cmp    %esi,%ecx
  804282:	0f 82 da 00 00 00    	jb     804362 <mem_malloc+0x153>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804288:	8d 7e 18             	lea    0x18(%esi),%edi
  80428b:	39 f9                	cmp    %edi,%ecx
  80428d:	72 2d                	jb     8042bc <mem_malloc+0xad>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80428f:	8d 7c 30 0c          	lea    0xc(%eax,%esi,1),%edi
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  804293:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804296:	8d 0c 3a             	lea    (%edx,%edi,1),%ecx
          mem2->used = 0;
  804299:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  80429d:	8b 3b                	mov    (%ebx),%edi
  80429f:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  8042a1:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  8042a4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8042a7:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  8042a9:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8042ad:	8b 01                	mov    (%ecx),%eax
  8042af:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8042b4:	74 0a                	je     8042c0 <mem_malloc+0xb1>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8042b6:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  8042ba:	eb 04                	jmp    8042c0 <mem_malloc+0xb1>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8042bc:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8042c0:	3b 1d 84 53 81 00    	cmp    0x815384,%ebx
  8042c6:	75 2c                	jne    8042f4 <mem_malloc+0xe5>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8042c8:	8b 15 88 53 81 00    	mov    0x815388,%edx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8042ce:	8b 0d 8c 53 81 00    	mov    0x81538c,%ecx
  8042d4:	89 d8                	mov    %ebx,%eax
  8042d6:	eb 06                	jmp    8042de <mem_malloc+0xcf>
  8042d8:	89 cf                	mov    %ecx,%edi
  8042da:	03 38                	add    (%eax),%edi
  8042dc:	89 f8                	mov    %edi,%eax
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8042de:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  8042e2:	75 07                	jne    8042eb <mem_malloc+0xdc>
  8042e4:	a3 84 53 81 00       	mov    %eax,0x815384
  8042e9:	eb 09                	jmp    8042f4 <mem_malloc+0xe5>
  8042eb:	39 c2                	cmp    %eax,%edx
  8042ed:	75 e9                	jne    8042d8 <mem_malloc+0xc9>
  8042ef:	a3 84 53 81 00       	mov    %eax,0x815384
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  8042f4:	83 ec 0c             	sub    $0xc,%esp
  8042f7:	ff 35 80 53 81 00    	pushl  0x815380
  8042fd:	e8 99 5c 00 00       	call   809f9b <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804302:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  804306:	83 c4 10             	add    $0x10,%esp
  804309:	39 05 88 53 81 00    	cmp    %eax,0x815388
  80430f:	73 17                	jae    804328 <mem_malloc+0x119>
  804311:	83 ec 04             	sub    $0x4,%esp
  804314:	68 c4 15 81 00       	push   $0x8115c4
  804319:	68 4b 02 00 00       	push   $0x24b
  80431e:	68 47 16 81 00       	push   $0x811647
  804323:	e8 b9 a0 00 00       	call   80e3e1 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804328:	8d 43 0c             	lea    0xc(%ebx),%eax
  80432b:	a8 03                	test   $0x3,%al
  80432d:	74 17                	je     804346 <mem_malloc+0x137>
  80432f:	83 ec 04             	sub    $0x4,%esp
  804332:	68 f4 15 81 00       	push   $0x8115f4
  804337:	68 4d 02 00 00       	push   $0x24d
  80433c:	68 47 16 81 00       	push   $0x811647
  804341:	e8 9b a0 00 00       	call   80e3e1 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804346:	f6 c3 03             	test   $0x3,%bl
  804349:	74 45                	je     804390 <mem_malloc+0x181>
  80434b:	83 ec 04             	sub    $0x4,%esp
  80434e:	68 24 16 81 00       	push   $0x811624
  804353:	68 4f 02 00 00       	push   $0x24f
  804358:	68 47 16 81 00       	push   $0x811647
  80435d:	e8 7f a0 00 00       	call   80e3e1 <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  804362:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804364:	39 f8                	cmp    %edi,%eax
  804366:	0f 82 00 ff ff ff    	jb     80426c <mem_malloc+0x5d>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80436c:	83 ec 0c             	sub    $0xc,%esp
  80436f:	ff 35 80 53 81 00    	pushl  0x815380
  804375:	e8 21 5c 00 00       	call   809f9b <sys_sem_signal>
  return NULL;
  80437a:	83 c4 10             	add    $0x10,%esp
  80437d:	b8 00 00 00 00       	mov    $0x0,%eax
  804382:	eb 0c                	jmp    804390 <mem_malloc+0x181>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  804384:	b8 00 00 00 00       	mov    $0x0,%eax
  804389:	eb 05                	jmp    804390 <mem_malloc+0x181>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  80438b:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  804390:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804393:	5b                   	pop    %ebx
  804394:	5e                   	pop    %esi
  804395:	5f                   	pop    %edi
  804396:	5d                   	pop    %ebp
  804397:	c3                   	ret    

00804398 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  804398:	55                   	push   %ebp
  804399:	89 e5                	mov    %esp,%ebp
  80439b:	56                   	push   %esi
  80439c:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80439d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8043a0:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8043a4:	83 ec 0c             	sub    $0xc,%esp
  8043a7:	53                   	push   %ebx
  8043a8:	e8 62 fe ff ff       	call   80420f <mem_malloc>
  8043ad:	89 c6                	mov    %eax,%esi
  if (p) {
  8043af:	83 c4 10             	add    $0x10,%esp
  8043b2:	85 c0                	test   %eax,%eax
  8043b4:	74 0f                	je     8043c5 <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8043b6:	83 ec 04             	sub    $0x4,%esp
  8043b9:	53                   	push   %ebx
  8043ba:	6a 00                	push   $0x0
  8043bc:	50                   	push   %eax
  8043bd:	e8 c4 a7 00 00       	call   80eb86 <memset>
  8043c2:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8043c5:	89 f0                	mov    %esi,%eax
  8043c7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8043ca:	5b                   	pop    %ebx
  8043cb:	5e                   	pop    %esi
  8043cc:	5d                   	pop    %ebp
  8043cd:	c3                   	ret    

008043ce <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8043ce:	55                   	push   %ebp
  8043cf:	89 e5                	mov    %esp,%ebp
  8043d1:	56                   	push   %esi
  8043d2:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8043d3:	b8 03 54 a3 00       	mov    $0xa35403,%eax
  8043d8:	83 e0 fc             	and    $0xfffffffc,%eax
  8043db:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  8043e0:	c7 84 12 80 44 b3 00 	movl   $0x0,0xb34480(%edx,%edx,1)
  8043e7:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8043eb:	0f b7 b2 48 17 81 00 	movzwl 0x811748(%edx),%esi
  8043f2:	b9 00 00 00 00       	mov    $0x0,%ecx
  8043f7:	eb 1c                	jmp    804415 <memp_init+0x47>
      memp->next = memp_tab[i];
  8043f9:	8b 9c 12 80 44 b3 00 	mov    0xb34480(%edx,%edx,1),%ebx
  804400:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804402:	89 84 12 80 44 b3 00 	mov    %eax,0xb34480(%edx,%edx,1)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804409:	0f b7 9a 64 17 81 00 	movzwl 0x811764(%edx),%ebx
  804410:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804412:	83 c1 01             	add    $0x1,%ecx
  804415:	66 39 f1             	cmp    %si,%cx
  804418:	75 df                	jne    8043f9 <memp_init+0x2b>
  80441a:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80441d:	83 fa 1c             	cmp    $0x1c,%edx
  804420:	75 be                	jne    8043e0 <memp_init+0x12>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804422:	5b                   	pop    %ebx
  804423:	5e                   	pop    %esi
  804424:	5d                   	pop    %ebp
  804425:	c3                   	ret    

00804426 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804426:	55                   	push   %ebp
  804427:	89 e5                	mov    %esp,%ebp
  804429:	83 ec 08             	sub    $0x8,%esp
  80442c:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80442f:	83 fa 0d             	cmp    $0xd,%edx
  804432:	76 17                	jbe    80444b <memp_malloc+0x25>
  804434:	83 ec 04             	sub    $0x4,%esp
  804437:	68 d1 16 81 00       	push   $0x8116d1
  80443c:	68 2d 01 00 00       	push   $0x12d
  804441:	68 ee 16 81 00       	push   $0x8116ee
  804446:	e8 96 9f 00 00       	call   80e3e1 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80444b:	8b 04 95 80 44 b3 00 	mov    0xb34480(,%edx,4),%eax
  
  if (memp != NULL) {    
  804452:	85 c0                	test   %eax,%eax
  804454:	74 24                	je     80447a <memp_malloc+0x54>
    memp_tab[type] = memp->next;    
  804456:	8b 08                	mov    (%eax),%ecx
  804458:	89 0c 95 80 44 b3 00 	mov    %ecx,0xb34480(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80445f:	a8 03                	test   $0x3,%al
  804461:	74 17                	je     80447a <memp_malloc+0x54>
  804463:	83 ec 04             	sub    $0x4,%esp
  804466:	68 04 17 81 00       	push   $0x811704
  80446b:	68 3f 01 00 00       	push   $0x13f
  804470:	68 ee 16 81 00       	push   $0x8116ee
  804475:	e8 67 9f 00 00       	call   80e3e1 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  80447a:	c9                   	leave  
  80447b:	c3                   	ret    

0080447c <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80447c:	55                   	push   %ebp
  80447d:	89 e5                	mov    %esp,%ebp
  80447f:	83 ec 08             	sub    $0x8,%esp
  804482:	8b 55 08             	mov    0x8(%ebp),%edx
  804485:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804488:	85 c0                	test   %eax,%eax
  80448a:	74 2b                	je     8044b7 <memp_free+0x3b>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80448c:	a8 03                	test   $0x3,%al
  80448e:	74 17                	je     8044a7 <memp_free+0x2b>
  804490:	83 ec 04             	sub    $0x4,%esp
  804493:	68 28 17 81 00       	push   $0x811728
  804498:	68 5b 01 00 00       	push   $0x15b
  80449d:	68 ee 16 81 00       	push   $0x8116ee
  8044a2:	e8 3a 9f 00 00       	call   80e3e1 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8044a7:	8b 0c 95 80 44 b3 00 	mov    0xb34480(,%edx,4),%ecx
  8044ae:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8044b0:	89 04 95 80 44 b3 00 	mov    %eax,0xb34480(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8044b7:	c9                   	leave  
  8044b8:	c3                   	ret    

008044b9 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8044b9:	55                   	push   %ebp
  8044ba:	89 e5                	mov    %esp,%ebp
  8044bc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8044bf:	85 c9                	test   %ecx,%ecx
  8044c1:	74 38                	je     8044fb <netif_remove+0x42>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8044c3:	a1 74 b3 b3 00       	mov    0xb3b374,%eax
  8044c8:	39 c8                	cmp    %ecx,%eax
  8044ca:	75 17                	jne    8044e3 <netif_remove+0x2a>
    netif_list = netif->next;
  8044cc:	8b 00                	mov    (%eax),%eax
  8044ce:	a3 74 b3 b3 00       	mov    %eax,0xb3b374
  8044d3:	eb 14                	jmp    8044e9 <netif_remove+0x30>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  8044d5:	8b 10                	mov    (%eax),%edx
  8044d7:	39 ca                	cmp    %ecx,%edx
  8044d9:	75 06                	jne    8044e1 <netif_remove+0x28>
        tmpNetif->next = netif->next;
  8044db:	8b 11                	mov    (%ecx),%edx
  8044dd:	89 10                	mov    %edx,(%eax)
  8044df:	eb 08                	jmp    8044e9 <netif_remove+0x30>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8044e1:	89 d0                	mov    %edx,%eax
  8044e3:	85 c0                	test   %eax,%eax
  8044e5:	75 ee                	jne    8044d5 <netif_remove+0x1c>
  8044e7:	eb 12                	jmp    8044fb <netif_remove+0x42>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  8044e9:	39 0d 78 b3 b3 00    	cmp    %ecx,0xb3b378
  8044ef:	75 0a                	jne    8044fb <netif_remove+0x42>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  8044f1:	c7 05 78 b3 b3 00 00 	movl   $0x0,0xb3b378
  8044f8:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  8044fb:	5d                   	pop    %ebp
  8044fc:	c3                   	ret    

008044fd <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  8044fd:	55                   	push   %ebp
  8044fe:	89 e5                	mov    %esp,%ebp
  804500:	53                   	push   %ebx
  804501:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804504:	85 c9                	test   %ecx,%ecx
  804506:	74 2c                	je     804534 <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  804508:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  80450c:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80450f:	a1 74 b3 b3 00       	mov    0xb3b374,%eax
  804514:	eb 18                	jmp    80452e <netif_find+0x31>
    if (num == netif->num &&
  804516:	38 50 31             	cmp    %dl,0x31(%eax)
  804519:	75 11                	jne    80452c <netif_find+0x2f>
  80451b:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  80451f:	38 19                	cmp    %bl,(%ecx)
  804521:	75 09                	jne    80452c <netif_find+0x2f>
       name[0] == netif->name[0] &&
  804523:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804527:	38 59 01             	cmp    %bl,0x1(%ecx)
  80452a:	74 0d                	je     804539 <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80452c:	8b 00                	mov    (%eax),%eax
  80452e:	85 c0                	test   %eax,%eax
  804530:	75 e4                	jne    804516 <netif_find+0x19>
  804532:	eb 05                	jmp    804539 <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  804534:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804539:	5b                   	pop    %ebx
  80453a:	5d                   	pop    %ebp
  80453b:	c3                   	ret    

0080453c <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80453c:	55                   	push   %ebp
  80453d:	89 e5                	mov    %esp,%ebp
  80453f:	57                   	push   %edi
  804540:	56                   	push   %esi
  804541:	53                   	push   %ebx
  804542:	83 ec 0c             	sub    $0xc,%esp
  804545:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804548:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80454b:	8b 43 04             	mov    0x4(%ebx),%eax
  80454e:	39 06                	cmp    %eax,(%esi)
  804550:	74 54                	je     8045a6 <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804552:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
    while (pcb != NULL) {
  804557:	eb 1d                	jmp    804576 <netif_set_ipaddr+0x3a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804559:	8b 4b 04             	mov    0x4(%ebx),%ecx
  80455c:	39 08                	cmp    %ecx,(%eax)
  80455e:	75 13                	jne    804573 <netif_set_ipaddr+0x37>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804560:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804563:	83 ec 0c             	sub    $0xc,%esp
  804566:	50                   	push   %eax
  804567:	e8 fc 15 00 00       	call   805b68 <tcp_abort>
  80456c:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  80456f:	89 f8                	mov    %edi,%eax
  804571:	eb 03                	jmp    804576 <netif_set_ipaddr+0x3a>
      } else {
        pcb = pcb->next;
  804573:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  804576:	85 c0                	test   %eax,%eax
  804578:	75 df                	jne    804559 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80457a:	a1 84 b3 b3 00       	mov    0xb3b384,%eax
  80457f:	eb 21                	jmp    8045a2 <netif_set_ipaddr+0x66>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804581:	85 c0                	test   %eax,%eax
  804583:	74 1a                	je     80459f <netif_set_ipaddr+0x63>
  804585:	8b 10                	mov    (%eax),%edx
  804587:	85 d2                	test   %edx,%edx
  804589:	74 14                	je     80459f <netif_set_ipaddr+0x63>
  80458b:	3b 53 04             	cmp    0x4(%ebx),%edx
  80458e:	75 0f                	jne    80459f <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804590:	85 f6                	test   %esi,%esi
  804592:	74 04                	je     804598 <netif_set_ipaddr+0x5c>
  804594:	8b 16                	mov    (%esi),%edx
  804596:	eb 05                	jmp    80459d <netif_set_ipaddr+0x61>
  804598:	ba 00 00 00 00       	mov    $0x0,%edx
  80459d:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80459f:	8b 40 0c             	mov    0xc(%eax),%eax
  8045a2:	85 c0                	test   %eax,%eax
  8045a4:	75 db                	jne    804581 <netif_set_ipaddr+0x45>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8045a6:	85 f6                	test   %esi,%esi
  8045a8:	74 04                	je     8045ae <netif_set_ipaddr+0x72>
  8045aa:	8b 06                	mov    (%esi),%eax
  8045ac:	eb 05                	jmp    8045b3 <netif_set_ipaddr+0x77>
  8045ae:	b8 00 00 00 00       	mov    $0x0,%eax
  8045b3:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  8045b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045b9:	5b                   	pop    %ebx
  8045ba:	5e                   	pop    %esi
  8045bb:	5f                   	pop    %edi
  8045bc:	5d                   	pop    %ebp
  8045bd:	c3                   	ret    

008045be <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  8045be:	55                   	push   %ebp
  8045bf:	89 e5                	mov    %esp,%ebp
  8045c1:	57                   	push   %edi
  8045c2:	56                   	push   %esi
  8045c3:	53                   	push   %ebx
  8045c4:	83 ec 14             	sub    $0x14,%esp
  8045c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8045ca:	8b 7d 10             	mov    0x10(%ebp),%edi
  8045cd:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8045d0:	ff 75 0c             	pushl  0xc(%ebp)
  8045d3:	53                   	push   %ebx
  8045d4:	e8 63 ff ff ff       	call   80453c <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8045d9:	83 c4 10             	add    $0x10,%esp
  8045dc:	85 ff                	test   %edi,%edi
  8045de:	74 04                	je     8045e4 <netif_set_addr+0x26>
  8045e0:	8b 07                	mov    (%edi),%eax
  8045e2:	eb 05                	jmp    8045e9 <netif_set_addr+0x2b>
  8045e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8045e9:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  8045ec:	85 f6                	test   %esi,%esi
  8045ee:	74 04                	je     8045f4 <netif_set_addr+0x36>
  8045f0:	8b 06                	mov    (%esi),%eax
  8045f2:	eb 05                	jmp    8045f9 <netif_set_addr+0x3b>
  8045f4:	b8 00 00 00 00       	mov    $0x0,%eax
  8045f9:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  8045fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045ff:	5b                   	pop    %ebx
  804600:	5e                   	pop    %esi
  804601:	5f                   	pop    %edi
  804602:	5d                   	pop    %ebp
  804603:	c3                   	ret    

00804604 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804604:	55                   	push   %ebp
  804605:	89 e5                	mov    %esp,%ebp
  804607:	53                   	push   %ebx
  804608:	83 ec 04             	sub    $0x4,%esp
  80460b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80460e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804615:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  80461c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804623:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804627:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80462e:	8b 45 18             	mov    0x18(%ebp),%eax
  804631:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804634:	0f b6 05 b8 44 b3 00 	movzbl 0xb344b8,%eax
  80463b:	8d 50 01             	lea    0x1(%eax),%edx
  80463e:	88 15 b8 44 b3 00    	mov    %dl,0xb344b8
  804644:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804647:	8b 45 20             	mov    0x20(%ebp),%eax
  80464a:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80464d:	ff 75 14             	pushl  0x14(%ebp)
  804650:	ff 75 10             	pushl  0x10(%ebp)
  804653:	ff 75 0c             	pushl  0xc(%ebp)
  804656:	53                   	push   %ebx
  804657:	e8 62 ff ff ff       	call   8045be <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80465c:	89 1c 24             	mov    %ebx,(%esp)
  80465f:	ff 55 1c             	call   *0x1c(%ebp)
  804662:	83 c4 10             	add    $0x10,%esp
  804665:	84 c0                	test   %al,%al
  804667:	75 11                	jne    80467a <netif_add+0x76>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  804669:	a1 74 b3 b3 00       	mov    0xb3b374,%eax
  80466e:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804670:	89 1d 74 b3 b3 00    	mov    %ebx,0xb3b374
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  804676:	89 d8                	mov    %ebx,%eax
  804678:	eb 05                	jmp    80467f <netif_add+0x7b>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  80467a:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  80467f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804682:	c9                   	leave  
  804683:	c3                   	ret    

00804684 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  804684:	55                   	push   %ebp
  804685:	89 e5                	mov    %esp,%ebp
  804687:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  80468a:	85 c0                	test   %eax,%eax
  80468c:	74 04                	je     804692 <netif_set_gw+0xe>
  80468e:	8b 10                	mov    (%eax),%edx
  804690:	eb 05                	jmp    804697 <netif_set_gw+0x13>
  804692:	ba 00 00 00 00       	mov    $0x0,%edx
  804697:	8b 45 08             	mov    0x8(%ebp),%eax
  80469a:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80469d:	5d                   	pop    %ebp
  80469e:	c3                   	ret    

0080469f <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80469f:	55                   	push   %ebp
  8046a0:	89 e5                	mov    %esp,%ebp
  8046a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8046a5:	85 c0                	test   %eax,%eax
  8046a7:	74 04                	je     8046ad <netif_set_netmask+0xe>
  8046a9:	8b 10                	mov    (%eax),%edx
  8046ab:	eb 05                	jmp    8046b2 <netif_set_netmask+0x13>
  8046ad:	ba 00 00 00 00       	mov    $0x0,%edx
  8046b2:	8b 45 08             	mov    0x8(%ebp),%eax
  8046b5:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  8046b8:	5d                   	pop    %ebp
  8046b9:	c3                   	ret    

008046ba <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  8046ba:	55                   	push   %ebp
  8046bb:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  8046bd:	8b 45 08             	mov    0x8(%ebp),%eax
  8046c0:	a3 78 b3 b3 00       	mov    %eax,0xb3b378
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8046c5:	5d                   	pop    %ebp
  8046c6:	c3                   	ret    

008046c7 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8046c7:	55                   	push   %ebp
  8046c8:	89 e5                	mov    %esp,%ebp
  8046ca:	83 ec 08             	sub    $0x8,%esp
  8046cd:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8046d0:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8046d4:	a8 01                	test   $0x1,%al
  8046d6:	75 1e                	jne    8046f6 <netif_set_up+0x2f>
    netif->flags |= NETIF_FLAG_UP;
  8046d8:	89 c1                	mov    %eax,%ecx
  8046da:	83 c9 01             	or     $0x1,%ecx
  8046dd:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8046e0:	a8 20                	test   $0x20,%al
  8046e2:	74 12                	je     8046f6 <netif_set_up+0x2f>
      etharp_query(netif, &(netif->ip_addr), NULL);
  8046e4:	83 ec 04             	sub    $0x4,%esp
  8046e7:	6a 00                	push   $0x0
  8046e9:	8d 42 04             	lea    0x4(%edx),%eax
  8046ec:	50                   	push   %eax
  8046ed:	52                   	push   %edx
  8046ee:	e8 1b 51 00 00       	call   80980e <etharp_query>
  8046f3:	83 c4 10             	add    $0x10,%esp
    }
#endif /* LWIP_ARP */
    
  }
}
  8046f6:	c9                   	leave  
  8046f7:	c3                   	ret    

008046f8 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  8046f8:	55                   	push   %ebp
  8046f9:	89 e5                	mov    %esp,%ebp
  8046fb:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  8046fe:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804702:	a8 01                	test   $0x1,%al
  804704:	74 06                	je     80470c <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804706:	83 e0 fe             	and    $0xfffffffe,%eax
  804709:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80470c:	5d                   	pop    %ebp
  80470d:	c3                   	ret    

0080470e <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80470e:	55                   	push   %ebp
  80470f:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804711:	8b 45 08             	mov    0x8(%ebp),%eax
  804714:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804718:	83 e0 01             	and    $0x1,%eax
}
  80471b:	5d                   	pop    %ebp
  80471c:	c3                   	ret    

0080471d <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80471d:	55                   	push   %ebp
  80471e:	89 e5                	mov    %esp,%ebp
  804720:	56                   	push   %esi
  804721:	53                   	push   %ebx
  804722:	8b 55 08             	mov    0x8(%ebp),%edx
  804725:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804728:	85 d2                	test   %edx,%edx
  80472a:	75 17                	jne    804743 <pbuf_header+0x26>
  80472c:	83 ec 04             	sub    $0x4,%esp
  80472f:	68 44 18 81 00       	push   $0x811844
  804734:	68 64 01 00 00       	push   $0x164
  804739:	68 80 17 81 00       	push   $0x811780
  80473e:	e8 9e 9c 00 00       	call   80e3e1 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804743:	66 85 c9             	test   %cx,%cx
  804746:	0f 84 97 00 00 00    	je     8047e3 <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80474c:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  80474e:	66 85 c9             	test   %cx,%cx
  804751:	79 1f                	jns    804772 <pbuf_header+0x55>
    increment_magnitude = -header_size_increment;
  804753:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804755:	66 3b 72 0a          	cmp    0xa(%edx),%si
  804759:	76 17                	jbe    804772 <pbuf_header+0x55>
  80475b:	83 ec 04             	sub    $0x4,%esp
  80475e:	68 95 17 81 00       	push   $0x811795
  804763:	68 6b 01 00 00       	push   $0x16b
  804768:	68 80 17 81 00       	push   $0x811780
  80476d:	e8 6f 9c 00 00       	call   80e3e1 <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804772:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804776:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804779:	66 83 f8 03          	cmp    $0x3,%ax
  80477d:	74 05                	je     804784 <pbuf_header+0x67>
  80477f:	66 85 c0             	test   %ax,%ax
  804782:	75 13                	jne    804797 <pbuf_header+0x7a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804784:	0f bf c1             	movswl %cx,%eax
  804787:	29 c3                	sub    %eax,%ebx
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804789:	8d 72 10             	lea    0x10(%edx),%esi
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  80478c:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804791:	39 f3                	cmp    %esi,%ebx
  804793:	73 3c                	jae    8047d1 <pbuf_header+0xb4>
  804795:	eb 51                	jmp    8047e8 <pbuf_header+0xcb>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804797:	83 e8 01             	sub    $0x1,%eax
  80479a:	66 83 f8 01          	cmp    $0x1,%ax
  80479e:	77 1a                	ja     8047ba <pbuf_header+0x9d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8047a0:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8047a5:	66 85 c9             	test   %cx,%cx
  8047a8:	79 3e                	jns    8047e8 <pbuf_header+0xcb>
  8047aa:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8047ae:	77 38                	ja     8047e8 <pbuf_header+0xcb>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8047b0:	0f bf c1             	movswl %cx,%eax
  8047b3:	29 c3                	sub    %eax,%ebx
  8047b5:	89 5a 04             	mov    %ebx,0x4(%edx)
  8047b8:	eb 1a                	jmp    8047d4 <pbuf_header+0xb7>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8047ba:	83 ec 04             	sub    $0x4,%esp
  8047bd:	68 b3 17 81 00       	push   $0x8117b3
  8047c2:	68 9a 01 00 00       	push   $0x19a
  8047c7:	68 80 17 81 00       	push   $0x811780
  8047cc:	e8 10 9c 00 00       	call   80e3e1 <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  8047d1:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8047d4:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8047d8:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8047dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8047e1:	eb 05                	jmp    8047e8 <pbuf_header+0xcb>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  8047e3:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  8047e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8047eb:	5b                   	pop    %ebx
  8047ec:	5e                   	pop    %esi
  8047ed:	5d                   	pop    %ebp
  8047ee:	c3                   	ret    

008047ef <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  8047ef:	55                   	push   %ebp
  8047f0:	89 e5                	mov    %esp,%ebp
  8047f2:	56                   	push   %esi
  8047f3:	53                   	push   %ebx
  8047f4:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  8047f7:	85 c0                	test   %eax,%eax
  8047f9:	75 17                	jne    804812 <pbuf_free+0x23>
    LWIP_ASSERT("p != NULL", p != NULL);
  8047fb:	83 ec 04             	sub    $0x4,%esp
  8047fe:	68 44 18 81 00       	push   $0x811844
  804803:	68 d0 01 00 00       	push   $0x1d0
  804808:	68 80 17 81 00       	push   $0x811780
  80480d:	e8 cf 9b 00 00       	call   80e3e1 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804812:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  804816:	76 17                	jbe    80482f <pbuf_free+0x40>
  804818:	83 ec 04             	sub    $0x4,%esp
  80481b:	68 c1 17 81 00       	push   $0x8117c1
  804820:	68 db 01 00 00       	push   $0x1db
  804825:	68 80 17 81 00       	push   $0x811780
  80482a:	e8 b2 9b 00 00       	call   80e3e1 <_panic>
  80482f:	bb 00 00 00 00       	mov    $0x0,%ebx
  804834:	eb 02                	jmp    804838 <pbuf_free+0x49>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  804836:	89 f0                	mov    %esi,%eax
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804838:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  80483c:	66 85 d2             	test   %dx,%dx
  80483f:	75 17                	jne    804858 <pbuf_free+0x69>
  804841:	83 ec 04             	sub    $0x4,%esp
  804844:	68 d6 17 81 00       	push   $0x8117d6
  804849:	68 e8 01 00 00       	push   $0x1e8
  80484e:	68 80 17 81 00       	push   $0x811780
  804853:	e8 89 9b 00 00       	call   80e3e1 <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  804858:	83 ea 01             	sub    $0x1,%edx
  80485b:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80485f:	66 85 d2             	test   %dx,%dx
  804862:	75 48                	jne    8048ac <pbuf_free+0xbd>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  804864:	8b 30                	mov    (%eax),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  804866:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80486a:	66 83 fa 03          	cmp    $0x3,%dx
  80486e:	75 10                	jne    804880 <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  804870:	83 ec 08             	sub    $0x8,%esp
  804873:	50                   	push   %eax
  804874:	6a 0d                	push   $0xd
  804876:	e8 01 fc ff ff       	call   80447c <memp_free>
  80487b:	83 c4 10             	add    $0x10,%esp
  80487e:	eb 25                	jmp    8048a5 <pbuf_free+0xb6>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804880:	83 ea 01             	sub    $0x1,%edx
  804883:	66 83 fa 01          	cmp    $0x1,%dx
  804887:	77 10                	ja     804899 <pbuf_free+0xaa>
        memp_free(MEMP_PBUF, p);
  804889:	83 ec 08             	sub    $0x8,%esp
  80488c:	50                   	push   %eax
  80488d:	6a 0c                	push   $0xc
  80488f:	e8 e8 fb ff ff       	call   80447c <memp_free>
  804894:	83 c4 10             	add    $0x10,%esp
  804897:	eb 0c                	jmp    8048a5 <pbuf_free+0xb6>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  804899:	83 ec 0c             	sub    $0xc,%esp
  80489c:	50                   	push   %eax
  80489d:	e8 bb f6 ff ff       	call   803f5d <mem_free>
  8048a2:	83 c4 10             	add    $0x10,%esp
      }
      count++;
  8048a5:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  8048a8:	85 f6                	test   %esi,%esi
  8048aa:	75 8a                	jne    804836 <pbuf_free+0x47>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8048ac:	89 d8                	mov    %ebx,%eax
  8048ae:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8048b1:	5b                   	pop    %ebx
  8048b2:	5e                   	pop    %esi
  8048b3:	5d                   	pop    %ebp
  8048b4:	c3                   	ret    

008048b5 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  8048b5:	55                   	push   %ebp
  8048b6:	89 e5                	mov    %esp,%ebp
  8048b8:	57                   	push   %edi
  8048b9:	56                   	push   %esi
  8048ba:	53                   	push   %ebx
  8048bb:	83 ec 1c             	sub    $0x1c,%esp
  8048be:	8b 45 08             	mov    0x8(%ebp),%eax
  8048c1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  8048c4:	83 f8 01             	cmp    $0x1,%eax
  8048c7:	74 18                	je     8048e1 <pbuf_alloc+0x2c>
  8048c9:	83 f8 01             	cmp    $0x1,%eax
  8048cc:	72 0c                	jb     8048da <pbuf_alloc+0x25>
  8048ce:	83 f8 02             	cmp    $0x2,%eax
  8048d1:	74 18                	je     8048eb <pbuf_alloc+0x36>
  8048d3:	83 f8 03             	cmp    $0x3,%eax
  8048d6:	74 34                	je     80490c <pbuf_alloc+0x57>
  8048d8:	eb 1b                	jmp    8048f5 <pbuf_alloc+0x40>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  8048da:	bf 14 00 00 00       	mov    $0x14,%edi
  8048df:	eb 05                	jmp    8048e6 <pbuf_alloc+0x31>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  8048e1:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  8048e6:	83 c7 14             	add    $0x14,%edi
  8048e9:	eb 05                	jmp    8048f0 <pbuf_alloc+0x3b>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  8048eb:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  8048f0:	83 c7 0e             	add    $0xe,%edi
    break;
  8048f3:	eb 1c                	jmp    804911 <pbuf_alloc+0x5c>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  8048f5:	83 ec 04             	sub    $0x4,%esp
  8048f8:	68 ec 17 81 00       	push   $0x8117ec
  8048fd:	68 8a 00 00 00       	push   $0x8a
  804902:	68 80 17 81 00       	push   $0x811780
  804907:	e8 d5 9a 00 00       	call   80e3e1 <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80490c:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804911:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804915:	77 0f                	ja     804926 <pbuf_alloc+0x71>
  804917:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  80491b:	0f 82 5c 01 00 00    	jb     804a7d <pbuf_alloc+0x1c8>
  804921:	e9 9d 01 00 00       	jmp    804ac3 <pbuf_alloc+0x20e>
  804926:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  80492a:	0f 85 c4 01 00 00    	jne    804af4 <pbuf_alloc+0x23f>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804930:	83 ec 0c             	sub    $0xc,%esp
  804933:	6a 0d                	push   $0xd
  804935:	e8 ec fa ff ff       	call   804426 <memp_malloc>
  80493a:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80493c:	83 c4 10             	add    $0x10,%esp
  80493f:	85 c0                	test   %eax,%eax
  804941:	0f 84 d2 01 00 00    	je     804b19 <pbuf_alloc+0x264>
      return NULL;
    }
    p->type = type;
  804947:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  80494b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804951:	0f b7 ff             	movzwl %di,%edi
  804954:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  804958:	83 e2 fc             	and    $0xfffffffc,%edx
  80495b:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80495e:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804962:	0f b7 db             	movzwl %bx,%ebx
  804965:	83 c7 03             	add    $0x3,%edi
  804968:	83 e7 fc             	and    $0xfffffffc,%edi
  80496b:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804970:	29 f8                	sub    %edi,%eax
  804972:	39 d8                	cmp    %ebx,%eax
  804974:	0f 4f c3             	cmovg  %ebx,%eax
  804977:	66 89 46 0a          	mov    %ax,0xa(%esi)
  80497b:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80497e:	8d be e0 07 00 00    	lea    0x7e0(%esi),%edi
  804984:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804987:	01 c2                	add    %eax,%edx
  804989:	39 d7                	cmp    %edx,%edi
  80498b:	73 17                	jae    8049a4 <pbuf_alloc+0xef>
  80498d:	83 ec 04             	sub    $0x4,%esp
  804990:	68 04 19 81 00       	push   $0x811904
  804995:	68 a3 00 00 00       	push   $0xa3
  80499a:	68 80 17 81 00       	push   $0x811780
  80499f:	e8 3d 9a 00 00       	call   80e3e1 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  8049a4:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  8049aa:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  8049ac:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8049ae:	e9 bd 00 00 00       	jmp    804a70 <pbuf_alloc+0x1bb>
      q = memp_malloc(MEMP_PBUF_POOL);
  8049b3:	83 ec 0c             	sub    $0xc,%esp
  8049b6:	6a 0d                	push   $0xd
  8049b8:	e8 69 fa ff ff       	call   804426 <memp_malloc>
      if (q == NULL) {
  8049bd:	83 c4 10             	add    $0x10,%esp
  8049c0:	85 c0                	test   %eax,%eax
  8049c2:	75 16                	jne    8049da <pbuf_alloc+0x125>
        /* free chain so far allocated */
        pbuf_free(p);
  8049c4:	83 ec 0c             	sub    $0xc,%esp
  8049c7:	56                   	push   %esi
  8049c8:	e8 22 fe ff ff       	call   8047ef <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  8049cd:	83 c4 10             	add    $0x10,%esp
  8049d0:	b8 00 00 00 00       	mov    $0x0,%eax
  8049d5:	e9 52 01 00 00       	jmp    804b2c <pbuf_alloc+0x277>
      }
      q->type = type;
  8049da:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  8049de:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  8049e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  8049e8:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  8049ea:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  8049f0:	7e 17                	jle    804a09 <pbuf_alloc+0x154>
  8049f2:	83 ec 04             	sub    $0x4,%esp
  8049f5:	68 07 18 81 00       	push   $0x811807
  8049fa:	68 bc 00 00 00       	push   $0xbc
  8049ff:	68 80 17 81 00       	push   $0x811780
  804a04:	e8 d8 99 00 00       	call   80e3e1 <_panic>
      q->tot_len = (u16_t)rem_len;
  804a09:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804a0d:	66 81 fb d0 07       	cmp    $0x7d0,%bx
  804a12:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804a17:	0f 46 d3             	cmovbe %ebx,%edx
  804a1a:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804a1e:	8d 48 10             	lea    0x10(%eax),%ecx
  804a21:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804a24:	f6 c1 03             	test   $0x3,%cl
  804a27:	74 17                	je     804a40 <pbuf_alloc+0x18b>
  804a29:	83 ec 04             	sub    $0x4,%esp
  804a2c:	68 38 19 81 00       	push   $0x811938
  804a31:	68 c2 00 00 00       	push   $0xc2
  804a36:	68 80 17 81 00       	push   $0x811780
  804a3b:	e8 a1 99 00 00       	call   80e3e1 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a40:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  804a44:	03 4e 04             	add    0x4(%esi),%ecx
  804a47:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804a4a:	73 17                	jae    804a63 <pbuf_alloc+0x1ae>
  804a4c:	83 ec 04             	sub    $0x4,%esp
  804a4f:	68 04 19 81 00       	push   $0x811904
  804a54:	68 c5 00 00 00       	push   $0xc5
  804a59:	68 80 17 81 00       	push   $0x811780
  804a5e:	e8 7e 99 00 00       	call   80e3e1 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  804a63:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  804a69:	0f b7 d2             	movzwl %dx,%edx
  804a6c:	29 d3                	sub    %edx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  804a6e:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  804a70:	85 db                	test   %ebx,%ebx
  804a72:	0f 8f 3b ff ff ff    	jg     8049b3 <pbuf_alloc+0xfe>
  804a78:	e9 8e 00 00 00       	jmp    804b0b <pbuf_alloc+0x256>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804a7d:	0f b7 ff             	movzwl %di,%edi
  804a80:	83 ec 0c             	sub    $0xc,%esp
  804a83:	8d 47 13             	lea    0x13(%edi),%eax
  804a86:	83 e0 fc             	and    $0xfffffffc,%eax
  804a89:	89 c2                	mov    %eax,%edx
  804a8b:	0f b7 c3             	movzwl %bx,%eax
  804a8e:	83 c0 03             	add    $0x3,%eax
  804a91:	83 e0 fc             	and    $0xfffffffc,%eax
  804a94:	01 d0                	add    %edx,%eax
  804a96:	50                   	push   %eax
  804a97:	e8 73 f7 ff ff       	call   80420f <mem_malloc>
  804a9c:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804a9e:	83 c4 10             	add    $0x10,%esp
  804aa1:	85 c0                	test   %eax,%eax
  804aa3:	74 7b                	je     804b20 <pbuf_alloc+0x26b>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804aa5:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  804aa9:	83 e0 fc             	and    $0xfffffffc,%eax
  804aac:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  804aaf:	66 89 5e 08          	mov    %bx,0x8(%esi)
  804ab3:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  804ab7:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  804abd:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  804ac1:	eb 48                	jmp    804b0b <pbuf_alloc+0x256>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  804ac3:	83 ec 0c             	sub    $0xc,%esp
  804ac6:	6a 0c                	push   $0xc
  804ac8:	e8 59 f9 ff ff       	call   804426 <memp_malloc>
  804acd:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804acf:	83 c4 10             	add    $0x10,%esp
  804ad2:	85 c0                	test   %eax,%eax
  804ad4:	74 51                	je     804b27 <pbuf_alloc+0x272>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  804ad6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804add:	66 89 58 08          	mov    %bx,0x8(%eax)
  804ae1:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  804ae5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804aeb:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  804aef:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  804af2:	eb 17                	jmp    804b0b <pbuf_alloc+0x256>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804af4:	83 ec 04             	sub    $0x4,%esp
  804af7:	68 1b 18 81 00       	push   $0x81181b
  804afc:	68 f1 00 00 00       	push   $0xf1
  804b01:	68 80 17 81 00       	push   $0x811780
  804b06:	e8 d6 98 00 00       	call   80e3e1 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  804b0b:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  804b11:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  804b15:	89 f0                	mov    %esi,%eax
  804b17:	eb 13                	jmp    804b2c <pbuf_alloc+0x277>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  804b19:	b8 00 00 00 00       	mov    $0x0,%eax
  804b1e:	eb 0c                	jmp    804b2c <pbuf_alloc+0x277>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  804b20:	b8 00 00 00 00       	mov    $0x0,%eax
  804b25:	eb 05                	jmp    804b2c <pbuf_alloc+0x277>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  804b27:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  804b2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804b2f:	5b                   	pop    %ebx
  804b30:	5e                   	pop    %esi
  804b31:	5f                   	pop    %edi
  804b32:	5d                   	pop    %ebp
  804b33:	c3                   	ret    

00804b34 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  804b34:	55                   	push   %ebp
  804b35:	89 e5                	mov    %esp,%ebp
  804b37:	56                   	push   %esi
  804b38:	53                   	push   %ebx
  804b39:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b3c:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b3f:	85 db                	test   %ebx,%ebx
  804b41:	75 17                	jne    804b5a <pbuf_realloc+0x26>
  804b43:	83 ec 04             	sub    $0x4,%esp
  804b46:	68 36 18 81 00       	push   $0x811836
  804b4b:	68 13 01 00 00       	push   $0x113
  804b50:	68 80 17 81 00       	push   $0x811780
  804b55:	e8 87 98 00 00       	call   80e3e1 <_panic>
  804b5a:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b5c:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804b60:	76 17                	jbe    804b79 <pbuf_realloc+0x45>
  804b62:	83 ec 04             	sub    $0x4,%esp
  804b65:	68 4e 18 81 00       	push   $0x81184e
  804b6a:	68 17 01 00 00       	push   $0x117
  804b6f:	68 80 17 81 00       	push   $0x811780
  804b74:	e8 68 98 00 00       	call   80e3e1 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  804b79:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804b7d:	66 39 d0             	cmp    %dx,%ax
  804b80:	0f 86 b4 00 00 00    	jbe    804c3a <pbuf_realloc+0x106>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  804b86:	0f b7 d2             	movzwl %dx,%edx
  804b89:	0f b7 c0             	movzwl %ax,%eax
  804b8c:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804b8e:	eb 42                	jmp    804bd2 <pbuf_realloc+0x9e>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  804b90:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804b92:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  804b98:	7e 17                	jle    804bb1 <pbuf_realloc+0x7d>
  804b9a:	83 ec 04             	sub    $0x4,%esp
  804b9d:	68 69 18 81 00       	push   $0x811869
  804ba2:	68 2b 01 00 00       	push   $0x12b
  804ba7:	68 80 17 81 00       	push   $0x811780
  804bac:	e8 30 98 00 00       	call   80e3e1 <_panic>
    q->tot_len += (u16_t)grow;
  804bb1:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  804bb5:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804bb7:	85 db                	test   %ebx,%ebx
  804bb9:	75 17                	jne    804bd2 <pbuf_realloc+0x9e>
  804bbb:	83 ec 04             	sub    $0x4,%esp
  804bbe:	68 7a 18 81 00       	push   $0x81187a
  804bc3:	68 2f 01 00 00       	push   $0x12f
  804bc8:	68 80 17 81 00       	push   $0x811780
  804bcd:	e8 0f 98 00 00       	call   80e3e1 <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804bd2:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804bd6:	66 39 c6             	cmp    %ax,%si
  804bd9:	77 b5                	ja     804b90 <pbuf_realloc+0x5c>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804bdb:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804bdf:	75 39                	jne    804c1a <pbuf_realloc+0xe6>
  804be1:	66 39 f0             	cmp    %si,%ax
  804be4:	74 34                	je     804c1a <pbuf_realloc+0xe6>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804be6:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804be9:	29 d9                	sub    %ebx,%ecx
  804beb:	0f b7 c6             	movzwl %si,%eax
  804bee:	01 c8                	add    %ecx,%eax
  804bf0:	83 ec 08             	sub    $0x8,%esp
  804bf3:	50                   	push   %eax
  804bf4:	53                   	push   %ebx
  804bf5:	e8 cc f4 ff ff       	call   8040c6 <mem_realloc>
  804bfa:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804bfc:	83 c4 10             	add    $0x10,%esp
  804bff:	85 c0                	test   %eax,%eax
  804c01:	75 17                	jne    804c1a <pbuf_realloc+0xe6>
  804c03:	83 ec 04             	sub    $0x4,%esp
  804c06:	68 92 18 81 00       	push   $0x811892
  804c0b:	68 39 01 00 00       	push   $0x139
  804c10:	68 80 17 81 00       	push   $0x811780
  804c15:	e8 c7 97 00 00       	call   80e3e1 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  804c1a:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804c1e:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  804c22:	8b 03                	mov    (%ebx),%eax
  804c24:	85 c0                	test   %eax,%eax
  804c26:	74 0c                	je     804c34 <pbuf_realloc+0x100>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  804c28:	83 ec 0c             	sub    $0xc,%esp
  804c2b:	50                   	push   %eax
  804c2c:	e8 be fb ff ff       	call   8047ef <pbuf_free>
  804c31:	83 c4 10             	add    $0x10,%esp
  }
  /* q is last packet in chain */
  q->next = NULL;
  804c34:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  804c3a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804c3d:	5b                   	pop    %ebx
  804c3e:	5e                   	pop    %esi
  804c3f:	5d                   	pop    %ebp
  804c40:	c3                   	ret    

00804c41 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804c41:	55                   	push   %ebp
  804c42:	89 e5                	mov    %esp,%ebp
  804c44:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804c47:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804c4c:	eb 05                	jmp    804c53 <pbuf_clen+0x12>
    ++len;
  804c4e:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804c51:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  804c53:	85 d2                	test   %edx,%edx
  804c55:	75 f7                	jne    804c4e <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  804c57:	5d                   	pop    %ebp
  804c58:	c3                   	ret    

00804c59 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804c59:	55                   	push   %ebp
  804c5a:	89 e5                	mov    %esp,%ebp
  804c5c:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804c5f:	85 c0                	test   %eax,%eax
  804c61:	74 05                	je     804c68 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804c63:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804c68:	5d                   	pop    %ebp
  804c69:	c3                   	ret    

00804c6a <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804c6a:	55                   	push   %ebp
  804c6b:	89 e5                	mov    %esp,%ebp
  804c6d:	53                   	push   %ebx
  804c6e:	83 ec 04             	sub    $0x4,%esp
  804c71:	8b 45 08             	mov    0x8(%ebp),%eax
  804c74:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804c77:	85 c0                	test   %eax,%eax
  804c79:	74 04                	je     804c7f <pbuf_cat+0x15>
  804c7b:	85 db                	test   %ebx,%ebx
  804c7d:	75 21                	jne    804ca0 <pbuf_cat+0x36>
  804c7f:	83 ec 04             	sub    $0x4,%esp
  804c82:	68 68 19 81 00       	push   $0x811968
  804c87:	68 42 02 00 00       	push   $0x242
  804c8c:	68 80 17 81 00       	push   $0x811780
  804c91:	e8 4b 97 00 00       	call   80e3e1 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804c96:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804c9a:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804c9e:	89 d0                	mov    %edx,%eax
  804ca0:	8b 10                	mov    (%eax),%edx
  804ca2:	85 d2                	test   %edx,%edx
  804ca4:	75 f0                	jne    804c96 <pbuf_cat+0x2c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804ca6:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804caa:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804cae:	74 17                	je     804cc7 <pbuf_cat+0x5d>
  804cb0:	83 ec 04             	sub    $0x4,%esp
  804cb3:	68 a0 19 81 00       	push   $0x8119a0
  804cb8:	68 4a 02 00 00       	push   $0x24a
  804cbd:	68 80 17 81 00       	push   $0x811780
  804cc2:	e8 1a 97 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804cc7:	66 03 53 08          	add    0x8(%ebx),%dx
  804ccb:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804ccf:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804cd1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804cd4:	c9                   	leave  
  804cd5:	c3                   	ret    

00804cd6 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804cd6:	55                   	push   %ebp
  804cd7:	89 e5                	mov    %esp,%ebp
  804cd9:	53                   	push   %ebx
  804cda:	83 ec 0c             	sub    $0xc,%esp
  804cdd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804ce0:	53                   	push   %ebx
  804ce1:	ff 75 08             	pushl  0x8(%ebp)
  804ce4:	e8 81 ff ff ff       	call   804c6a <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804ce9:	89 1c 24             	mov    %ebx,(%esp)
  804cec:	e8 68 ff ff ff       	call   804c59 <pbuf_ref>
  804cf1:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804cf4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804cf7:	c9                   	leave  
  804cf8:	c3                   	ret    

00804cf9 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804cf9:	55                   	push   %ebp
  804cfa:	89 e5                	mov    %esp,%ebp
  804cfc:	57                   	push   %edi
  804cfd:	56                   	push   %esi
  804cfe:	53                   	push   %ebx
  804cff:	83 ec 1c             	sub    $0x1c,%esp
  804d02:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804d05:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804d07:	85 f6                	test   %esi,%esi
  804d09:	0f 84 80 00 00 00    	je     804d8f <pbuf_dechain+0x96>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804d0f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d13:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d17:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804d1b:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804d1e:	0f b7 d0             	movzwl %ax,%edx
  804d21:	0f b7 f9             	movzwl %cx,%edi
  804d24:	29 fa                	sub    %edi,%edx
  804d26:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804d29:	74 17                	je     804d42 <pbuf_dechain+0x49>
  804d2b:	83 ec 04             	sub    $0x4,%esp
  804d2e:	68 d0 19 81 00       	push   $0x8119d0
  804d33:	68 80 02 00 00       	push   $0x280
  804d38:	68 80 17 81 00       	push   $0x811780
  804d3d:	e8 9f 96 00 00       	call   80e3e1 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804d42:	29 c8                	sub    %ecx,%eax
  804d44:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804d48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804d4e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d52:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804d56:	83 ec 0c             	sub    $0xc,%esp
  804d59:	56                   	push   %esi
  804d5a:	e8 90 fa ff ff       	call   8047ef <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d5f:	83 c4 10             	add    $0x10,%esp
  804d62:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d66:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804d6a:	74 17                	je     804d83 <pbuf_dechain+0x8a>
  804d6c:	83 ec 04             	sub    $0x4,%esp
  804d6f:	68 ad 18 81 00       	push   $0x8118ad
  804d74:	68 91 02 00 00       	push   $0x291
  804d79:	68 80 17 81 00       	push   $0x811780
  804d7e:	e8 5e 96 00 00       	call   80e3e1 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  804d83:	84 c0                	test   %al,%al
  804d85:	b8 00 00 00 00       	mov    $0x0,%eax
  804d8a:	0f 44 c6             	cmove  %esi,%eax
  804d8d:	eb 0f                	jmp    804d9e <pbuf_dechain+0xa5>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d8f:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d93:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804d97:	75 d3                	jne    804d6c <pbuf_dechain+0x73>
  return ((tail_gone > 0) ? NULL : q);
  804d99:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804d9e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804da1:	5b                   	pop    %ebx
  804da2:	5e                   	pop    %esi
  804da3:	5f                   	pop    %edi
  804da4:	5d                   	pop    %ebp
  804da5:	c3                   	ret    

00804da6 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804da6:	55                   	push   %ebp
  804da7:	89 e5                	mov    %esp,%ebp
  804da9:	57                   	push   %edi
  804daa:	56                   	push   %esi
  804dab:	53                   	push   %ebx
  804dac:	83 ec 1c             	sub    $0x1c,%esp
  804daf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804db2:	8b 75 0c             	mov    0xc(%ebp),%esi

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804db5:	85 db                	test   %ebx,%ebx
  804db7:	74 0e                	je     804dc7 <pbuf_copy+0x21>
  804db9:	85 f6                	test   %esi,%esi
  804dbb:	74 0a                	je     804dc7 <pbuf_copy+0x21>
  804dbd:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  804dc1:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804dc5:	73 17                	jae    804dde <pbuf_copy+0x38>
  804dc7:	83 ec 04             	sub    $0x4,%esp
  804dca:	68 f4 19 81 00       	push   $0x8119f4
  804dcf:	68 b1 02 00 00       	push   $0x2b1
  804dd4:	68 80 17 81 00       	push   $0x811780
  804dd9:	e8 03 96 00 00       	call   80e3e1 <_panic>
  804dde:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804de4:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804dea:	85 db                	test   %ebx,%ebx
  804dec:	75 17                	jne    804e05 <pbuf_copy+0x5f>
  804dee:	83 ec 04             	sub    $0x4,%esp
  804df1:	68 c2 18 81 00       	push   $0x8118c2
  804df6:	68 b6 02 00 00       	push   $0x2b6
  804dfb:	68 80 17 81 00       	push   $0x811780
  804e00:	e8 dc 95 00 00       	call   80e3e1 <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804e05:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  804e09:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804e0d:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e11:	29 c1                	sub    %eax,%ecx
  804e13:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804e16:	0f b7 d7             	movzwl %di,%edx
  804e19:	0f b7 4d e4          	movzwl -0x1c(%ebp),%ecx
  804e1d:	0f b7 c1             	movzwl %cx,%eax
  804e20:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  804e22:	89 f8                	mov    %edi,%eax
  804e24:	89 cf                	mov    %ecx,%edi
  804e26:	29 f8                	sub    %edi,%eax
  804e28:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804e2c:	66 2b 4d e6          	sub    -0x1a(%ebp),%cx
  804e30:	89 cf                	mov    %ecx,%edi
  804e32:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  804e35:	0f 4d f8             	cmovge %eax,%edi
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804e38:	83 ec 04             	sub    $0x4,%esp
  804e3b:	0f b7 c7             	movzwl %di,%eax
  804e3e:	50                   	push   %eax
  804e3f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804e43:	03 46 04             	add    0x4(%esi),%eax
  804e46:	50                   	push   %eax
  804e47:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e4b:	03 43 04             	add    0x4(%ebx),%eax
  804e4e:	50                   	push   %eax
  804e4f:	e8 e7 9d 00 00       	call   80ec3b <memcpy>
    offset_to += len;
  804e54:	66 01 7d e6          	add    %di,-0x1a(%ebp)
  804e58:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
    offset_from += len;
  804e5c:	66 01 7d e4          	add    %di,-0x1c(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804e60:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e64:	83 c4 10             	add    $0x10,%esp
  804e67:	66 39 c2             	cmp    %ax,%dx
  804e6a:	76 17                	jbe    804e83 <pbuf_copy+0xdd>
  804e6c:	83 ec 04             	sub    $0x4,%esp
  804e6f:	68 cf 18 81 00       	push   $0x8118cf
  804e74:	68 c2 02 00 00       	push   $0x2c2
  804e79:	68 80 17 81 00       	push   $0x811780
  804e7e:	e8 5e 95 00 00       	call   80e3e1 <_panic>
    if (offset_to == p_to->len) {
  804e83:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804e87:	75 08                	jne    804e91 <pbuf_copy+0xeb>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804e89:	8b 1b                	mov    (%ebx),%ebx
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  804e8b:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804e91:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  804e95:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  804e99:	76 17                	jbe    804eb2 <pbuf_copy+0x10c>
  804e9b:	83 ec 04             	sub    $0x4,%esp
  804e9e:	68 e6 18 81 00       	push   $0x8118e6
  804ea3:	68 c8 02 00 00       	push   $0x2c8
  804ea8:	68 80 17 81 00       	push   $0x811780
  804ead:	e8 2f 95 00 00       	call   80e3e1 <_panic>
    if (offset_from >= p_from->len) {
  804eb2:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  804eb6:	72 08                	jb     804ec0 <pbuf_copy+0x11a>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  804eb8:	8b 36                	mov    (%esi),%esi
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804eba:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804ec0:	85 f6                	test   %esi,%esi
  804ec2:	74 26                	je     804eea <pbuf_copy+0x144>
  804ec4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  804ec8:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  804ecc:	75 48                	jne    804f16 <pbuf_copy+0x170>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804ece:	83 3e 00             	cmpl   $0x0,(%esi)
  804ed1:	74 43                	je     804f16 <pbuf_copy+0x170>
  804ed3:	83 ec 04             	sub    $0x4,%esp
  804ed6:	68 24 1a 81 00       	push   $0x811a24
  804edb:	68 d2 02 00 00       	push   $0x2d2
  804ee0:	68 80 17 81 00       	push   $0x811780
  804ee5:	e8 f7 94 00 00       	call   80e3e1 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804eea:	85 db                	test   %ebx,%ebx
  804eec:	75 40                	jne    804f2e <pbuf_copy+0x188>
  804eee:	eb 48                	jmp    804f38 <pbuf_copy+0x192>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804ef0:	83 3b 00             	cmpl   $0x0,(%ebx)
  804ef3:	74 17                	je     804f0c <pbuf_copy+0x166>
  804ef5:	83 ec 04             	sub    $0x4,%esp
  804ef8:	68 24 1a 81 00       	push   $0x811a24
  804efd:	68 d7 02 00 00       	push   $0x2d7
  804f02:	68 80 17 81 00       	push   $0x811780
  804f07:	e8 d5 94 00 00       	call   80e3e1 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804f0c:	85 f6                	test   %esi,%esi
  804f0e:	0f 85 d6 fe ff ff    	jne    804dea <pbuf_copy+0x44>
  804f14:	eb 22                	jmp    804f38 <pbuf_copy+0x192>
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804f16:	85 db                	test   %ebx,%ebx
  804f18:	0f 84 cc fe ff ff    	je     804dea <pbuf_copy+0x44>
  804f1e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f22:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804f26:	0f 85 be fe ff ff    	jne    804dea <pbuf_copy+0x44>
  804f2c:	eb c2                	jmp    804ef0 <pbuf_copy+0x14a>
  804f2e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f32:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804f36:	74 b8                	je     804ef0 <pbuf_copy+0x14a>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804f38:	b8 00 00 00 00       	mov    $0x0,%eax
  804f3d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f40:	5b                   	pop    %ebx
  804f41:	5e                   	pop    %esi
  804f42:	5f                   	pop    %edi
  804f43:	5d                   	pop    %ebp
  804f44:	c3                   	ret    

00804f45 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804f45:	55                   	push   %ebp
  804f46:	89 e5                	mov    %esp,%ebp
  804f48:	57                   	push   %edi
  804f49:	56                   	push   %esi
  804f4a:	53                   	push   %ebx
  804f4b:	83 ec 1c             	sub    $0x1c,%esp
  804f4e:	8b 75 08             	mov    0x8(%ebp),%esi
  804f51:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804f55:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804f59:	85 f6                	test   %esi,%esi
  804f5b:	75 17                	jne    804f74 <pbuf_copy_partial+0x2f>
  804f5d:	83 ec 04             	sub    $0x4,%esp
  804f60:	68 50 1a 81 00       	push   $0x811a50
  804f65:	68 ef 02 00 00       	push   $0x2ef
  804f6a:	68 80 17 81 00       	push   $0x811780
  804f6f:	e8 6d 94 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804f74:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804f78:	75 66                	jne    804fe0 <pbuf_copy_partial+0x9b>
  804f7a:	83 ec 04             	sub    $0x4,%esp
  804f7d:	68 74 1a 81 00       	push   $0x811a74
  804f82:	68 f0 02 00 00       	push   $0x2f0
  804f87:	68 80 17 81 00       	push   $0x811780
  804f8c:	e8 50 94 00 00       	call   80e3e1 <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  804f91:	66 85 c0             	test   %ax,%ax
  804f94:	74 0d                	je     804fa3 <pbuf_copy_partial+0x5e>
  804f96:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  804f9a:	66 39 d0             	cmp    %dx,%ax
  804f9d:	72 04                	jb     804fa3 <pbuf_copy_partial+0x5e>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  804f9f:	29 d0                	sub    %edx,%eax
  804fa1:	eb 39                	jmp    804fdc <pbuf_copy_partial+0x97>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804fa3:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804fa7:	29 c3                	sub    %eax,%ebx
  804fa9:	66 39 fb             	cmp    %di,%bx
  804fac:	0f 47 df             	cmova  %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  804faf:	83 ec 04             	sub    $0x4,%esp
  804fb2:	0f b7 d3             	movzwl %bx,%edx
  804fb5:	52                   	push   %edx
  804fb6:	0f b7 c0             	movzwl %ax,%eax
  804fb9:	03 46 04             	add    0x4(%esi),%eax
  804fbc:	50                   	push   %eax
  804fbd:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804fc1:	03 45 0c             	add    0xc(%ebp),%eax
  804fc4:	50                   	push   %eax
  804fc5:	e8 71 9c 00 00       	call   80ec3b <memcpy>
      copied_total += buf_copy_len;
  804fca:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  804fce:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  804fd2:	29 df                	sub    %ebx,%edi
  804fd4:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  804fd7:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  804fdc:	8b 36                	mov    (%esi),%esi
  804fde:	eb 0c                	jmp    804fec <pbuf_copy_partial+0xa7>
  804fe0:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804fe6:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804fec:	85 f6                	test   %esi,%esi
  804fee:	74 05                	je     804ff5 <pbuf_copy_partial+0xb0>
  804ff0:	66 85 ff             	test   %di,%di
  804ff3:	75 9c                	jne    804f91 <pbuf_copy_partial+0x4c>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  804ff5:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804ff9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804ffc:	5b                   	pop    %ebx
  804ffd:	5e                   	pop    %esi
  804ffe:	5f                   	pop    %edi
  804fff:	5d                   	pop    %ebp
  805000:	c3                   	ret    

00805001 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805001:	55                   	push   %ebp
  805002:	89 e5                	mov    %esp,%ebp
  805004:	83 ec 14             	sub    $0x14,%esp
  805007:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80500a:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80500f:	8b 40 04             	mov    0x4(%eax),%eax
  805012:	ff 30                	pushl  (%eax)
  805014:	e8 82 4f 00 00       	call   809f9b <sys_sem_signal>
  805019:	83 c4 10             	add    $0x10,%esp
}
  80501c:	c9                   	leave  
  80501d:	c3                   	ret    

0080501e <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80501e:	55                   	push   %ebp
  80501f:	89 e5                	mov    %esp,%ebp
  805021:	57                   	push   %edi
  805022:	56                   	push   %esi
  805023:	53                   	push   %ebx
  805024:	83 ec 0c             	sub    $0xc,%esp
  805027:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80502a:	e8 6d 53 00 00       	call   80a39c <sys_arch_timeouts>
  80502f:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  805031:	85 c0                	test   %eax,%eax
  805033:	74 06                	je     80503b <sys_mbox_fetch+0x1d>
  805035:	8b 00                	mov    (%eax),%eax
  805037:	85 c0                	test   %eax,%eax
  805039:	75 13                	jne    80504e <sys_mbox_fetch+0x30>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80503b:	83 ec 04             	sub    $0x4,%esp
  80503e:	6a 00                	push   $0x0
  805040:	57                   	push   %edi
  805041:	ff 75 08             	pushl  0x8(%ebp)
  805044:	e8 c0 51 00 00       	call   80a209 <sys_arch_mbox_fetch>
  805049:	83 c4 10             	add    $0x10,%esp
  80504c:	eb 5c                	jmp    8050aa <sys_mbox_fetch+0x8c>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80504e:	8b 40 04             	mov    0x4(%eax),%eax
  805051:	85 c0                	test   %eax,%eax
  805053:	74 15                	je     80506a <sys_mbox_fetch+0x4c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805055:	83 ec 04             	sub    $0x4,%esp
  805058:	50                   	push   %eax
  805059:	57                   	push   %edi
  80505a:	ff 75 08             	pushl  0x8(%ebp)
  80505d:	e8 a7 51 00 00       	call   80a209 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  805062:	83 c4 10             	add    $0x10,%esp
  805065:	83 f8 ff             	cmp    $0xffffffff,%eax
  805068:	75 29                	jne    805093 <sys_mbox_fetch+0x75>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80506a:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80506c:	8b 10                	mov    (%eax),%edx
  80506e:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  805070:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805073:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805076:	83 ec 08             	sub    $0x8,%esp
  805079:	50                   	push   %eax
  80507a:	6a 0b                	push   $0xb
  80507c:	e8 fb f3 ff ff       	call   80447c <memp_free>
      if (h != NULL) {
  805081:	83 c4 10             	add    $0x10,%esp
  805084:	85 db                	test   %ebx,%ebx
  805086:	74 a2                	je     80502a <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  805088:	83 ec 0c             	sub    $0xc,%esp
  80508b:	56                   	push   %esi
  80508c:	ff d3                	call   *%ebx
  80508e:	83 c4 10             	add    $0x10,%esp
  805091:	eb 97                	jmp    80502a <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805093:	8b 0b                	mov    (%ebx),%ecx
  805095:	8b 51 04             	mov    0x4(%ecx),%edx
  805098:	39 d0                	cmp    %edx,%eax
  80509a:	73 07                	jae    8050a3 <sys_mbox_fetch+0x85>
        timeouts->next->time -= time_needed;
  80509c:	29 c2                	sub    %eax,%edx
  80509e:	89 51 04             	mov    %edx,0x4(%ecx)
  8050a1:	eb 07                	jmp    8050aa <sys_mbox_fetch+0x8c>
      } else {
        timeouts->next->time = 0;
  8050a3:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  8050aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050ad:	5b                   	pop    %ebx
  8050ae:	5e                   	pop    %esi
  8050af:	5f                   	pop    %edi
  8050b0:	5d                   	pop    %ebp
  8050b1:	c3                   	ret    

008050b2 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  8050b2:	55                   	push   %ebp
  8050b3:	89 e5                	mov    %esp,%ebp
  8050b5:	57                   	push   %edi
  8050b6:	56                   	push   %esi
  8050b7:	53                   	push   %ebx
  8050b8:	83 ec 0c             	sub    $0xc,%esp
  8050bb:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  8050be:	e8 d9 52 00 00       	call   80a39c <sys_arch_timeouts>
  8050c3:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8050c5:	85 c0                	test   %eax,%eax
  8050c7:	74 06                	je     8050cf <sys_sem_wait+0x1d>
  8050c9:	8b 00                	mov    (%eax),%eax
  8050cb:	85 c0                	test   %eax,%eax
  8050cd:	75 10                	jne    8050df <sys_sem_wait+0x2d>
    sys_arch_sem_wait(sem, 0);
  8050cf:	83 ec 08             	sub    $0x8,%esp
  8050d2:	6a 00                	push   $0x0
  8050d4:	56                   	push   %esi
  8050d5:	e8 2f 4f 00 00       	call   80a009 <sys_arch_sem_wait>
  8050da:	83 c4 10             	add    $0x10,%esp
  8050dd:	eb 59                	jmp    805138 <sys_sem_wait+0x86>
  } else {
    if (timeouts->next->time > 0) {
  8050df:	8b 40 04             	mov    0x4(%eax),%eax
  8050e2:	85 c0                	test   %eax,%eax
  8050e4:	74 12                	je     8050f8 <sys_sem_wait+0x46>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  8050e6:	83 ec 08             	sub    $0x8,%esp
  8050e9:	50                   	push   %eax
  8050ea:	56                   	push   %esi
  8050eb:	e8 19 4f 00 00       	call   80a009 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8050f0:	83 c4 10             	add    $0x10,%esp
  8050f3:	83 f8 ff             	cmp    $0xffffffff,%eax
  8050f6:	75 29                	jne    805121 <sys_sem_wait+0x6f>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8050f8:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8050fa:	8b 10                	mov    (%eax),%edx
  8050fc:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8050fe:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805101:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805104:	83 ec 08             	sub    $0x8,%esp
  805107:	50                   	push   %eax
  805108:	6a 0b                	push   $0xb
  80510a:	e8 6d f3 ff ff       	call   80447c <memp_free>
      if (h != NULL) {
  80510f:	83 c4 10             	add    $0x10,%esp
  805112:	85 db                	test   %ebx,%ebx
  805114:	74 a8                	je     8050be <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  805116:	83 ec 0c             	sub    $0xc,%esp
  805119:	57                   	push   %edi
  80511a:	ff d3                	call   *%ebx
  80511c:	83 c4 10             	add    $0x10,%esp
  80511f:	eb 9d                	jmp    8050be <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805121:	8b 0b                	mov    (%ebx),%ecx
  805123:	8b 51 04             	mov    0x4(%ecx),%edx
  805126:	39 d0                	cmp    %edx,%eax
  805128:	73 07                	jae    805131 <sys_sem_wait+0x7f>
        timeouts->next->time -= time_needed;
  80512a:	29 c2                	sub    %eax,%edx
  80512c:	89 51 04             	mov    %edx,0x4(%ecx)
  80512f:	eb 07                	jmp    805138 <sys_sem_wait+0x86>
      } else {
        timeouts->next->time = 0;
  805131:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  805138:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80513b:	5b                   	pop    %ebx
  80513c:	5e                   	pop    %esi
  80513d:	5f                   	pop    %edi
  80513e:	5d                   	pop    %ebp
  80513f:	c3                   	ret    

00805140 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  805140:	55                   	push   %ebp
  805141:	89 e5                	mov    %esp,%ebp
  805143:	56                   	push   %esi
  805144:	53                   	push   %ebx
  805145:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  805148:	83 ec 0c             	sub    $0xc,%esp
  80514b:	6a 0b                	push   $0xb
  80514d:	e8 d4 f2 ff ff       	call   804426 <memp_malloc>
  805152:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  805154:	83 c4 10             	add    $0x10,%esp
  805157:	85 c0                	test   %eax,%eax
  805159:	75 17                	jne    805172 <sys_timeout+0x32>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80515b:	83 ec 04             	sub    $0x4,%esp
  80515e:	68 99 1a 81 00       	push   $0x811a99
  805163:	68 c3 00 00 00       	push   $0xc3
  805168:	68 b6 1a 81 00       	push   $0x811ab6
  80516d:	e8 6f 92 00 00       	call   80e3e1 <_panic>
    return;
  }
  timeout->next = NULL;
  805172:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805178:	8b 45 0c             	mov    0xc(%ebp),%eax
  80517b:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  80517e:	8b 45 10             	mov    0x10(%ebp),%eax
  805181:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  805184:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  805187:	e8 10 52 00 00       	call   80a39c <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80518c:	85 c0                	test   %eax,%eax
  80518e:	75 17                	jne    8051a7 <sys_timeout+0x67>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805190:	83 ec 04             	sub    $0x4,%esp
  805193:	68 ca 1a 81 00       	push   $0x811aca
  805198:	68 d1 00 00 00       	push   $0xd1
  80519d:	68 b6 1a 81 00       	push   $0x811ab6
  8051a2:	e8 3a 92 00 00       	call   80e3e1 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  8051a7:	8b 08                	mov    (%eax),%ecx
  8051a9:	85 c9                	test   %ecx,%ecx
  8051ab:	75 04                	jne    8051b1 <sys_timeout+0x71>
    timeouts->next = timeout;
  8051ad:	89 18                	mov    %ebx,(%eax)
    return;
  8051af:	eb 39                	jmp    8051ea <sys_timeout+0xaa>
  }

  if (timeouts->next->time > msecs) {
  8051b1:	8b 51 04             	mov    0x4(%ecx),%edx
  8051b4:	39 d6                	cmp    %edx,%esi
  8051b6:	73 0d                	jae    8051c5 <sys_timeout+0x85>
    timeouts->next->time -= msecs;
  8051b8:	29 f2                	sub    %esi,%edx
  8051ba:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  8051bd:	8b 10                	mov    (%eax),%edx
  8051bf:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8051c1:	89 18                	mov    %ebx,(%eax)
  8051c3:	eb 25                	jmp    8051ea <sys_timeout+0xaa>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  8051c5:	8b 53 04             	mov    0x4(%ebx),%edx
  8051c8:	2b 51 04             	sub    0x4(%ecx),%edx
  8051cb:	89 53 04             	mov    %edx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8051ce:	8b 01                	mov    (%ecx),%eax
  8051d0:	85 c0                	test   %eax,%eax
  8051d2:	74 09                	je     8051dd <sys_timeout+0x9d>
  8051d4:	3b 50 04             	cmp    0x4(%eax),%edx
  8051d7:	72 0c                	jb     8051e5 <sys_timeout+0xa5>
  8051d9:	89 c1                	mov    %eax,%ecx
  8051db:	eb e8                	jmp    8051c5 <sys_timeout+0x85>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  8051dd:	8b 01                	mov    (%ecx),%eax
  8051df:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  8051e1:	89 19                	mov    %ebx,(%ecx)
        break;
  8051e3:	eb 05                	jmp    8051ea <sys_timeout+0xaa>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  8051e5:	29 50 04             	sub    %edx,0x4(%eax)
  8051e8:	eb f3                	jmp    8051dd <sys_timeout+0x9d>
        t->next = timeout;
        break;
      }
    }
  }
}
  8051ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8051ed:	5b                   	pop    %ebx
  8051ee:	5e                   	pop    %esi
  8051ef:	5d                   	pop    %ebp
  8051f0:	c3                   	ret    

008051f1 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  8051f1:	55                   	push   %ebp
  8051f2:	89 e5                	mov    %esp,%ebp
  8051f4:	57                   	push   %edi
  8051f5:	56                   	push   %esi
  8051f6:	53                   	push   %ebx
  8051f7:	83 ec 0c             	sub    $0xc,%esp
  8051fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8051fd:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  805200:	e8 97 51 00 00       	call   80a39c <sys_arch_timeouts>

  if (timeouts == NULL) {
  805205:	85 c0                	test   %eax,%eax
  805207:	75 17                	jne    805220 <sys_untimeout+0x2f>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805209:	83 ec 04             	sub    $0x4,%esp
  80520c:	68 e8 1a 81 00       	push   $0x811ae8
  805211:	68 00 01 00 00       	push   $0x100
  805216:	68 b6 1a 81 00       	push   $0x811ab6
  80521b:	e8 c1 91 00 00       	call   80e3e1 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  805220:	8b 10                	mov    (%eax),%edx
  805222:	85 d2                	test   %edx,%edx
  805224:	74 45                	je     80526b <sys_untimeout+0x7a>
  805226:	bf 00 00 00 00       	mov    $0x0,%edi
  80522b:	eb 02                	jmp    80522f <sys_untimeout+0x3e>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80522d:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80522f:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805232:	75 2f                	jne    805263 <sys_untimeout+0x72>
  805234:	39 72 0c             	cmp    %esi,0xc(%edx)
  805237:	75 2a                	jne    805263 <sys_untimeout+0x72>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  805239:	85 ff                	test   %edi,%edi
  80523b:	75 06                	jne    805243 <sys_untimeout+0x52>
        timeouts->next = t->next;
  80523d:	8b 0a                	mov    (%edx),%ecx
  80523f:	89 08                	mov    %ecx,(%eax)
  805241:	eb 04                	jmp    805247 <sys_untimeout+0x56>
      else
        prev_t->next = t->next;
  805243:	8b 02                	mov    (%edx),%eax
  805245:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  805247:	8b 02                	mov    (%edx),%eax
  805249:	85 c0                	test   %eax,%eax
  80524b:	74 06                	je     805253 <sys_untimeout+0x62>
        t->next->time += t->time;
  80524d:	8b 4a 04             	mov    0x4(%edx),%ecx
  805250:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  805253:	83 ec 08             	sub    $0x8,%esp
  805256:	52                   	push   %edx
  805257:	6a 0b                	push   $0xb
  805259:	e8 1e f2 ff ff       	call   80447c <memp_free>
      return;
  80525e:	83 c4 10             	add    $0x10,%esp
  805261:	eb 08                	jmp    80526b <sys_untimeout+0x7a>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805263:	8b 0a                	mov    (%edx),%ecx
  805265:	89 d7                	mov    %edx,%edi
  805267:	85 c9                	test   %ecx,%ecx
  805269:	75 c2                	jne    80522d <sys_untimeout+0x3c>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  80526b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80526e:	5b                   	pop    %ebx
  80526f:	5e                   	pop    %esi
  805270:	5f                   	pop    %edi
  805271:	5d                   	pop    %ebp
  805272:	c3                   	ret    

00805273 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805273:	55                   	push   %ebp
  805274:	89 e5                	mov    %esp,%ebp
  805276:	83 ec 18             	sub    $0x18,%esp
  805279:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80527c:	8d 4d 08             	lea    0x8(%ebp),%ecx
  80527f:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805282:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  805288:	85 c0                	test   %eax,%eax
  80528a:	74 15                	je     8052a1 <sys_sem_wait_timeout+0x2e>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80528c:	83 ec 04             	sub    $0x4,%esp
  80528f:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805292:	52                   	push   %edx
  805293:	68 01 50 80 00       	push   $0x805001
  805298:	50                   	push   %eax
  805299:	e8 a2 fe ff ff       	call   805140 <sys_timeout>
  80529e:	83 c4 10             	add    $0x10,%esp
  }
  sys_sem_wait(sem);
  8052a1:	83 ec 0c             	sub    $0xc,%esp
  8052a4:	ff 75 08             	pushl  0x8(%ebp)
  8052a7:	e8 06 fe ff ff       	call   8050b2 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052ac:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8052af:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052b4:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8052b9:	75 19                	jne    8052d4 <sys_sem_wait_timeout+0x61>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  8052bb:	83 ec 08             	sub    $0x8,%esp
  8052be:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8052c1:	50                   	push   %eax
  8052c2:	68 01 50 80 00       	push   $0x805001
  8052c7:	e8 25 ff ff ff       	call   8051f1 <sys_untimeout>
    return 1;
  8052cc:	83 c4 10             	add    $0x10,%esp
  8052cf:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  8052d4:	c9                   	leave  
  8052d5:	c3                   	ret    

008052d6 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  8052d6:	55                   	push   %ebp
  8052d7:	89 e5                	mov    %esp,%ebp
  8052d9:	53                   	push   %ebx
  8052da:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8052dd:	6a 00                	push   $0x0
  8052df:	e8 06 4a 00 00       	call   809cea <sys_sem_new>
  8052e4:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8052e6:	83 c4 08             	add    $0x8,%esp
  8052e9:	ff 75 08             	pushl  0x8(%ebp)
  8052ec:	50                   	push   %eax
  8052ed:	e8 81 ff ff ff       	call   805273 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8052f2:	89 1c 24             	mov    %ebx,(%esp)
  8052f5:	e8 71 4a 00 00       	call   809d6b <sys_sem_free>
  8052fa:	83 c4 10             	add    $0x10,%esp
}
  8052fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805300:	c9                   	leave  
  805301:	c3                   	ret    

00805302 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  805302:	55                   	push   %ebp
  805303:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805305:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80530a:	5d                   	pop    %ebp
  80530b:	c3                   	ret    

0080530c <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80530c:	55                   	push   %ebp
  80530d:	89 e5                	mov    %esp,%ebp
  80530f:	57                   	push   %edi
  805310:	56                   	push   %esi
  805311:	53                   	push   %ebx
  805312:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805315:	8b 35 7c b3 b3 00    	mov    0xb3b37c,%esi
  80531b:	0f b7 0d 0c 40 81 00 	movzwl 0x81400c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805322:	8b 3d 90 b3 b3 00    	mov    0xb3b390,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805328:	a1 84 b3 b3 00       	mov    0xb3b384,%eax
  80532d:	89 45 f0             	mov    %eax,-0x10(%ebp)
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  805330:	bb 00 10 00 00       	mov    $0x1000,%ebx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  805335:	89 c8                	mov    %ecx,%eax
  805337:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  80533b:	0f 48 c3             	cmovs  %ebx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80533e:	89 f2                	mov    %esi,%edx
  805340:	eb 0c                	jmp    80534e <tcp_new_port+0x42>
    if (pcb->local_port == port) {
  805342:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  805346:	66 39 c8             	cmp    %cx,%ax
  805349:	74 ea                	je     805335 <tcp_new_port+0x29>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80534b:	8b 52 0c             	mov    0xc(%edx),%edx
  80534e:	85 d2                	test   %edx,%edx
  805350:	75 f0                	jne    805342 <tcp_new_port+0x36>
  805352:	89 fa                	mov    %edi,%edx
  805354:	eb 0c                	jmp    805362 <tcp_new_port+0x56>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805356:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80535a:	66 39 c8             	cmp    %cx,%ax
  80535d:	74 d6                	je     805335 <tcp_new_port+0x29>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80535f:	8b 52 0c             	mov    0xc(%edx),%edx
  805362:	85 d2                	test   %edx,%edx
  805364:	75 f0                	jne    805356 <tcp_new_port+0x4a>
  805366:	8b 55 f0             	mov    -0x10(%ebp),%edx
  805369:	eb 0c                	jmp    805377 <tcp_new_port+0x6b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  80536b:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80536f:	66 39 c8             	cmp    %cx,%ax
  805372:	74 c1                	je     805335 <tcp_new_port+0x29>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805374:	8b 52 0c             	mov    0xc(%edx),%edx
  805377:	85 d2                	test   %edx,%edx
  805379:	75 f0                	jne    80536b <tcp_new_port+0x5f>
  80537b:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  805381:	83 c4 04             	add    $0x4,%esp
  805384:	5b                   	pop    %ebx
  805385:	5e                   	pop    %esi
  805386:	5f                   	pop    %edi
  805387:	5d                   	pop    %ebp
  805388:	c3                   	ret    

00805389 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  805389:	55                   	push   %ebp
  80538a:	89 e5                	mov    %esp,%ebp
  80538c:	57                   	push   %edi
  80538d:	56                   	push   %esi
  80538e:	53                   	push   %ebx
  80538f:	83 ec 0c             	sub    $0xc,%esp
  805392:	8b 75 08             	mov    0x8(%ebp),%esi
  805395:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805398:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80539b:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  80539f:	74 17                	je     8053b8 <tcp_bind+0x2f>
  8053a1:	83 ec 04             	sub    $0x4,%esp
  8053a4:	68 08 1b 81 00       	push   $0x811b08
  8053a9:	68 05 01 00 00       	push   $0x105
  8053ae:	68 ea 1c 81 00       	push   $0x811cea
  8053b3:	e8 29 90 00 00       	call   80e3e1 <_panic>
  8053b8:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  8053ba:	66 85 d2             	test   %dx,%dx
  8053bd:	75 05                	jne    8053c4 <tcp_bind+0x3b>
    port = tcp_new_port();
  8053bf:	e8 48 ff ff ff       	call   80530c <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053c4:	8b 15 84 b3 b3 00    	mov    0xb3b384,%edx
  8053ca:	eb 35                	jmp    805401 <tcp_bind+0x78>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  8053cc:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8053d0:	75 2c                	jne    8053fe <tcp_bind+0x75>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8053d2:	85 d2                	test   %edx,%edx
  8053d4:	0f 84 f3 00 00 00    	je     8054cd <tcp_bind+0x144>
  8053da:	8b 0a                	mov    (%edx),%ecx
  8053dc:	85 db                	test   %ebx,%ebx
  8053de:	0f 84 f0 00 00 00    	je     8054d4 <tcp_bind+0x14b>
  8053e4:	85 c9                	test   %ecx,%ecx
  8053e6:	0f 84 e8 00 00 00    	je     8054d4 <tcp_bind+0x14b>
          ip_addr_isany(ipaddr) ||
  8053ec:	8b 3b                	mov    (%ebx),%edi
  8053ee:	85 ff                	test   %edi,%edi
  8053f0:	0f 84 e5 00 00 00    	je     8054db <tcp_bind+0x152>
  8053f6:	39 f9                	cmp    %edi,%ecx
  8053f8:	0f 84 dd 00 00 00    	je     8054db <tcp_bind+0x152>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8053fe:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805401:	85 d2                	test   %edx,%edx
  805403:	75 c7                	jne    8053cc <tcp_bind+0x43>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805405:	8b 15 7c b3 b3 00    	mov    0xb3b37c,%edx
  80540b:	eb 35                	jmp    805442 <tcp_bind+0xb9>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80540d:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805411:	75 2c                	jne    80543f <tcp_bind+0xb6>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805413:	85 d2                	test   %edx,%edx
  805415:	0f 84 c7 00 00 00    	je     8054e2 <tcp_bind+0x159>
  80541b:	8b 0a                	mov    (%edx),%ecx
  80541d:	85 db                	test   %ebx,%ebx
  80541f:	0f 84 c4 00 00 00    	je     8054e9 <tcp_bind+0x160>
  805425:	85 c9                	test   %ecx,%ecx
  805427:	0f 84 bc 00 00 00    	je     8054e9 <tcp_bind+0x160>
          ip_addr_isany(ipaddr) ||
  80542d:	8b 3b                	mov    (%ebx),%edi
  80542f:	85 ff                	test   %edi,%edi
  805431:	0f 84 b9 00 00 00    	je     8054f0 <tcp_bind+0x167>
  805437:	39 f9                	cmp    %edi,%ecx
  805439:	0f 84 b1 00 00 00    	je     8054f0 <tcp_bind+0x167>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80543f:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805442:	85 d2                	test   %edx,%edx
  805444:	75 c7                	jne    80540d <tcp_bind+0x84>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805446:	8b 15 8c b3 b3 00    	mov    0xb3b38c,%edx
  80544c:	eb 35                	jmp    805483 <tcp_bind+0xfa>
    if (cpcb->local_port == port) {
  80544e:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805452:	75 2c                	jne    805480 <tcp_bind+0xf7>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805454:	85 d2                	test   %edx,%edx
  805456:	0f 84 9b 00 00 00    	je     8054f7 <tcp_bind+0x16e>
  80545c:	8b 0a                	mov    (%edx),%ecx
  80545e:	85 db                	test   %ebx,%ebx
  805460:	0f 84 98 00 00 00    	je     8054fe <tcp_bind+0x175>
  805466:	85 c9                	test   %ecx,%ecx
  805468:	0f 84 90 00 00 00    	je     8054fe <tcp_bind+0x175>
          ip_addr_isany(ipaddr) ||
  80546e:	8b 3b                	mov    (%ebx),%edi
  805470:	85 ff                	test   %edi,%edi
  805472:	0f 84 8d 00 00 00    	je     805505 <tcp_bind+0x17c>
  805478:	39 f9                	cmp    %edi,%ecx
  80547a:	0f 84 85 00 00 00    	je     805505 <tcp_bind+0x17c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805480:	8b 52 0c             	mov    0xc(%edx),%edx
  805483:	85 d2                	test   %edx,%edx
  805485:	75 c7                	jne    80544e <tcp_bind+0xc5>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805487:	8b 15 90 b3 b3 00    	mov    0xb3b390,%edx
  80548d:	eb 0f                	jmp    80549e <tcp_bind+0x115>
    if (cpcb->local_port == port) {
  80548f:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805493:	75 06                	jne    80549b <tcp_bind+0x112>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805495:	8b 3b                	mov    (%ebx),%edi
  805497:	39 3a                	cmp    %edi,(%edx)
  805499:	74 71                	je     80550c <tcp_bind+0x183>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80549b:	8b 52 0c             	mov    0xc(%edx),%edx
  80549e:	85 d2                	test   %edx,%edx
  8054a0:	75 ed                	jne    80548f <tcp_bind+0x106>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  8054a2:	85 db                	test   %ebx,%ebx
  8054a4:	74 09                	je     8054af <tcp_bind+0x126>
  8054a6:	83 3b 00             	cmpl   $0x0,(%ebx)
  8054a9:	74 04                	je     8054af <tcp_bind+0x126>
    pcb->local_ip = *ipaddr;
  8054ab:	8b 13                	mov    (%ebx),%edx
  8054ad:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  8054af:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8054b3:	a1 8c b3 b3 00       	mov    0xb3b38c,%eax
  8054b8:	89 46 0c             	mov    %eax,0xc(%esi)
  8054bb:	89 35 8c b3 b3 00    	mov    %esi,0xb3b38c
  8054c1:	e8 73 cd ff ff       	call   802239 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  8054c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8054cb:	eb 44                	jmp    805511 <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  8054cd:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054d2:	eb 3d                	jmp    805511 <tcp_bind+0x188>
  8054d4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054d9:	eb 36                	jmp    805511 <tcp_bind+0x188>
  8054db:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054e0:	eb 2f                	jmp    805511 <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  8054e2:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054e7:	eb 28                	jmp    805511 <tcp_bind+0x188>
  8054e9:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054ee:	eb 21                	jmp    805511 <tcp_bind+0x188>
  8054f0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054f5:	eb 1a                	jmp    805511 <tcp_bind+0x188>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  8054f7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054fc:	eb 13                	jmp    805511 <tcp_bind+0x188>
  8054fe:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805503:	eb 0c                	jmp    805511 <tcp_bind+0x188>
  805505:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80550a:	eb 05                	jmp    805511 <tcp_bind+0x188>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80550c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805511:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805514:	5b                   	pop    %ebx
  805515:	5e                   	pop    %esi
  805516:	5f                   	pop    %edi
  805517:	5d                   	pop    %ebp
  805518:	c3                   	ret    

00805519 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805519:	55                   	push   %ebp
  80551a:	89 e5                	mov    %esp,%ebp
  80551c:	57                   	push   %edi
  80551d:	56                   	push   %esi
  80551e:	53                   	push   %ebx
  80551f:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805522:	8b 45 08             	mov    0x8(%ebp),%eax
  805525:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  805529:	74 17                	je     805542 <tcp_listen_with_backlog+0x29>
  80552b:	83 ec 04             	sub    $0x4,%esp
  80552e:	68 34 1b 81 00       	push   $0x811b34
  805533:	68 60 01 00 00       	push   $0x160
  805538:	68 ea 1c 81 00       	push   $0x811cea
  80553d:	e8 9f 8e 00 00       	call   80e3e1 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805542:	83 ec 0c             	sub    $0xc,%esp
  805545:	6a 03                	push   $0x3
  805547:	e8 da ee ff ff       	call   804426 <memp_malloc>
  80554c:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  80554e:	83 c4 10             	add    $0x10,%esp
  805551:	85 c0                	test   %eax,%eax
  805553:	0f 84 d8 00 00 00    	je     805631 <tcp_listen_with_backlog+0x118>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805559:	8b 45 08             	mov    0x8(%ebp),%eax
  80555c:	8b 40 18             	mov    0x18(%eax),%eax
  80555f:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805562:	8b 45 08             	mov    0x8(%ebp),%eax
  805565:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  805569:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  80556d:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  805574:	8b 45 08             	mov    0x8(%ebp),%eax
  805577:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80557b:	83 c8 02             	or     $0x2,%eax
  80557e:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  805582:	8b 45 08             	mov    0x8(%ebp),%eax
  805585:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  805589:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  80558c:	8b 45 08             	mov    0x8(%ebp),%eax
  80558f:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  805593:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805596:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80559a:	74 07                	je     8055a3 <tcp_listen_with_backlog+0x8a>
  80559c:	8b 45 08             	mov    0x8(%ebp),%eax
  80559f:	8b 00                	mov    (%eax),%eax
  8055a1:	eb 05                	jmp    8055a8 <tcp_listen_with_backlog+0x8f>
  8055a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8055a8:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055aa:	a1 8c b3 b3 00       	mov    0xb3b38c,%eax
  8055af:	3b 45 08             	cmp    0x8(%ebp),%eax
  8055b2:	75 0a                	jne    8055be <tcp_listen_with_backlog+0xa5>
  8055b4:	8b 40 0c             	mov    0xc(%eax),%eax
  8055b7:	a3 8c b3 b3 00       	mov    %eax,0xb3b38c
  8055bc:	eb 3d                	jmp    8055fb <tcp_listen_with_backlog+0xe2>
  8055be:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  8055c3:	eb 28                	jmp    8055ed <tcp_listen_with_backlog+0xd4>
  8055c5:	8b 50 0c             	mov    0xc(%eax),%edx
  8055c8:	39 55 08             	cmp    %edx,0x8(%ebp)
  8055cb:	0f 94 c1             	sete   %cl
  8055ce:	89 cf                	mov    %ecx,%edi
  8055d0:	85 d2                	test   %edx,%edx
  8055d2:	0f 95 c1             	setne  %cl
  8055d5:	89 fb                	mov    %edi,%ebx
  8055d7:	84 cb                	test   %cl,%bl
  8055d9:	74 10                	je     8055eb <tcp_listen_with_backlog+0xd2>
  8055db:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  8055e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8055e3:	8b 53 0c             	mov    0xc(%ebx),%edx
  8055e6:	89 50 0c             	mov    %edx,0xc(%eax)
  8055e9:	eb 10                	jmp    8055fb <tcp_listen_with_backlog+0xe2>
  8055eb:	89 d0                	mov    %edx,%eax
  8055ed:	85 c0                	test   %eax,%eax
  8055ef:	75 d4                	jne    8055c5 <tcp_listen_with_backlog+0xac>
  8055f1:	c7 05 88 b3 b3 00 00 	movl   $0x0,0xb3b388
  8055f8:	00 00 00 
  8055fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8055fe:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  memp_free(MEMP_TCP_PCB, pcb);
  805605:	83 ec 08             	sub    $0x8,%esp
  805608:	50                   	push   %eax
  805609:	6a 02                	push   $0x2
  80560b:	e8 6c ee ff ff       	call   80447c <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805610:	c7 46 20 02 53 80 00 	movl   $0x805302,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805617:	a1 84 b3 b3 00       	mov    0xb3b384,%eax
  80561c:	89 46 0c             	mov    %eax,0xc(%esi)
  80561f:	89 35 84 b3 b3 00    	mov    %esi,0xb3b384
  805625:	e8 0f cc ff ff       	call   802239 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  80562a:	83 c4 10             	add    $0x10,%esp
  80562d:	89 f0                	mov    %esi,%eax
  80562f:	eb 05                	jmp    805636 <tcp_listen_with_backlog+0x11d>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  805631:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  805636:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805639:	5b                   	pop    %ebx
  80563a:	5e                   	pop    %esi
  80563b:	5f                   	pop    %edi
  80563c:	5d                   	pop    %ebp
  80563d:	c3                   	ret    

0080563e <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80563e:	55                   	push   %ebp
  80563f:	89 e5                	mov    %esp,%ebp
  805641:	56                   	push   %esi
  805642:	53                   	push   %ebx
  805643:	8b 45 08             	mov    0x8(%ebp),%eax
  805646:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805649:	0f b7 58 28          	movzwl 0x28(%eax),%ebx
  80564d:	0f b7 f2             	movzwl %dx,%esi
  805650:	0f b7 cb             	movzwl %bx,%ecx
  805653:	01 f1                	add    %esi,%ecx
  805655:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  80565b:	76 0e                	jbe    80566b <tcp_recved+0x2d>
    pcb->rcv_wnd = TCP_WND;
  80565d:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805663:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805669:	eb 10                	jmp    80567b <tcp_recved+0x3d>
  } else {
    pcb->rcv_wnd += len;
  80566b:	01 da                	add    %ebx,%edx
  80566d:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805671:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805675:	72 04                	jb     80567b <tcp_recved+0x3d>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805677:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80567b:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  80567f:	f6 c2 03             	test   $0x3,%dl
  805682:	75 24                	jne    8056a8 <tcp_recved+0x6a>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  805684:	f6 c2 01             	test   $0x1,%dl
  805687:	74 17                	je     8056a0 <tcp_recved+0x62>
  805689:	83 e2 fe             	and    $0xfffffffe,%edx
  80568c:	83 ca 02             	or     $0x2,%edx
  80568f:	88 50 20             	mov    %dl,0x20(%eax)
  805692:	83 ec 0c             	sub    $0xc,%esp
  805695:	50                   	push   %eax
  805696:	e8 08 29 00 00       	call   807fa3 <tcp_output>
  80569b:	83 c4 10             	add    $0x10,%esp
  80569e:	eb 27                	jmp    8056c7 <tcp_recved+0x89>
  8056a0:	83 ca 01             	or     $0x1,%edx
  8056a3:	88 50 20             	mov    %dl,0x20(%eax)
  8056a6:	eb 1f                	jmp    8056c7 <tcp_recved+0x89>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8056a8:	f6 c2 01             	test   $0x1,%dl
  8056ab:	74 1a                	je     8056c7 <tcp_recved+0x89>
  8056ad:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8056b3:	76 12                	jbe    8056c7 <tcp_recved+0x89>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  8056b5:	83 ca 02             	or     $0x2,%edx
  8056b8:	88 50 20             	mov    %dl,0x20(%eax)
  8056bb:	83 ec 0c             	sub    $0xc,%esp
  8056be:	50                   	push   %eax
  8056bf:	e8 df 28 00 00       	call   807fa3 <tcp_output>
  8056c4:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  8056c7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056ca:	5b                   	pop    %ebx
  8056cb:	5e                   	pop    %esi
  8056cc:	5d                   	pop    %ebp
  8056cd:	c3                   	ret    

008056ce <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8056ce:	55                   	push   %ebp
  8056cf:	89 e5                	mov    %esp,%ebp
  8056d1:	53                   	push   %ebx
  8056d2:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8056d5:	8b 1d 7c b3 b3 00    	mov    0xb3b37c,%ebx
  8056db:	eb 5d                	jmp    80573a <tcp_fasttmr+0x6c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  8056dd:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8056e3:	85 c0                	test   %eax,%eax
  8056e5:	74 32                	je     805719 <tcp_fasttmr+0x4b>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8056e7:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  8056ed:	85 d2                	test   %edx,%edx
  8056ef:	74 12                	je     805703 <tcp_fasttmr+0x35>
  8056f1:	6a 00                	push   $0x0
  8056f3:	50                   	push   %eax
  8056f4:	53                   	push   %ebx
  8056f5:	ff 73 18             	pushl  0x18(%ebx)
  8056f8:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  8056fa:	83 c4 10             	add    $0x10,%esp
  8056fd:	84 c0                	test   %al,%al
  8056ff:	75 18                	jne    805719 <tcp_fasttmr+0x4b>
  805701:	eb 0c                	jmp    80570f <tcp_fasttmr+0x41>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805703:	83 ec 0c             	sub    $0xc,%esp
  805706:	50                   	push   %eax
  805707:	e8 e3 f0 ff ff       	call   8047ef <pbuf_free>
  80570c:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80570f:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805716:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805719:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80571d:	a8 01                	test   $0x1,%al
  80571f:	74 16                	je     805737 <tcp_fasttmr+0x69>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805721:	83 c8 02             	or     $0x2,%eax
  805724:	88 43 20             	mov    %al,0x20(%ebx)
  805727:	83 ec 0c             	sub    $0xc,%esp
  80572a:	53                   	push   %ebx
  80572b:	e8 73 28 00 00       	call   807fa3 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805730:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  805734:	83 c4 10             	add    $0x10,%esp
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805737:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80573a:	85 db                	test   %ebx,%ebx
  80573c:	75 9f                	jne    8056dd <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  80573e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805741:	c9                   	leave  
  805742:	c3                   	ret    

00805743 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805743:	55                   	push   %ebp
  805744:	89 e5                	mov    %esp,%ebp
  805746:	56                   	push   %esi
  805747:	53                   	push   %ebx
  805748:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  80574b:	85 db                	test   %ebx,%ebx
  80574d:	74 2a                	je     805779 <tcp_seg_free+0x36>
    if (seg->p != NULL) {
  80574f:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805752:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  805757:	85 c0                	test   %eax,%eax
  805759:	74 0e                	je     805769 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  80575b:	83 ec 0c             	sub    $0xc,%esp
  80575e:	50                   	push   %eax
  80575f:	e8 8b f0 ff ff       	call   8047ef <pbuf_free>
  805764:	89 c6                	mov    %eax,%esi
  805766:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805769:	83 ec 08             	sub    $0x8,%esp
  80576c:	53                   	push   %ebx
  80576d:	6a 04                	push   $0x4
  80576f:	e8 08 ed ff ff       	call   80447c <memp_free>
  805774:	83 c4 10             	add    $0x10,%esp
  805777:	eb 05                	jmp    80577e <tcp_seg_free+0x3b>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805779:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  80577e:	89 f0                	mov    %esi,%eax
  805780:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805783:	5b                   	pop    %ebx
  805784:	5e                   	pop    %esi
  805785:	5d                   	pop    %ebp
  805786:	c3                   	ret    

00805787 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  805787:	55                   	push   %ebp
  805788:	89 e5                	mov    %esp,%ebp
  80578a:	56                   	push   %esi
  80578b:	53                   	push   %ebx
  80578c:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t count = 0;
  80578f:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  805794:	eb 12                	jmp    8057a8 <tcp_segs_free+0x21>
    next = seg->next;
  805796:	8b 32                	mov    (%edx),%esi
    count += tcp_seg_free(seg);
  805798:	83 ec 0c             	sub    $0xc,%esp
  80579b:	52                   	push   %edx
  80579c:	e8 a2 ff ff ff       	call   805743 <tcp_seg_free>
  8057a1:	01 c3                	add    %eax,%ebx
  8057a3:	83 c4 10             	add    $0x10,%esp
    seg = next;
  8057a6:	89 f2                	mov    %esi,%edx
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  8057a8:	85 d2                	test   %edx,%edx
  8057aa:	75 ea                	jne    805796 <tcp_segs_free+0xf>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  8057ac:	89 d8                	mov    %ebx,%eax
  8057ae:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057b1:	5b                   	pop    %ebx
  8057b2:	5e                   	pop    %esi
  8057b3:	5d                   	pop    %ebp
  8057b4:	c3                   	ret    

008057b5 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8057b5:	55                   	push   %ebp
  8057b6:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8057b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8057be:	88 50 14             	mov    %dl,0x14(%eax)
}
  8057c1:	5d                   	pop    %ebp
  8057c2:	c3                   	ret    

008057c3 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8057c3:	55                   	push   %ebp
  8057c4:	89 e5                	mov    %esp,%ebp
  8057c6:	53                   	push   %ebx
  8057c7:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8057ca:	6a 04                	push   $0x4
  8057cc:	e8 55 ec ff ff       	call   804426 <memp_malloc>
  8057d1:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8057d3:	83 c4 10             	add    $0x10,%esp
  8057d6:	85 c0                	test   %eax,%eax
  8057d8:	74 1c                	je     8057f6 <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8057da:	83 ec 04             	sub    $0x4,%esp
  8057dd:	6a 14                	push   $0x14
  8057df:	ff 75 08             	pushl  0x8(%ebp)
  8057e2:	50                   	push   %eax
  8057e3:	e8 53 94 00 00       	call   80ec3b <memcpy>
  pbuf_ref(cseg->p);
  8057e8:	83 c4 04             	add    $0x4,%esp
  8057eb:	ff 73 04             	pushl  0x4(%ebx)
  8057ee:	e8 66 f4 ff ff       	call   804c59 <pbuf_ref>
  return cseg;
  8057f3:	83 c4 10             	add    $0x10,%esp
}
  8057f6:	89 d8                	mov    %ebx,%eax
  8057f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8057fb:	c9                   	leave  
  8057fc:	c3                   	ret    

008057fd <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8057fd:	55                   	push   %ebp
  8057fe:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805800:	8b 55 0c             	mov    0xc(%ebp),%edx
  805803:	8b 45 08             	mov    0x8(%ebp),%eax
  805806:	89 50 18             	mov    %edx,0x18(%eax)
}
  805809:	5d                   	pop    %ebp
  80580a:	c3                   	ret    

0080580b <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  80580b:	55                   	push   %ebp
  80580c:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  80580e:	8b 55 0c             	mov    0xc(%ebp),%edx
  805811:	8b 45 08             	mov    0x8(%ebp),%eax
  805814:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  80581a:	5d                   	pop    %ebp
  80581b:	c3                   	ret    

0080581c <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  80581c:	55                   	push   %ebp
  80581d:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  80581f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805822:	8b 45 08             	mov    0x8(%ebp),%eax
  805825:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  80582b:	5d                   	pop    %ebp
  80582c:	c3                   	ret    

0080582d <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  80582d:	55                   	push   %ebp
  80582e:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805830:	8b 55 0c             	mov    0xc(%ebp),%edx
  805833:	8b 45 08             	mov    0x8(%ebp),%eax
  805836:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  80583c:	5d                   	pop    %ebp
  80583d:	c3                   	ret    

0080583e <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  80583e:	55                   	push   %ebp
  80583f:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805841:	8b 55 0c             	mov    0xc(%ebp),%edx
  805844:	8b 45 08             	mov    0x8(%ebp),%eax
  805847:	89 50 20             	mov    %edx,0x20(%eax)
}
  80584a:	5d                   	pop    %ebp
  80584b:	c3                   	ret    

0080584c <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  80584c:	55                   	push   %ebp
  80584d:	89 e5                	mov    %esp,%ebp
  80584f:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805852:	8b 55 0c             	mov    0xc(%ebp),%edx
  805855:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  80585b:	8b 55 10             	mov    0x10(%ebp),%edx
  80585e:	88 50 31             	mov    %dl,0x31(%eax)
}
  805861:	5d                   	pop    %ebp
  805862:	c3                   	ret    

00805863 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805863:	55                   	push   %ebp
  805864:	89 e5                	mov    %esp,%ebp
  805866:	53                   	push   %ebx
  805867:	83 ec 04             	sub    $0x4,%esp
  80586a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  80586d:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805870:	83 f8 0a             	cmp    $0xa,%eax
  805873:	74 64                	je     8058d9 <tcp_pcb_purge+0x76>
  805875:	83 f8 01             	cmp    $0x1,%eax
  805878:	76 5f                	jbe    8058d9 <tcp_pcb_purge+0x76>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  80587a:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805880:	85 c0                	test   %eax,%eax
  805882:	74 16                	je     80589a <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  805884:	83 ec 0c             	sub    $0xc,%esp
  805887:	50                   	push   %eax
  805888:	e8 62 ef ff ff       	call   8047ef <pbuf_free>
      pcb->refused_data = NULL;
  80588d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805894:	00 00 00 
  805897:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  80589a:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  8058a0:	83 ec 0c             	sub    $0xc,%esp
  8058a3:	ff 73 7c             	pushl  0x7c(%ebx)
  8058a6:	e8 dc fe ff ff       	call   805787 <tcp_segs_free>
    pcb->ooseq = NULL;
  8058ab:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8058b2:	83 c4 04             	add    $0x4,%esp
  8058b5:	ff 73 74             	pushl  0x74(%ebx)
  8058b8:	e8 ca fe ff ff       	call   805787 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8058bd:	83 c4 04             	add    $0x4,%esp
  8058c0:	ff 73 78             	pushl  0x78(%ebx)
  8058c3:	e8 bf fe ff ff       	call   805787 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8058c8:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8058cf:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  8058d6:	83 c4 10             	add    $0x10,%esp
  }
}
  8058d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8058dc:	c9                   	leave  
  8058dd:	c3                   	ret    

008058de <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  8058de:	55                   	push   %ebp
  8058df:	89 e5                	mov    %esp,%ebp
  8058e1:	57                   	push   %edi
  8058e2:	56                   	push   %esi
  8058e3:	53                   	push   %ebx
  8058e4:	83 ec 0c             	sub    $0xc,%esp
  8058e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8058ea:	8b 7d 0c             	mov    0xc(%ebp),%edi
  TCP_RMV(pcblist, pcb);
  8058ed:	8b 10                	mov    (%eax),%edx
  8058ef:	39 fa                	cmp    %edi,%edx
  8058f1:	75 07                	jne    8058fa <tcp_pcb_remove+0x1c>
  8058f3:	8b 52 0c             	mov    0xc(%edx),%edx
  8058f6:	89 10                	mov    %edx,(%eax)
  8058f8:	eb 3b                	jmp    805935 <tcp_pcb_remove+0x57>
  8058fa:	89 15 88 b3 b3 00    	mov    %edx,0xb3b388
  805900:	eb 25                	jmp    805927 <tcp_pcb_remove+0x49>
  805902:	8b 42 0c             	mov    0xc(%edx),%eax
  805905:	39 c7                	cmp    %eax,%edi
  805907:	0f 94 c1             	sete   %cl
  80590a:	89 ce                	mov    %ecx,%esi
  80590c:	85 c0                	test   %eax,%eax
  80590e:	0f 95 c1             	setne  %cl
  805911:	89 f3                	mov    %esi,%ebx
  805913:	84 cb                	test   %cl,%bl
  805915:	74 0e                	je     805925 <tcp_pcb_remove+0x47>
  805917:	89 15 88 b3 b3 00    	mov    %edx,0xb3b388
  80591d:	8b 47 0c             	mov    0xc(%edi),%eax
  805920:	89 42 0c             	mov    %eax,0xc(%edx)
  805923:	eb 10                	jmp    805935 <tcp_pcb_remove+0x57>
  805925:	89 c2                	mov    %eax,%edx
  805927:	85 d2                	test   %edx,%edx
  805929:	75 d7                	jne    805902 <tcp_pcb_remove+0x24>
  80592b:	c7 05 88 b3 b3 00 00 	movl   $0x0,0xb3b388
  805932:	00 00 00 
  805935:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)

  tcp_pcb_purge(pcb);
  80593c:	83 ec 0c             	sub    $0xc,%esp
  80593f:	57                   	push   %edi
  805940:	e8 1e ff ff ff       	call   805863 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805945:	8b 47 10             	mov    0x10(%edi),%eax
  805948:	83 c4 10             	add    $0x10,%esp
  80594b:	83 f8 01             	cmp    $0x1,%eax
  80594e:	74 1f                	je     80596f <tcp_pcb_remove+0x91>
  805950:	83 f8 0a             	cmp    $0xa,%eax
  805953:	74 1a                	je     80596f <tcp_pcb_remove+0x91>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805955:	0f b6 47 20          	movzbl 0x20(%edi),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  805959:	a8 01                	test   $0x1,%al
  80595b:	74 12                	je     80596f <tcp_pcb_remove+0x91>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  80595d:	83 c8 02             	or     $0x2,%eax
  805960:	88 47 20             	mov    %al,0x20(%edi)
    tcp_output(pcb);
  805963:	83 ec 0c             	sub    $0xc,%esp
  805966:	57                   	push   %edi
  805967:	e8 37 26 00 00       	call   807fa3 <tcp_output>
  80596c:	83 c4 10             	add    $0x10,%esp
  }

  if (pcb->state != LISTEN) {
  80596f:	83 7f 10 01          	cmpl   $0x1,0x10(%edi)
  805973:	74 57                	je     8059cc <tcp_pcb_remove+0xee>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805975:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  805979:	74 17                	je     805992 <tcp_pcb_remove+0xb4>
  80597b:	83 ec 04             	sub    $0x4,%esp
  80597e:	68 fe 1c 81 00       	push   $0x811cfe
  805983:	68 b4 04 00 00       	push   $0x4b4
  805988:	68 ea 1c 81 00       	push   $0x811cea
  80598d:	e8 4f 8a 00 00       	call   80e3e1 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805992:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  805996:	74 17                	je     8059af <tcp_pcb_remove+0xd1>
  805998:	83 ec 04             	sub    $0x4,%esp
  80599b:	68 16 1d 81 00       	push   $0x811d16
  8059a0:	68 b5 04 00 00       	push   $0x4b5
  8059a5:	68 ea 1c 81 00       	push   $0x811cea
  8059aa:	e8 32 8a 00 00       	call   80e3e1 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8059af:	83 7f 7c 00          	cmpl   $0x0,0x7c(%edi)
  8059b3:	74 17                	je     8059cc <tcp_pcb_remove+0xee>
  8059b5:	83 ec 04             	sub    $0x4,%esp
  8059b8:	68 2f 1d 81 00       	push   $0x811d2f
  8059bd:	68 b7 04 00 00       	push   $0x4b7
  8059c2:	68 ea 1c 81 00       	push   $0x811cea
  8059c7:	e8 15 8a 00 00       	call   80e3e1 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8059cc:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  8059d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8059d6:	5b                   	pop    %ebx
  8059d7:	5e                   	pop    %esi
  8059d8:	5f                   	pop    %edi
  8059d9:	5d                   	pop    %ebp
  8059da:	c3                   	ret    

008059db <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8059db:	55                   	push   %ebp
  8059dc:	89 e5                	mov    %esp,%ebp
  8059de:	57                   	push   %edi
  8059df:	56                   	push   %esi
  8059e0:	53                   	push   %ebx
  8059e1:	83 ec 0c             	sub    $0xc,%esp
  8059e4:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8059e7:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8059eb:	0f 87 12 01 00 00    	ja     805b03 <tcp_close+0x128>
  8059f1:	8b 43 10             	mov    0x10(%ebx),%eax
  8059f4:	ff 24 85 48 1d 81 00 	jmp    *0x811d48(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8059fb:	8b 3d 8c b3 b3 00    	mov    0xb3b38c,%edi
  805a01:	39 df                	cmp    %ebx,%edi
  805a03:	75 0a                	jne    805a0f <tcp_close+0x34>
  805a05:	8b 47 0c             	mov    0xc(%edi),%eax
  805a08:	a3 8c b3 b3 00       	mov    %eax,0xb3b38c
  805a0d:	eb 3b                	jmp    805a4a <tcp_close+0x6f>
  805a0f:	89 3d 88 b3 b3 00    	mov    %edi,0xb3b388
  805a15:	eb 25                	jmp    805a3c <tcp_close+0x61>
  805a17:	8b 47 0c             	mov    0xc(%edi),%eax
  805a1a:	39 c3                	cmp    %eax,%ebx
  805a1c:	0f 94 c1             	sete   %cl
  805a1f:	89 ce                	mov    %ecx,%esi
  805a21:	85 c0                	test   %eax,%eax
  805a23:	0f 95 c1             	setne  %cl
  805a26:	89 f2                	mov    %esi,%edx
  805a28:	84 ca                	test   %cl,%dl
  805a2a:	74 0e                	je     805a3a <tcp_close+0x5f>
  805a2c:	89 3d 88 b3 b3 00    	mov    %edi,0xb3b388
  805a32:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a35:	89 47 0c             	mov    %eax,0xc(%edi)
  805a38:	eb 10                	jmp    805a4a <tcp_close+0x6f>
  805a3a:	89 c7                	mov    %eax,%edi
  805a3c:	85 ff                	test   %edi,%edi
  805a3e:	75 d7                	jne    805a17 <tcp_close+0x3c>
  805a40:	c7 05 88 b3 b3 00 00 	movl   $0x0,0xb3b388
  805a47:	00 00 00 
  805a4a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805a51:	83 ec 08             	sub    $0x8,%esp
  805a54:	53                   	push   %ebx
  805a55:	6a 02                	push   $0x2
  805a57:	e8 20 ea ff ff       	call   80447c <memp_free>
    pcb = NULL;
    break;
  805a5c:	83 c4 10             	add    $0x10,%esp
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  805a5f:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  805a64:	e9 bb 00 00 00       	jmp    805b24 <tcp_close+0x149>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805a69:	83 ec 08             	sub    $0x8,%esp
  805a6c:	53                   	push   %ebx
  805a6d:	68 84 b3 b3 00       	push   $0xb3b384
  805a72:	e8 67 fe ff ff       	call   8058de <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805a77:	83 c4 08             	add    $0x8,%esp
  805a7a:	53                   	push   %ebx
  805a7b:	6a 03                	push   $0x3
  805a7d:	e8 fa e9 ff ff       	call   80447c <memp_free>
    pcb = NULL;
    break;
  805a82:	83 c4 10             	add    $0x10,%esp
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  805a85:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  805a8a:	e9 95 00 00 00       	jmp    805b24 <tcp_close+0x149>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805a8f:	83 ec 08             	sub    $0x8,%esp
  805a92:	53                   	push   %ebx
  805a93:	68 7c b3 b3 00       	push   $0xb3b37c
  805a98:	e8 41 fe ff ff       	call   8058de <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805a9d:	83 c4 08             	add    $0x8,%esp
  805aa0:	53                   	push   %ebx
  805aa1:	6a 02                	push   $0x2
  805aa3:	e8 d4 e9 ff ff       	call   80447c <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805aa8:	83 c4 10             	add    $0x10,%esp
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  805aab:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805ab0:	eb 72                	jmp    805b24 <tcp_close+0x149>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805ab2:	83 ec 08             	sub    $0x8,%esp
  805ab5:	6a 01                	push   $0x1
  805ab7:	53                   	push   %ebx
  805ab8:	e8 74 24 00 00       	call   807f31 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805abd:	83 c4 10             	add    $0x10,%esp
  805ac0:	84 c0                	test   %al,%al
  805ac2:	75 60                	jne    805b24 <tcp_close+0x149>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  805ac4:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805acb:	eb 3b                	jmp    805b08 <tcp_close+0x12d>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805acd:	83 ec 08             	sub    $0x8,%esp
  805ad0:	6a 01                	push   $0x1
  805ad2:	53                   	push   %ebx
  805ad3:	e8 59 24 00 00       	call   807f31 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805ad8:	83 c4 10             	add    $0x10,%esp
  805adb:	84 c0                	test   %al,%al
  805add:	75 45                	jne    805b24 <tcp_close+0x149>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  805adf:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805ae6:	eb 20                	jmp    805b08 <tcp_close+0x12d>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805ae8:	83 ec 08             	sub    $0x8,%esp
  805aeb:	6a 01                	push   $0x1
  805aed:	53                   	push   %ebx
  805aee:	e8 3e 24 00 00       	call   807f31 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805af3:	83 c4 10             	add    $0x10,%esp
  805af6:	84 c0                	test   %al,%al
  805af8:	75 2a                	jne    805b24 <tcp_close+0x149>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  805afa:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805b01:	eb 05                	jmp    805b08 <tcp_close+0x12d>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  805b03:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  805b08:	85 db                	test   %ebx,%ebx
  805b0a:	74 13                	je     805b1f <tcp_close+0x144>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  805b0c:	83 ec 0c             	sub    $0xc,%esp
  805b0f:	53                   	push   %ebx
  805b10:	e8 8e 24 00 00       	call   807fa3 <tcp_output>
  805b15:	83 c4 10             	add    $0x10,%esp
  805b18:	b8 00 00 00 00       	mov    $0x0,%eax
  805b1d:	eb 05                	jmp    805b24 <tcp_close+0x149>
  805b1f:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  805b24:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805b27:	5b                   	pop    %ebx
  805b28:	5e                   	pop    %esi
  805b29:	5f                   	pop    %edi
  805b2a:	5d                   	pop    %ebp
  805b2b:	c3                   	ret    

00805b2c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  805b2c:	55                   	push   %ebp
  805b2d:	89 e5                	mov    %esp,%ebp
  805b2f:	83 ec 08             	sub    $0x8,%esp
  805b32:	8b 45 10             	mov    0x10(%ebp),%eax
  805b35:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  805b38:	85 c0                	test   %eax,%eax
  805b3a:	74 13                	je     805b4f <tcp_recv_null+0x23>
    pbuf_free(p);
  805b3c:	83 ec 0c             	sub    $0xc,%esp
  805b3f:	50                   	push   %eax
  805b40:	e8 aa ec ff ff       	call   8047ef <pbuf_free>
  805b45:	83 c4 10             	add    $0x10,%esp
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  805b48:	b8 00 00 00 00       	mov    $0x0,%eax
  805b4d:	eb 17                	jmp    805b66 <tcp_recv_null+0x3a>
  805b4f:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  805b54:	84 d2                	test   %dl,%dl
  805b56:	75 0e                	jne    805b66 <tcp_recv_null+0x3a>
    return tcp_close(pcb);
  805b58:	83 ec 0c             	sub    $0xc,%esp
  805b5b:	ff 75 0c             	pushl  0xc(%ebp)
  805b5e:	e8 78 fe ff ff       	call   8059db <tcp_close>
  805b63:	83 c4 10             	add    $0x10,%esp
  }
  return ERR_OK;
}
  805b66:	c9                   	leave  
  805b67:	c3                   	ret    

00805b68 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  805b68:	55                   	push   %ebp
  805b69:	89 e5                	mov    %esp,%ebp
  805b6b:	57                   	push   %edi
  805b6c:	56                   	push   %esi
  805b6d:	53                   	push   %ebx
  805b6e:	83 ec 2c             	sub    $0x2c,%esp
  805b71:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  805b74:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805b78:	75 21                	jne    805b9b <tcp_abort+0x33>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805b7a:	83 ec 08             	sub    $0x8,%esp
  805b7d:	53                   	push   %ebx
  805b7e:	68 90 b3 b3 00       	push   $0xb3b390
  805b83:	e8 56 fd ff ff       	call   8058de <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805b88:	83 c4 08             	add    $0x8,%esp
  805b8b:	53                   	push   %ebx
  805b8c:	6a 02                	push   $0x2
  805b8e:	e8 e9 e8 ff ff       	call   80447c <memp_free>
  805b93:	83 c4 10             	add    $0x10,%esp
  805b96:	e9 d1 00 00 00       	jmp    805c6c <tcp_abort+0x104>
  } else {
    seqno = pcb->snd_nxt;
  805b9b:	8b 43 54             	mov    0x54(%ebx),%eax
  805b9e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805ba1:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805ba4:	85 db                	test   %ebx,%ebx
  805ba6:	74 04                	je     805bac <tcp_abort+0x44>
  805ba8:	8b 03                	mov    (%ebx),%eax
  805baa:	eb 05                	jmp    805bb1 <tcp_abort+0x49>
  805bac:	b8 00 00 00 00       	mov    $0x0,%eax
  805bb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805bb4:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805bb7:	74 05                	je     805bbe <tcp_abort+0x56>
  805bb9:	8b 43 04             	mov    0x4(%ebx),%eax
  805bbc:	eb 05                	jmp    805bc3 <tcp_abort+0x5b>
  805bbe:	b8 00 00 00 00       	mov    $0x0,%eax
  805bc3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805bc6:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805bca:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805bce:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805bd2:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  805bd6:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  805bdc:	8b 43 18             	mov    0x18(%ebx),%eax
  805bdf:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805be2:	83 ec 08             	sub    $0x8,%esp
  805be5:	53                   	push   %ebx
  805be6:	68 7c b3 b3 00       	push   $0xb3b37c
  805beb:	e8 ee fc ff ff       	call   8058de <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805bf0:	8b 43 78             	mov    0x78(%ebx),%eax
  805bf3:	83 c4 10             	add    $0x10,%esp
  805bf6:	85 c0                	test   %eax,%eax
  805bf8:	74 0c                	je     805c06 <tcp_abort+0x9e>
      tcp_segs_free(pcb->unacked);
  805bfa:	83 ec 0c             	sub    $0xc,%esp
  805bfd:	50                   	push   %eax
  805bfe:	e8 84 fb ff ff       	call   805787 <tcp_segs_free>
  805c03:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unsent != NULL) {
  805c06:	8b 43 74             	mov    0x74(%ebx),%eax
  805c09:	85 c0                	test   %eax,%eax
  805c0b:	74 0c                	je     805c19 <tcp_abort+0xb1>
      tcp_segs_free(pcb->unsent);
  805c0d:	83 ec 0c             	sub    $0xc,%esp
  805c10:	50                   	push   %eax
  805c11:	e8 71 fb ff ff       	call   805787 <tcp_segs_free>
  805c16:	83 c4 10             	add    $0x10,%esp
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  805c19:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805c1c:	85 c0                	test   %eax,%eax
  805c1e:	74 0c                	je     805c2c <tcp_abort+0xc4>
      tcp_segs_free(pcb->ooseq);
  805c20:	83 ec 0c             	sub    $0xc,%esp
  805c23:	50                   	push   %eax
  805c24:	e8 5e fb ff ff       	call   805787 <tcp_segs_free>
  805c29:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  805c2c:	83 ec 08             	sub    $0x8,%esp
  805c2f:	53                   	push   %ebx
  805c30:	6a 02                	push   $0x2
  805c32:	e8 45 e8 ff ff       	call   80447c <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805c37:	83 c4 10             	add    $0x10,%esp
  805c3a:	85 f6                	test   %esi,%esi
  805c3c:	74 0d                	je     805c4b <tcp_abort+0xe3>
  805c3e:	83 ec 08             	sub    $0x8,%esp
  805c41:	6a fb                	push   $0xfffffffb
  805c43:	ff 75 cc             	pushl  -0x34(%ebp)
  805c46:	ff d6                	call   *%esi
  805c48:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805c4b:	83 ec 08             	sub    $0x8,%esp
  805c4e:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805c52:	50                   	push   %eax
  805c53:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805c57:	50                   	push   %eax
  805c58:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805c5b:	50                   	push   %eax
  805c5c:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805c5f:	50                   	push   %eax
  805c60:	57                   	push   %edi
  805c61:	ff 75 d4             	pushl  -0x2c(%ebp)
  805c64:	e8 b1 27 00 00       	call   80841a <tcp_rst>
  805c69:	83 c4 20             	add    $0x20,%esp
  }
}
  805c6c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805c6f:	5b                   	pop    %ebx
  805c70:	5e                   	pop    %esi
  805c71:	5f                   	pop    %edi
  805c72:	5d                   	pop    %ebp
  805c73:	c3                   	ret    

00805c74 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  805c74:	55                   	push   %ebp
  805c75:	89 e5                	mov    %esp,%ebp
  805c77:	57                   	push   %edi
  805c78:	56                   	push   %esi
  805c79:	53                   	push   %ebx
  805c7a:	83 ec 1c             	sub    $0x1c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  805c7d:	83 05 80 b3 b3 00 01 	addl   $0x1,0xb3b380

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  805c84:	8b 1d 7c b3 b3 00    	mov    0xb3b37c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  805c8a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  805c8e:	bf 00 00 00 00       	mov    $0x0,%edi
  805c93:	e9 57 03 00 00       	jmp    805fef <tcp_slowtmr+0x37b>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805c98:	8b 43 10             	mov    0x10(%ebx),%eax
  805c9b:	85 c0                	test   %eax,%eax
  805c9d:	75 17                	jne    805cb6 <tcp_slowtmr+0x42>
  805c9f:	83 ec 04             	sub    $0x4,%esp
  805ca2:	68 58 1b 81 00       	push   $0x811b58
  805ca7:	68 36 02 00 00       	push   $0x236
  805cac:	68 ea 1c 81 00       	push   $0x811cea
  805cb1:	e8 2b 87 00 00       	call   80e3e1 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805cb6:	83 f8 01             	cmp    $0x1,%eax
  805cb9:	75 17                	jne    805cd2 <tcp_slowtmr+0x5e>
  805cbb:	83 ec 04             	sub    $0x4,%esp
  805cbe:	68 84 1b 81 00       	push   $0x811b84
  805cc3:	68 37 02 00 00       	push   $0x237
  805cc8:	68 ea 1c 81 00       	push   $0x811cea
  805ccd:	e8 0f 87 00 00       	call   80e3e1 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805cd2:	83 f8 0a             	cmp    $0xa,%eax
  805cd5:	75 17                	jne    805cee <tcp_slowtmr+0x7a>
  805cd7:	83 ec 04             	sub    $0x4,%esp
  805cda:	68 b0 1b 81 00       	push   $0x811bb0
  805cdf:	68 38 02 00 00       	push   $0x238
  805ce4:	68 ea 1c 81 00       	push   $0x811cea
  805ce9:	e8 f3 86 00 00       	call   80e3e1 <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805cee:	83 f8 02             	cmp    $0x2,%eax
  805cf1:	75 12                	jne    805d05 <tcp_slowtmr+0x91>
  805cf3:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805cf7:	80 fa 06             	cmp    $0x6,%dl
  805cfa:	0f 85 b1 03 00 00    	jne    8060b1 <tcp_slowtmr+0x43d>
  805d00:	e9 a3 01 00 00       	jmp    805ea8 <tcp_slowtmr+0x234>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d05:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805d09:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d0e:	80 fa 0c             	cmp    $0xc,%dl
  805d11:	0f 84 f1 00 00 00    	je     805e08 <tcp_slowtmr+0x194>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  805d17:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  805d1e:	84 c9                	test   %cl,%cl
  805d20:	74 54                	je     805d76 <tcp_slowtmr+0x102>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  805d22:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805d28:	83 c0 01             	add    $0x1,%eax
  805d2b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805d31:	0f b6 d1             	movzbl %cl,%edx
  805d34:	0f b6 92 67 1d 81 00 	movzbl 0x811d67(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805d3b:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805d40:	39 d0                	cmp    %edx,%eax
  805d42:	0f 82 c0 00 00 00    	jb     805e08 <tcp_slowtmr+0x194>
          pcb->persist_cnt = 0;
  805d48:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805d4f:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805d52:	80 f9 06             	cmp    $0x6,%cl
  805d55:	77 09                	ja     805d60 <tcp_slowtmr+0xec>
            pcb->persist_backoff++;
  805d57:	83 c1 01             	add    $0x1,%ecx
  805d5a:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  805d60:	83 ec 0c             	sub    $0xc,%esp
  805d63:	53                   	push   %ebx
  805d64:	e8 9e 29 00 00       	call   808707 <tcp_zero_window_probe>
  805d69:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805d6c:	be 00 00 00 00       	mov    $0x0,%esi
  805d71:	e9 92 00 00 00       	jmp    805e08 <tcp_slowtmr+0x194>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  805d76:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805d7a:	66 85 c9             	test   %cx,%cx
  805d7d:	78 07                	js     805d86 <tcp_slowtmr+0x112>
          ++pcb->rtime;
  805d7f:	83 c1 01             	add    $0x1,%ecx
  805d82:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805d86:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805d8a:	74 77                	je     805e03 <tcp_slowtmr+0x18f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805d8c:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805d91:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  805d95:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  805d99:	7c 6d                	jl     805e08 <tcp_slowtmr+0x194>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  805d9b:	83 f8 02             	cmp    $0x2,%eax
  805d9e:	74 1f                	je     805dbf <tcp_slowtmr+0x14b>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805da0:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805da4:	66 c1 f8 03          	sar    $0x3,%ax
  805da8:	98                   	cwtl   
  805da9:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805dad:	01 c8                	add    %ecx,%eax
  805daf:	0f b6 d2             	movzbl %dl,%edx
  805db2:	0f b6 8a 6f 1d 81 00 	movzbl 0x811d6f(%edx),%ecx
  805db9:	d3 e0                	shl    %cl,%eax
  805dbb:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  805dbf:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805dc5:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  805dc9:	66 39 43 4e          	cmp    %ax,0x4e(%ebx)
  805dcd:	66 0f 46 43 4e       	cmovbe 0x4e(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805dd2:	66 d1 e8             	shr    %ax
  805dd5:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  805dd9:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  805ddd:	66 39 d0             	cmp    %dx,%ax
  805de0:	73 06                	jae    805de8 <tcp_slowtmr+0x174>
            pcb->ssthresh = pcb->mss * 2;
  805de2:	01 d2                	add    %edx,%edx
  805de4:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  805de8:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  805dec:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  805df0:	83 ec 0c             	sub    $0xc,%esp
  805df3:	53                   	push   %ebx
  805df4:	e8 46 27 00 00       	call   80853f <tcp_rexmit_rto>
  805df9:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805dfc:	be 00 00 00 00       	mov    $0x0,%esi
  805e01:	eb 05                	jmp    805e08 <tcp_slowtmr+0x194>
  805e03:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  805e08:	8b 43 10             	mov    0x10(%ebx),%eax
  805e0b:	83 f8 06             	cmp    $0x6,%eax
  805e0e:	75 21                	jne    805e31 <tcp_slowtmr+0x1bd>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e10:	a1 80 b3 b3 00       	mov    0xb3b380,%eax
  805e15:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805e18:	83 f8 29             	cmp    $0x29,%eax
  805e1b:	89 f0                	mov    %esi,%eax
  805e1d:	1c ff                	sbb    $0xff,%al
  805e1f:	89 c6                	mov    %eax,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805e21:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e24:	85 c9                	test   %ecx,%ecx
  805e26:	0f 85 8f 00 00 00    	jne    805ebb <tcp_slowtmr+0x247>
  805e2c:	e9 e6 00 00 00       	jmp    805f17 <tcp_slowtmr+0x2a3>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805e31:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805e35:	74 7d                	je     805eb4 <tcp_slowtmr+0x240>
  805e37:	83 f8 07             	cmp    $0x7,%eax
  805e3a:	74 05                	je     805e41 <tcp_slowtmr+0x1cd>
  805e3c:	83 f8 04             	cmp    $0x4,%eax
  805e3f:	75 73                	jne    805eb4 <tcp_slowtmr+0x240>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805e41:	a1 80 b3 b3 00       	mov    0xb3b380,%eax
  805e46:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805e49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805e4c:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  805e52:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  805e58:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805e5d:	f7 e2                	mul    %edx
  805e5f:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805e62:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805e65:	76 0e                	jbe    805e75 <tcp_slowtmr+0x201>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  805e67:	83 ec 0c             	sub    $0xc,%esp
  805e6a:	53                   	push   %ebx
  805e6b:	e8 f8 fc ff ff       	call   805b68 <tcp_abort>
  805e70:	83 c4 10             	add    $0x10,%esp
  805e73:	eb 3f                	jmp    805eb4 <tcp_slowtmr+0x240>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  805e75:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805e7c:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805e82:	01 ca                	add    %ecx,%edx
              / TCP_SLOW_INTERVAL)
  805e84:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805e89:	f7 e2                	mul    %edx
  805e8b:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805e8e:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805e91:	76 21                	jbe    805eb4 <tcp_slowtmr+0x240>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  805e93:	83 ec 0c             	sub    $0xc,%esp
  805e96:	53                   	push   %ebx
  805e97:	e8 49 27 00 00       	call   8085e5 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805e9c:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805ea3:	83 c4 10             	add    $0x10,%esp
  805ea6:	eb 0c                	jmp    805eb4 <tcp_slowtmr+0x240>
  805ea8:	be 01 00 00 00       	mov    $0x1,%esi
  805ead:	eb 05                	jmp    805eb4 <tcp_slowtmr+0x240>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805eaf:	be 01 00 00 00       	mov    $0x1,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805eb4:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805eb7:	85 c9                	test   %ecx,%ecx
  805eb9:	74 29                	je     805ee4 <tcp_slowtmr+0x270>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805ebb:	8b 15 80 b3 b3 00    	mov    0xb3b380,%edx
  805ec1:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805ec4:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805ec8:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805ecb:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805ecd:	39 c2                	cmp    %eax,%edx
  805ecf:	72 13                	jb     805ee4 <tcp_slowtmr+0x270>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  805ed1:	83 ec 0c             	sub    $0xc,%esp
  805ed4:	51                   	push   %ecx
  805ed5:	e8 ad f8 ff ff       	call   805787 <tcp_segs_free>
      pcb->ooseq = NULL;
  805eda:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805ee1:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  805ee4:	8b 43 10             	mov    0x10(%ebx),%eax
  805ee7:	83 f8 03             	cmp    $0x3,%eax
  805eea:	75 13                	jne    805eff <tcp_slowtmr+0x28b>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805eec:	a1 80 b3 b3 00       	mov    0xb3b380,%eax
  805ef1:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805ef4:	83 f8 29             	cmp    $0x29,%eax
  805ef7:	89 f0                	mov    %esi,%eax
  805ef9:	1c ff                	sbb    $0xff,%al
  805efb:	89 c6                	mov    %eax,%esi
  805efd:	eb 18                	jmp    805f17 <tcp_slowtmr+0x2a3>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  805eff:	83 f8 09             	cmp    $0x9,%eax
  805f02:	75 13                	jne    805f17 <tcp_slowtmr+0x2a3>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805f04:	a1 80 b3 b3 00       	mov    0xb3b380,%eax
  805f09:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805f0c:	3d f1 00 00 00       	cmp    $0xf1,%eax
  805f11:	89 f0                	mov    %esi,%eax
  805f13:	1c ff                	sbb    $0xff,%al
  805f15:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  805f17:	89 f0                	mov    %esi,%eax
  805f19:	84 c0                	test   %al,%al
  805f1b:	0f 84 8b 00 00 00    	je     805fac <tcp_slowtmr+0x338>
      tcp_pcb_purge(pcb);      
  805f21:	83 ec 0c             	sub    $0xc,%esp
  805f24:	53                   	push   %ebx
  805f25:	e8 39 f9 ff ff       	call   805863 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  805f2a:	83 c4 10             	add    $0x10,%esp
  805f2d:	85 ff                	test   %edi,%edi
  805f2f:	74 27                	je     805f58 <tcp_slowtmr+0x2e4>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805f31:	3b 1d 7c b3 b3 00    	cmp    0xb3b37c,%ebx
  805f37:	75 17                	jne    805f50 <tcp_slowtmr+0x2dc>
  805f39:	83 ec 04             	sub    $0x4,%esp
  805f3c:	68 e0 1b 81 00       	push   $0x811be0
  805f41:	68 c1 02 00 00       	push   $0x2c1
  805f46:	68 ea 1c 81 00       	push   $0x811cea
  805f4b:	e8 91 84 00 00       	call   80e3e1 <_panic>
        prev->next = pcb->next;
  805f50:	8b 43 0c             	mov    0xc(%ebx),%eax
  805f53:	89 47 0c             	mov    %eax,0xc(%edi)
  805f56:	eb 28                	jmp    805f80 <tcp_slowtmr+0x30c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805f58:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
  805f5d:	39 d8                	cmp    %ebx,%eax
  805f5f:	74 17                	je     805f78 <tcp_slowtmr+0x304>
  805f61:	83 ec 04             	sub    $0x4,%esp
  805f64:	68 0c 1c 81 00       	push   $0x811c0c
  805f69:	68 c5 02 00 00       	push   $0x2c5
  805f6e:	68 ea 1c 81 00       	push   $0x811cea
  805f73:	e8 69 84 00 00       	call   80e3e1 <_panic>
        tcp_active_pcbs = pcb->next;
  805f78:	8b 40 0c             	mov    0xc(%eax),%eax
  805f7b:	a3 7c b3 b3 00       	mov    %eax,0xb3b37c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805f80:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805f86:	85 c0                	test   %eax,%eax
  805f88:	74 0d                	je     805f97 <tcp_slowtmr+0x323>
  805f8a:	83 ec 08             	sub    $0x8,%esp
  805f8d:	6a fb                	push   $0xfffffffb
  805f8f:	ff 73 18             	pushl  0x18(%ebx)
  805f92:	ff d0                	call   *%eax
  805f94:	83 c4 10             	add    $0x10,%esp

      pcb2 = pcb->next;
  805f97:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805f9a:	83 ec 08             	sub    $0x8,%esp
  805f9d:	53                   	push   %ebx
  805f9e:	6a 02                	push   $0x2
  805fa0:	e8 d7 e4 ff ff       	call   80447c <memp_free>
  805fa5:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805fa8:	89 f3                	mov    %esi,%ebx
  805faa:	eb 43                	jmp    805fef <tcp_slowtmr+0x37b>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  805fac:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805fb0:	83 c0 01             	add    $0x1,%eax
  805fb3:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805fb6:	3a 43 31             	cmp    0x31(%ebx),%al
  805fb9:	72 2f                	jb     805fea <tcp_slowtmr+0x376>
        pcb->polltmr = 0;
  805fbb:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  805fbf:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805fc5:	85 c0                	test   %eax,%eax
  805fc7:	74 0f                	je     805fd8 <tcp_slowtmr+0x364>
  805fc9:	83 ec 08             	sub    $0x8,%esp
  805fcc:	53                   	push   %ebx
  805fcd:	ff 73 18             	pushl  0x18(%ebx)
  805fd0:	ff d0                	call   *%eax
  805fd2:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805fd5:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805fd8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805fdc:	75 0c                	jne    805fea <tcp_slowtmr+0x376>
          tcp_output(pcb);
  805fde:	83 ec 0c             	sub    $0xc,%esp
  805fe1:	53                   	push   %ebx
  805fe2:	e8 bc 1f 00 00       	call   807fa3 <tcp_output>
  805fe7:	83 c4 10             	add    $0x10,%esp
        }
      }
      
      prev = pcb;
  805fea:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  805fec:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  805fef:	85 db                	test   %ebx,%ebx
  805ff1:	0f 85 a1 fc ff ff    	jne    805c98 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  805ff7:	8b 35 90 b3 b3 00    	mov    0xb3b390,%esi
  while (pcb != NULL) {
  805ffd:	e9 a5 00 00 00       	jmp    8060a7 <tcp_slowtmr+0x433>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806002:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806006:	74 17                	je     80601f <tcp_slowtmr+0x3ab>
  806008:	83 ec 04             	sub    $0x4,%esp
  80600b:	68 38 1c 81 00       	push   $0x811c38
  806010:	68 e5 02 00 00       	push   $0x2e5
  806015:	68 ea 1c 81 00       	push   $0x811cea
  80601a:	e8 c2 83 00 00       	call   80e3e1 <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80601f:	a1 80 b3 b3 00       	mov    0xb3b380,%eax
  806024:	2b 46 2c             	sub    0x2c(%esi),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  806027:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80602c:	76 74                	jbe    8060a2 <tcp_slowtmr+0x42e>
      tcp_pcb_purge(pcb);      
  80602e:	83 ec 0c             	sub    $0xc,%esp
  806031:	56                   	push   %esi
  806032:	e8 2c f8 ff ff       	call   805863 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  806037:	83 c4 10             	add    $0x10,%esp
  80603a:	85 db                	test   %ebx,%ebx
  80603c:	74 27                	je     806065 <tcp_slowtmr+0x3f1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80603e:	3b 35 90 b3 b3 00    	cmp    0xb3b390,%esi
  806044:	75 17                	jne    80605d <tcp_slowtmr+0x3e9>
  806046:	83 ec 04             	sub    $0x4,%esp
  806049:	68 68 1c 81 00       	push   $0x811c68
  80604e:	68 f4 02 00 00       	push   $0x2f4
  806053:	68 ea 1c 81 00       	push   $0x811cea
  806058:	e8 84 83 00 00       	call   80e3e1 <_panic>
        prev->next = pcb->next;
  80605d:	8b 46 0c             	mov    0xc(%esi),%eax
  806060:	89 43 0c             	mov    %eax,0xc(%ebx)
  806063:	eb 28                	jmp    80608d <tcp_slowtmr+0x419>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806065:	a1 90 b3 b3 00       	mov    0xb3b390,%eax
  80606a:	39 f0                	cmp    %esi,%eax
  80606c:	74 17                	je     806085 <tcp_slowtmr+0x411>
  80606e:	83 ec 04             	sub    $0x4,%esp
  806071:	68 90 1c 81 00       	push   $0x811c90
  806076:	68 f8 02 00 00       	push   $0x2f8
  80607b:	68 ea 1c 81 00       	push   $0x811cea
  806080:	e8 5c 83 00 00       	call   80e3e1 <_panic>
        tcp_tw_pcbs = pcb->next;
  806085:	8b 40 0c             	mov    0xc(%eax),%eax
  806088:	a3 90 b3 b3 00       	mov    %eax,0xb3b390
      }
      pcb2 = pcb->next;
  80608d:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806090:	83 ec 08             	sub    $0x8,%esp
  806093:	56                   	push   %esi
  806094:	6a 02                	push   $0x2
  806096:	e8 e1 e3 ff ff       	call   80447c <memp_free>
  80609b:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  80609e:	89 fe                	mov    %edi,%esi
  8060a0:	eb 05                	jmp    8060a7 <tcp_slowtmr+0x433>
    } else {
      prev = pcb;
  8060a2:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  8060a4:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8060a7:	85 f6                	test   %esi,%esi
  8060a9:	0f 85 53 ff ff ff    	jne    806002 <tcp_slowtmr+0x38e>
  8060af:	eb 0e                	jmp    8060bf <tcp_slowtmr+0x44b>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  8060b1:	80 fa 0c             	cmp    $0xc,%dl
  8060b4:	0f 85 5d fc ff ff    	jne    805d17 <tcp_slowtmr+0xa3>
  8060ba:	e9 f0 fd ff ff       	jmp    805eaf <tcp_slowtmr+0x23b>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8060bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8060c2:	5b                   	pop    %ebx
  8060c3:	5e                   	pop    %esi
  8060c4:	5f                   	pop    %edi
  8060c5:	5d                   	pop    %ebp
  8060c6:	c3                   	ret    

008060c7 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  8060c7:	55                   	push   %ebp
  8060c8:	89 e5                	mov    %esp,%ebp
  8060ca:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8060cd:	e8 fc f5 ff ff       	call   8056ce <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8060d2:	0f b6 05 b9 44 b3 00 	movzbl 0xb344b9,%eax
  8060d9:	83 c0 01             	add    $0x1,%eax
  8060dc:	a2 b9 44 b3 00       	mov    %al,0xb344b9
  8060e1:	a8 01                	test   $0x1,%al
  8060e3:	74 05                	je     8060ea <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8060e5:	e8 8a fb ff ff       	call   805c74 <tcp_slowtmr>
  }
}
  8060ea:	c9                   	leave  
  8060eb:	c3                   	ret    

008060ec <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  8060ec:	55                   	push   %ebp
  8060ed:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8060ef:	a1 08 40 81 00       	mov    0x814008,%eax
  8060f4:	03 05 80 b3 b3 00    	add    0xb3b380,%eax
  8060fa:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  8060ff:	5d                   	pop    %ebp
  806100:	c3                   	ret    

00806101 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  806101:	55                   	push   %ebp
  806102:	89 e5                	mov    %esp,%ebp
  806104:	57                   	push   %edi
  806105:	56                   	push   %esi
  806106:	53                   	push   %ebx
  806107:	83 ec 28             	sub    $0x28,%esp
  80610a:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  80610e:	6a 02                	push   $0x2
  806110:	e8 11 e3 ff ff       	call   804426 <memp_malloc>
  806115:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  806117:	83 c4 10             	add    $0x10,%esp
  80611a:	85 c0                	test   %eax,%eax
  80611c:	0f 85 bd 00 00 00    	jne    8061df <tcp_alloc+0xde>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806122:	a1 90 b3 b3 00       	mov    0xb3b390,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806127:	8b 35 80 b3 b3 00    	mov    0xb3b380,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  80612d:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  806132:	bf 00 00 00 00       	mov    $0x0,%edi
  806137:	eb 10                	jmp    806149 <tcp_alloc+0x48>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806139:	89 f2                	mov    %esi,%edx
  80613b:	2b 50 2c             	sub    0x2c(%eax),%edx
  80613e:	39 ca                	cmp    %ecx,%edx
  806140:	72 04                	jb     806146 <tcp_alloc+0x45>
      inactivity = tcp_ticks - pcb->tmr;
  806142:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  806144:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806146:	8b 40 0c             	mov    0xc(%eax),%eax
  806149:	85 c0                	test   %eax,%eax
  80614b:	75 ec                	jne    806139 <tcp_alloc+0x38>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  80614d:	85 ff                	test   %edi,%edi
  80614f:	74 0c                	je     80615d <tcp_alloc+0x5c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806151:	83 ec 0c             	sub    $0xc,%esp
  806154:	57                   	push   %edi
  806155:	e8 0e fa ff ff       	call   805b68 <tcp_abort>
  80615a:	83 c4 10             	add    $0x10,%esp
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  80615d:	83 ec 0c             	sub    $0xc,%esp
  806160:	6a 02                	push   $0x2
  806162:	e8 bf e2 ff ff       	call   804426 <memp_malloc>
  806167:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  806169:	83 c4 10             	add    $0x10,%esp
  80616c:	85 c0                	test   %eax,%eax
  80616e:	75 6f                	jne    8061df <tcp_alloc+0xde>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806170:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806175:	8b 3d 80 b3 b3 00    	mov    0xb3b380,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  80617b:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  806180:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  inactive = NULL;
  806187:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80618e:	eb 21                	jmp    8061b1 <tcp_alloc+0xb0>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  806190:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  806194:	38 ca                	cmp    %cl,%dl
  806196:	77 16                	ja     8061ae <tcp_alloc+0xad>
  806198:	38 d3                	cmp    %dl,%bl
  80619a:	72 12                	jb     8061ae <tcp_alloc+0xad>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80619c:	89 fe                	mov    %edi,%esi
  80619e:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  8061a1:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  8061a4:	72 08                	jb     8061ae <tcp_alloc+0xad>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  8061a6:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  8061a8:	89 75 e4             	mov    %esi,-0x1c(%ebp)
      inactive = pcb;
  8061ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8061ae:	8b 40 0c             	mov    0xc(%eax),%eax
  8061b1:	85 c0                	test   %eax,%eax
  8061b3:	75 db                	jne    806190 <tcp_alloc+0x8f>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  8061b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8061b8:	85 c0                	test   %eax,%eax
  8061ba:	74 0c                	je     8061c8 <tcp_alloc+0xc7>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8061bc:	83 ec 0c             	sub    $0xc,%esp
  8061bf:	50                   	push   %eax
  8061c0:	e8 a3 f9 ff ff       	call   805b68 <tcp_abort>
  8061c5:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  8061c8:	83 ec 0c             	sub    $0xc,%esp
  8061cb:	6a 02                	push   $0x2
  8061cd:	e8 54 e2 ff ff       	call   804426 <memp_malloc>
  8061d2:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  8061d4:	83 c4 10             	add    $0x10,%esp
  8061d7:	85 c0                	test   %eax,%eax
  8061d9:	0f 84 96 00 00 00    	je     806275 <tcp_alloc+0x174>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8061df:	83 ec 04             	sub    $0x4,%esp
  8061e2:	68 a8 00 00 00       	push   $0xa8
  8061e7:	6a 00                	push   $0x0
  8061e9:	56                   	push   %esi
  8061ea:	e8 97 89 00 00       	call   80eb86 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8061ef:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  8061f3:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  8061f9:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  8061ff:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  806205:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  80620b:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  80620f:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806213:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  806219:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  80621f:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  806225:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  80622b:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  806231:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  806237:	e8 b0 fe ff ff       	call   8060ec <tcp_next_iss>
    pcb->snd_wl2 = iss;
  80623c:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  80623f:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  806242:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  806245:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  806248:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  80624b:	a1 80 b3 b3 00       	mov    0xb3b380,%eax
  806250:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  806253:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  806257:	c7 86 88 00 00 00 2c 	movl   $0x805b2c,0x88(%esi)
  80625e:	5b 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  806261:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  806268:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  80626b:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  806272:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  806275:	89 f0                	mov    %esi,%eax
  806277:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80627a:	5b                   	pop    %ebx
  80627b:	5e                   	pop    %esi
  80627c:	5f                   	pop    %edi
  80627d:	5d                   	pop    %ebp
  80627e:	c3                   	ret    

0080627f <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  80627f:	55                   	push   %ebp
  806280:	89 e5                	mov    %esp,%ebp
  806282:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806285:	6a 40                	push   $0x40
  806287:	e8 75 fe ff ff       	call   806101 <tcp_alloc>
}
  80628c:	c9                   	leave  
  80628d:	c3                   	ret    

0080628e <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  80628e:	55                   	push   %ebp
  80628f:	89 e5                	mov    %esp,%ebp
  806291:	56                   	push   %esi
  806292:	53                   	push   %ebx
  806293:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806296:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806298:	83 ec 0c             	sub    $0xc,%esp
  80629b:	ff 75 0c             	pushl  0xc(%ebp)
  80629e:	e8 d5 01 00 00       	call   806478 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8062a3:	83 c4 10             	add    $0x10,%esp
  8062a6:	85 c0                	test   %eax,%eax
  8062a8:	74 14                	je     8062be <tcp_eff_send_mss+0x30>
  8062aa:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
  8062ae:	66 85 d2             	test   %dx,%dx
  8062b1:	74 0b                	je     8062be <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  8062b3:	83 ea 28             	sub    $0x28,%edx
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8062b6:	66 39 d3             	cmp    %dx,%bx
  8062b9:	89 d6                	mov    %edx,%esi
  8062bb:	0f 46 f3             	cmovbe %ebx,%esi
  }
  return sendmss;
}
  8062be:	89 f0                	mov    %esi,%eax
  8062c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8062c3:	5b                   	pop    %ebx
  8062c4:	5e                   	pop    %esi
  8062c5:	5d                   	pop    %ebp
  8062c6:	c3                   	ret    

008062c7 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  8062c7:	55                   	push   %ebp
  8062c8:	89 e5                	mov    %esp,%ebp
  8062ca:	57                   	push   %edi
  8062cb:	56                   	push   %esi
  8062cc:	53                   	push   %ebx
  8062cd:	83 ec 1c             	sub    $0x1c,%esp
  8062d0:	8b 7d 08             	mov    0x8(%ebp),%edi
  8062d3:	8b 75 0c             	mov    0xc(%ebp),%esi
  8062d6:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8062d9:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
  8062dd:	74 17                	je     8062f6 <tcp_connect+0x2f>
  8062df:	83 ec 04             	sub    $0x4,%esp
  8062e2:	68 b8 1c 81 00       	push   $0x811cb8
  8062e7:	68 ec 01 00 00       	push   $0x1ec
  8062ec:	68 ea 1c 81 00       	push   $0x811cea
  8062f1:	e8 eb 80 00 00       	call   80e3e1 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  8062f6:	85 f6                	test   %esi,%esi
  8062f8:	0f 84 21 01 00 00    	je     80641f <tcp_connect+0x158>
    pcb->remote_ip = *ipaddr;
  8062fe:	8b 16                	mov    (%esi),%edx
  806300:	89 57 04             	mov    %edx,0x4(%edi)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  806303:	66 89 47 1e          	mov    %ax,0x1e(%edi)
  if (pcb->local_port == 0) {
  806307:	66 83 7f 1c 00       	cmpw   $0x0,0x1c(%edi)
  80630c:	75 09                	jne    806317 <tcp_connect+0x50>
    pcb->local_port = tcp_new_port();
  80630e:	e8 f9 ef ff ff       	call   80530c <tcp_new_port>
  806313:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  }
  iss = tcp_next_iss();
  806317:	e8 d0 fd ff ff       	call   8060ec <tcp_next_iss>
  pcb->rcv_nxt = 0;
  80631c:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%edi)
  pcb->snd_nxt = iss;
  806323:	89 47 54             	mov    %eax,0x54(%edi)
  pcb->lastack = iss - 1;
  806326:	83 e8 01             	sub    $0x1,%eax
  806329:	89 47 48             	mov    %eax,0x48(%edi)
  pcb->snd_lbb = iss - 1;
  80632c:	89 47 68             	mov    %eax,0x68(%edi)
  pcb->rcv_wnd = TCP_WND;
  80632f:	66 c7 47 28 c0 5d    	movw   $0x5dc0,0x28(%edi)
  pcb->rcv_ann_wnd = TCP_WND;
  806335:	66 c7 47 2a c0 5d    	movw   $0x5dc0,0x2a(%edi)
  pcb->snd_wnd = TCP_WND;
  80633b:	66 c7 47 5c c0 5d    	movw   $0x5dc0,0x5c(%edi)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806341:	66 c7 47 34 18 02    	movw   $0x218,0x34(%edi)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806347:	83 ec 08             	sub    $0x8,%esp
  80634a:	56                   	push   %esi
  80634b:	68 18 02 00 00       	push   $0x218
  806350:	e8 39 ff ff ff       	call   80628e <tcp_eff_send_mss>
  806355:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  806359:	66 c7 47 4e 01 00    	movw   $0x1,0x4e(%edi)
  pcb->ssthresh = pcb->mss * 10;
  80635f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  806362:	01 c0                	add    %eax,%eax
  806364:	66 89 47 50          	mov    %ax,0x50(%edi)
  pcb->state = SYN_SENT;
  806368:	c7 47 10 02 00 00 00 	movl   $0x2,0x10(%edi)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80636f:	8b 45 14             	mov    0x14(%ebp),%eax
  806372:	89 87 8c 00 00 00    	mov    %eax,0x8c(%edi)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806378:	8b 15 8c b3 b3 00    	mov    0xb3b38c,%edx
  80637e:	83 c4 10             	add    $0x10,%esp
  806381:	39 fa                	cmp    %edi,%edx
  806383:	75 0a                	jne    80638f <tcp_connect+0xc8>
  806385:	8b 42 0c             	mov    0xc(%edx),%eax
  806388:	a3 8c b3 b3 00       	mov    %eax,0xb3b38c
  80638d:	eb 3b                	jmp    8063ca <tcp_connect+0x103>
  80638f:	89 15 88 b3 b3 00    	mov    %edx,0xb3b388
  806395:	eb 25                	jmp    8063bc <tcp_connect+0xf5>
  806397:	8b 42 0c             	mov    0xc(%edx),%eax
  80639a:	39 c7                	cmp    %eax,%edi
  80639c:	0f 94 c1             	sete   %cl
  80639f:	89 ce                	mov    %ecx,%esi
  8063a1:	85 c0                	test   %eax,%eax
  8063a3:	0f 95 c1             	setne  %cl
  8063a6:	89 f3                	mov    %esi,%ebx
  8063a8:	84 cb                	test   %cl,%bl
  8063aa:	74 0e                	je     8063ba <tcp_connect+0xf3>
  8063ac:	89 15 88 b3 b3 00    	mov    %edx,0xb3b388
  8063b2:	8b 47 0c             	mov    0xc(%edi),%eax
  8063b5:	89 42 0c             	mov    %eax,0xc(%edx)
  8063b8:	eb 10                	jmp    8063ca <tcp_connect+0x103>
  8063ba:	89 c2                	mov    %eax,%edx
  8063bc:	85 d2                	test   %edx,%edx
  8063be:	75 d7                	jne    806397 <tcp_connect+0xd0>
  8063c0:	c7 05 88 b3 b3 00 00 	movl   $0x0,0xb3b388
  8063c7:	00 00 00 
  TCP_REG(&tcp_active_pcbs, pcb);
  8063ca:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
  8063cf:	89 47 0c             	mov    %eax,0xc(%edi)
  8063d2:	89 3d 7c b3 b3 00    	mov    %edi,0xb3b37c
  8063d8:	e8 5c be ff ff       	call   802239 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  8063dd:	83 ec 0c             	sub    $0xc,%esp
  8063e0:	68 b4 05 04 02       	push   $0x20405b4
  8063e5:	e8 7d 12 00 00       	call   807667 <htonl>
  8063ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  8063ed:	83 c4 0c             	add    $0xc,%esp
  8063f0:	6a 04                	push   $0x4
  8063f2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8063f5:	50                   	push   %eax
  8063f6:	6a 00                	push   $0x0
  8063f8:	6a 02                	push   $0x2
  8063fa:	6a 00                	push   $0x0
  8063fc:	6a 00                	push   $0x0
  8063fe:	57                   	push   %edi
  8063ff:	e8 aa 14 00 00       	call   8078ae <tcp_enqueue>
  806404:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806406:	83 c4 20             	add    $0x20,%esp
  806409:	89 f3                	mov    %esi,%ebx
  80640b:	84 db                	test   %bl,%bl
  80640d:	75 15                	jne    806424 <tcp_connect+0x15d>
    tcp_output(pcb);
  80640f:	83 ec 0c             	sub    $0xc,%esp
  806412:	57                   	push   %edi
  806413:	e8 8b 1b 00 00       	call   807fa3 <tcp_output>
  806418:	83 c4 10             	add    $0x10,%esp
  }
  return ret;
  80641b:	89 f0                	mov    %esi,%eax
  80641d:	eb 05                	jmp    806424 <tcp_connect+0x15d>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80641f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  806424:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806427:	5b                   	pop    %ebx
  806428:	5e                   	pop    %esi
  806429:	5f                   	pop    %edi
  80642a:	5d                   	pop    %ebp
  80642b:	c3                   	ret    

0080642c <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80642c:	55                   	push   %ebp
  80642d:	89 e5                	mov    %esp,%ebp
  80642f:	53                   	push   %ebx
  806430:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806433:	8b 45 08             	mov    0x8(%ebp),%eax
  806436:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806438:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80643b:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806440:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806443:	77 30                	ja     806475 <ip_addr_isbroadcast+0x49>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806445:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  806449:	83 e0 02             	and    $0x2,%eax
  80644c:	74 27                	je     806475 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  80644e:	8b 41 04             	mov    0x4(%ecx),%eax
  806451:	39 d0                	cmp    %edx,%eax
  806453:	74 1b                	je     806470 <ip_addr_isbroadcast+0x44>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806455:	8b 59 08             	mov    0x8(%ecx),%ebx
  806458:	31 d0                	xor    %edx,%eax
  80645a:	89 c1                	mov    %eax,%ecx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  80645c:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806461:	85 d9                	test   %ebx,%ecx
  806463:	75 10                	jne    806475 <ip_addr_isbroadcast+0x49>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806465:	f7 d3                	not    %ebx
  806467:	21 da                	and    %ebx,%edx
  806469:	39 d3                	cmp    %edx,%ebx
  80646b:	0f 94 c0             	sete   %al
  80646e:	eb 05                	jmp    806475 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806470:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806475:	5b                   	pop    %ebx
  806476:	5d                   	pop    %ebp
  806477:	c3                   	ret    

00806478 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806478:	55                   	push   %ebp
  806479:	89 e5                	mov    %esp,%ebp
  80647b:	56                   	push   %esi
  80647c:	53                   	push   %ebx
  80647d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806480:	8b 1d 74 b3 b3 00    	mov    0xb3b374,%ebx
  806486:	eb 1c                	jmp    8064a4 <ip_route+0x2c>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806488:	83 ec 0c             	sub    $0xc,%esp
  80648b:	53                   	push   %ebx
  80648c:	e8 7d e2 ff ff       	call   80470e <netif_is_up>
  806491:	83 c4 10             	add    $0x10,%esp
  806494:	84 c0                	test   %al,%al
  806496:	74 0a                	je     8064a2 <ip_route+0x2a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806498:	8b 43 04             	mov    0x4(%ebx),%eax
  80649b:	33 06                	xor    (%esi),%eax
  80649d:	85 43 08             	test   %eax,0x8(%ebx)
  8064a0:	74 2b                	je     8064cd <ip_route+0x55>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8064a2:	8b 1b                	mov    (%ebx),%ebx
  8064a4:	85 db                	test   %ebx,%ebx
  8064a6:	75 e0                	jne    806488 <ip_route+0x10>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8064a8:	a1 78 b3 b3 00       	mov    0xb3b378,%eax
  8064ad:	85 c0                	test   %eax,%eax
  8064af:	74 1e                	je     8064cf <ip_route+0x57>
  8064b1:	83 ec 0c             	sub    $0xc,%esp
  8064b4:	50                   	push   %eax
  8064b5:	e8 54 e2 ff ff       	call   80470e <netif_is_up>
  8064ba:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8064bd:	84 c0                	test   %al,%al
  8064bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8064c4:	0f 45 05 78 b3 b3 00 	cmovne 0xb3b378,%eax
  8064cb:	eb 02                	jmp    8064cf <ip_route+0x57>
  8064cd:	89 d8                	mov    %ebx,%eax
}
  8064cf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8064d2:	5b                   	pop    %ebx
  8064d3:	5e                   	pop    %esi
  8064d4:	5d                   	pop    %ebp
  8064d5:	c3                   	ret    

008064d6 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8064d6:	55                   	push   %ebp
  8064d7:	89 e5                	mov    %esp,%ebp
  8064d9:	57                   	push   %edi
  8064da:	56                   	push   %esi
  8064db:	53                   	push   %ebx
  8064dc:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  8064df:	8b 45 08             	mov    0x8(%ebp),%eax
  8064e2:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  8064e5:	0f b7 06             	movzwl (%esi),%eax
  8064e8:	50                   	push   %eax
  8064e9:	e8 6c 11 00 00       	call   80765a <ntohs>
  8064ee:	66 c1 e8 0c          	shr    $0xc,%ax
  8064f2:	83 c4 10             	add    $0x10,%esp
  8064f5:	66 83 f8 04          	cmp    $0x4,%ax
  8064f9:	74 13                	je     80650e <ip_input+0x38>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8064fb:	83 ec 0c             	sub    $0xc,%esp
  8064fe:	ff 75 08             	pushl  0x8(%ebp)
  806501:	e8 e9 e2 ff ff       	call   8047ef <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806506:	83 c4 10             	add    $0x10,%esp
  806509:	e9 c8 02 00 00       	jmp    8067d6 <ip_input+0x300>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  80650e:	83 ec 0c             	sub    $0xc,%esp
  806511:	0f b7 06             	movzwl (%esi),%eax
  806514:	50                   	push   %eax
  806515:	e8 40 11 00 00       	call   80765a <ntohs>
  80651a:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  80651e:	83 e0 3c             	and    $0x3c,%eax
  806521:	89 c7                	mov    %eax,%edi
  806523:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806527:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80652b:	89 04 24             	mov    %eax,(%esp)
  80652e:	e8 27 11 00 00       	call   80765a <ntohs>
  806533:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806535:	83 c4 10             	add    $0x10,%esp
  806538:	8b 55 08             	mov    0x8(%ebp),%edx
  80653b:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  80653f:	77 06                	ja     806547 <ip_input+0x71>
  806541:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  806545:	76 13                	jbe    80655a <ip_input+0x84>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  806547:	83 ec 0c             	sub    $0xc,%esp
  80654a:	ff 75 08             	pushl  0x8(%ebp)
  80654d:	e8 9d e2 ff ff       	call   8047ef <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806552:	83 c4 10             	add    $0x10,%esp
  806555:	e9 7c 02 00 00       	jmp    8067d6 <ip_input+0x300>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  80655a:	83 ec 08             	sub    $0x8,%esp
  80655d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806561:	50                   	push   %eax
  806562:	56                   	push   %esi
  806563:	e8 be 0f 00 00       	call   807526 <inet_chksum>
  806568:	83 c4 10             	add    $0x10,%esp
  80656b:	66 85 c0             	test   %ax,%ax
  80656e:	74 13                	je     806583 <ip_input+0xad>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806570:	83 ec 0c             	sub    $0xc,%esp
  806573:	ff 75 08             	pushl  0x8(%ebp)
  806576:	e8 74 e2 ff ff       	call   8047ef <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80657b:	83 c4 10             	add    $0x10,%esp
  80657e:	e9 53 02 00 00       	jmp    8067d6 <ip_input+0x300>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806583:	83 ec 08             	sub    $0x8,%esp
  806586:	0f b7 db             	movzwl %bx,%ebx
  806589:	53                   	push   %ebx
  80658a:	ff 75 08             	pushl  0x8(%ebp)
  80658d:	e8 a2 e5 ff ff       	call   804b34 <pbuf_realloc>
  806592:	83 c4 10             	add    $0x10,%esp
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806595:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  806598:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80659d:	8d 46 10             	lea    0x10(%esi),%eax
  8065a0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8065a3:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  8065a6:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8065a8:	83 ec 0c             	sub    $0xc,%esp
  8065ab:	53                   	push   %ebx
  8065ac:	e8 5d e1 ff ff       	call   80470e <netif_is_up>
  8065b1:	83 c4 10             	add    $0x10,%esp
  8065b4:	84 c0                	test   %al,%al
  8065b6:	74 27                	je     8065df <ip_input+0x109>
  8065b8:	83 fb fc             	cmp    $0xfffffffc,%ebx
  8065bb:	74 22                	je     8065df <ip_input+0x109>
  8065bd:	8b 43 04             	mov    0x4(%ebx),%eax
  8065c0:	85 c0                	test   %eax,%eax
  8065c2:	74 1b                	je     8065df <ip_input+0x109>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8065c4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8065c7:	3b 41 10             	cmp    0x10(%ecx),%eax
  8065ca:	74 35                	je     806601 <ip_input+0x12b>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8065cc:	83 ec 08             	sub    $0x8,%esp
  8065cf:	53                   	push   %ebx
  8065d0:	ff 75 dc             	pushl  -0x24(%ebp)
  8065d3:	e8 54 fe ff ff       	call   80642c <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8065d8:	83 c4 10             	add    $0x10,%esp
  8065db:	84 c0                	test   %al,%al
  8065dd:	75 29                	jne    806608 <ip_input+0x132>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  8065df:	85 ff                	test   %edi,%edi
  8065e1:	74 08                	je     8065eb <ip_input+0x115>
        first = 0;
        netif = netif_list;
  8065e3:	8b 1d 74 b3 b3 00    	mov    0xb3b374,%ebx
  8065e9:	eb 02                	jmp    8065ed <ip_input+0x117>
      } else {
        netif = netif->next;
  8065eb:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  8065ed:	39 f3                	cmp    %esi,%ebx
  8065ef:	75 02                	jne    8065f3 <ip_input+0x11d>
        netif = netif->next;
  8065f1:	8b 1e                	mov    (%esi),%ebx
  8065f3:	bf 00 00 00 00       	mov    $0x0,%edi
      }
    } while(netif != NULL);
  8065f8:	85 db                	test   %ebx,%ebx
  8065fa:	75 ac                	jne    8065a8 <ip_input+0xd2>
  8065fc:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8065ff:	eb 14                	jmp    806615 <ip_input+0x13f>
  806601:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806604:	89 d8                	mov    %ebx,%eax
  806606:	eb 05                	jmp    80660d <ip_input+0x137>
  806608:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80660b:	89 d8                	mov    %ebx,%eax
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  80660d:	85 c0                	test   %eax,%eax
  80660f:	0f 85 a2 01 00 00    	jne    8067b7 <ip_input+0x2e1>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806615:	83 ec 0c             	sub    $0xc,%esp
  806618:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80661c:	50                   	push   %eax
  80661d:	e8 38 10 00 00       	call   80765a <ntohs>
  806622:	83 c4 10             	add    $0x10,%esp
  806625:	bb 00 00 00 00       	mov    $0x0,%ebx
  80662a:	3c 11                	cmp    $0x11,%al
  80662c:	0f 85 85 01 00 00    	jne    8067b7 <ip_input+0x2e1>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806632:	83 ec 0c             	sub    $0xc,%esp
  806635:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806639:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  80663e:	50                   	push   %eax
  80663f:	e8 16 10 00 00       	call   80765a <ntohs>
  806644:	83 c4 10             	add    $0x10,%esp
  806647:	66 83 f8 44          	cmp    $0x44,%ax
  80664b:	74 3d                	je     80668a <ip_input+0x1b4>
  80664d:	e9 65 01 00 00       	jmp    8067b7 <ip_input+0x2e1>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806652:	8b 7e 0c             	mov    0xc(%esi),%edi
  806655:	83 ec 0c             	sub    $0xc,%esp
  806658:	68 00 00 00 f0       	push   $0xf0000000
  80665d:	e8 3c 12 00 00       	call   80789e <ntohl>
  806662:	21 c7                	and    %eax,%edi
  806664:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80666b:	e8 2e 12 00 00       	call   80789e <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806670:	83 c4 10             	add    $0x10,%esp
  806673:	39 c7                	cmp    %eax,%edi
  806675:	75 16                	jne    80668d <ip_input+0x1b7>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806677:	83 ec 0c             	sub    $0xc,%esp
  80667a:	ff 75 08             	pushl  0x8(%ebp)
  80667d:	e8 6d e1 ff ff       	call   8047ef <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806682:	83 c4 10             	add    $0x10,%esp
  806685:	e9 4c 01 00 00       	jmp    8067d6 <ip_input+0x300>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  80668a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  80668d:	85 db                	test   %ebx,%ebx
  80668f:	75 13                	jne    8066a4 <ip_input+0x1ce>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806691:	83 ec 0c             	sub    $0xc,%esp
  806694:	ff 75 08             	pushl  0x8(%ebp)
  806697:	e8 53 e1 ff ff       	call   8047ef <pbuf_free>
    return ERR_OK;
  80669c:	83 c4 10             	add    $0x10,%esp
  80669f:	e9 32 01 00 00       	jmp    8067d6 <ip_input+0x300>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  8066a4:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  8066a8:	83 ec 0c             	sub    $0xc,%esp
  8066ab:	68 ff 3f 00 00       	push   $0x3fff
  8066b0:	e8 98 0f 00 00       	call   80764d <htons>
  8066b5:	83 c4 10             	add    $0x10,%esp
  8066b8:	66 85 d8             	test   %bx,%ax
  8066bb:	74 1c                	je     8066d9 <ip_input+0x203>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  8066bd:	83 ec 0c             	sub    $0xc,%esp
  8066c0:	ff 75 08             	pushl  0x8(%ebp)
  8066c3:	e8 18 05 00 00       	call   806be0 <ip_reass>
  8066c8:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  8066cb:	83 c4 10             	add    $0x10,%esp
  8066ce:	85 c0                	test   %eax,%eax
  8066d0:	0f 84 00 01 00 00    	je     8067d6 <ip_input+0x300>
      return ERR_OK;
    }
    iphdr = p->payload;
  8066d6:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  8066d9:	83 ec 08             	sub    $0x8,%esp
  8066dc:	ff 75 0c             	pushl  0xc(%ebp)
  8066df:	ff 75 08             	pushl  0x8(%ebp)
  8066e2:	e8 10 75 00 00       	call   80dbf7 <raw_input>
  8066e7:	83 c4 10             	add    $0x10,%esp
  8066ea:	84 c0                	test   %al,%al
  8066ec:	0f 85 e4 00 00 00    	jne    8067d6 <ip_input+0x300>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  8066f2:	83 ec 0c             	sub    $0xc,%esp
  8066f5:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8066f9:	50                   	push   %eax
  8066fa:	e8 5b 0f 00 00       	call   80765a <ntohs>
  8066ff:	83 c4 10             	add    $0x10,%esp
  806702:	0f b6 c0             	movzbl %al,%eax
  806705:	66 83 f8 06          	cmp    $0x6,%ax
  806709:	74 24                	je     80672f <ip_input+0x259>
  80670b:	66 83 f8 11          	cmp    $0x11,%ax
  80670f:	74 08                	je     806719 <ip_input+0x243>
  806711:	66 83 f8 01          	cmp    $0x1,%ax
  806715:	75 41                	jne    806758 <ip_input+0x282>
  806717:	eb 2c                	jmp    806745 <ip_input+0x26f>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  806719:	83 ec 08             	sub    $0x8,%esp
  80671c:	ff 75 0c             	pushl  0xc(%ebp)
  80671f:	ff 75 08             	pushl  0x8(%ebp)
  806722:	e8 27 21 00 00       	call   80884e <udp_input>
      break;
  806727:	83 c4 10             	add    $0x10,%esp
  80672a:	e9 a7 00 00 00       	jmp    8067d6 <ip_input+0x300>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  80672f:	83 ec 08             	sub    $0x8,%esp
  806732:	ff 75 0c             	pushl  0xc(%ebp)
  806735:	ff 75 08             	pushl  0x8(%ebp)
  806738:	e8 6c 67 00 00       	call   80cea9 <tcp_input>
      break;
  80673d:	83 c4 10             	add    $0x10,%esp
  806740:	e9 91 00 00 00       	jmp    8067d6 <ip_input+0x300>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  806745:	83 ec 08             	sub    $0x8,%esp
  806748:	ff 75 0c             	pushl  0xc(%ebp)
  80674b:	ff 75 08             	pushl  0x8(%ebp)
  80674e:	e8 5e 77 00 00       	call   80deb1 <icmp_input>
      break;
  806753:	83 c4 10             	add    $0x10,%esp
  806756:	eb 7e                	jmp    8067d6 <ip_input+0x300>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806758:	83 ec 08             	sub    $0x8,%esp
  80675b:	ff 75 0c             	pushl  0xc(%ebp)
  80675e:	8d 46 10             	lea    0x10(%esi),%eax
  806761:	50                   	push   %eax
  806762:	e8 c5 fc ff ff       	call   80642c <ip_addr_isbroadcast>
  806767:	83 c4 10             	add    $0x10,%esp
  80676a:	84 c0                	test   %al,%al
  80676c:	75 39                	jne    8067a7 <ip_input+0x2d1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  80676e:	8b 5e 10             	mov    0x10(%esi),%ebx
  806771:	83 ec 0c             	sub    $0xc,%esp
  806774:	68 00 00 00 f0       	push   $0xf0000000
  806779:	e8 20 11 00 00       	call   80789e <ntohl>
  80677e:	21 c3                	and    %eax,%ebx
  806780:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806787:	e8 12 11 00 00       	call   80789e <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80678c:	83 c4 10             	add    $0x10,%esp
  80678f:	39 c3                	cmp    %eax,%ebx
  806791:	74 14                	je     8067a7 <ip_input+0x2d1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  806793:	8b 45 08             	mov    0x8(%ebp),%eax
  806796:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806799:	83 ec 08             	sub    $0x8,%esp
  80679c:	6a 02                	push   $0x2
  80679e:	50                   	push   %eax
  80679f:	e8 1f 7a 00 00       	call   80e1c3 <icmp_dest_unreach>
  8067a4:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  8067a7:	83 ec 0c             	sub    $0xc,%esp
  8067aa:	ff 75 08             	pushl  0x8(%ebp)
  8067ad:	e8 3d e0 ff ff       	call   8047ef <pbuf_free>
  8067b2:	83 c4 10             	add    $0x10,%esp
  8067b5:	eb 1f                	jmp    8067d6 <ip_input+0x300>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8067b7:	83 ec 08             	sub    $0x8,%esp
  8067ba:	ff 75 0c             	pushl  0xc(%ebp)
  8067bd:	8d 46 0c             	lea    0xc(%esi),%eax
  8067c0:	50                   	push   %eax
  8067c1:	e8 66 fc ff ff       	call   80642c <ip_addr_isbroadcast>
  8067c6:	83 c4 10             	add    $0x10,%esp
  8067c9:	84 c0                	test   %al,%al
  8067cb:	0f 84 81 fe ff ff    	je     806652 <ip_input+0x17c>
  8067d1:	e9 a1 fe ff ff       	jmp    806677 <ip_input+0x1a1>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8067d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8067db:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8067de:	5b                   	pop    %ebx
  8067df:	5e                   	pop    %esi
  8067e0:	5f                   	pop    %edi
  8067e1:	5d                   	pop    %ebp
  8067e2:	c3                   	ret    

008067e3 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8067e3:	55                   	push   %ebp
  8067e4:	89 e5                	mov    %esp,%ebp
  8067e6:	57                   	push   %edi
  8067e7:	56                   	push   %esi
  8067e8:	53                   	push   %ebx
  8067e9:	83 ec 1c             	sub    $0x1c,%esp
  8067ec:	8b 75 08             	mov    0x8(%ebp),%esi
  8067ef:	8b 7d 14             	mov    0x14(%ebp),%edi
  8067f2:	8b 45 18             	mov    0x18(%ebp),%eax
  8067f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8067f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8067fb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8067fe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806802:	0f 84 12 01 00 00    	je     80691a <ip_output_if+0x137>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806808:	83 ec 08             	sub    $0x8,%esp
  80680b:	6a 14                	push   $0x14
  80680d:	56                   	push   %esi
  80680e:	e8 0a df ff ff       	call   80471d <pbuf_header>
  806813:	83 c4 10             	add    $0x10,%esp
  806816:	84 c0                	test   %al,%al
  806818:	0f 85 40 01 00 00    	jne    80695e <ip_output_if+0x17b>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80681e:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806821:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806826:	77 17                	ja     80683f <ip_output_if+0x5c>
  806828:	83 ec 04             	sub    $0x4,%esp
  80682b:	68 84 1d 81 00       	push   $0x811d84
  806830:	68 ee 01 00 00       	push   $0x1ee
  806835:	68 b1 1d 81 00       	push   $0x811db1
  80683a:	e8 a2 7b 00 00       	call   80e3e1 <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80683f:	83 ec 0c             	sub    $0xc,%esp
  806842:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806846:	50                   	push   %eax
  806847:	e8 0e 0e 00 00       	call   80765a <ntohs>
  80684c:	0f b6 c0             	movzbl %al,%eax
  80684f:	c1 e7 08             	shl    $0x8,%edi
  806852:	09 c7                	or     %eax,%edi
  806854:	0f b7 ff             	movzwl %di,%edi
  806857:	89 3c 24             	mov    %edi,(%esp)
  80685a:	e8 ee 0d 00 00       	call   80764d <htons>
  80685f:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806863:	0f b7 c0             	movzwl %ax,%eax
  806866:	89 04 24             	mov    %eax,(%esp)
  806869:	e8 ec 0d 00 00       	call   80765a <ntohs>
  80686e:	25 00 ff 00 00       	and    $0xff00,%eax
  806873:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  806877:	09 d0                	or     %edx,%eax
  806879:	0f b7 c0             	movzwl %ax,%eax
  80687c:	89 04 24             	mov    %eax,(%esp)
  80687f:	e8 c9 0d 00 00       	call   80764d <htons>
  806884:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806888:	8b 45 10             	mov    0x10(%ebp),%eax
  80688b:	8b 00                	mov    (%eax),%eax
  80688d:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806890:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806894:	80 cc 45             	or     $0x45,%ah
  806897:	89 04 24             	mov    %eax,(%esp)
  80689a:	e8 ae 0d 00 00       	call   80764d <htons>
  80689f:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8068a2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8068a6:	89 04 24             	mov    %eax,(%esp)
  8068a9:	e8 9f 0d 00 00       	call   80764d <htons>
  8068ae:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  8068b2:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8068b8:	0f b7 05 ba 44 b3 00 	movzwl 0xb344ba,%eax
  8068bf:	89 04 24             	mov    %eax,(%esp)
  8068c2:	e8 86 0d 00 00       	call   80764d <htons>
  8068c7:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  8068cb:	66 83 05 ba 44 b3 00 	addw   $0x1,0xb344ba
  8068d2:	01 

    if (ip_addr_isany(src)) {
  8068d3:	83 c4 10             	add    $0x10,%esp
  8068d6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8068da:	74 09                	je     8068e5 <ip_output_if+0x102>
  8068dc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8068df:	8b 00                	mov    (%eax),%eax
  8068e1:	85 c0                	test   %eax,%eax
  8068e3:	75 18                	jne    8068fd <ip_output_if+0x11a>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8068e5:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  8068e9:	74 08                	je     8068f3 <ip_output_if+0x110>
  8068eb:	8b 45 20             	mov    0x20(%ebp),%eax
  8068ee:	8b 40 04             	mov    0x4(%eax),%eax
  8068f1:	eb 05                	jmp    8068f8 <ip_output_if+0x115>
  8068f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8068f8:	89 43 0c             	mov    %eax,0xc(%ebx)
  8068fb:	eb 03                	jmp    806900 <ip_output_if+0x11d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  8068fd:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806900:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806906:	83 ec 08             	sub    $0x8,%esp
  806909:	6a 14                	push   $0x14
  80690b:	53                   	push   %ebx
  80690c:	e8 15 0c 00 00       	call   807526 <inet_chksum>
  806911:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806915:	83 c4 10             	add    $0x10,%esp
  806918:	eb 09                	jmp    806923 <ip_output_if+0x140>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  80691a:	8b 46 04             	mov    0x4(%esi),%eax
  80691d:	83 c0 10             	add    $0x10,%eax
  806920:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806923:	8b 45 20             	mov    0x20(%ebp),%eax
  806926:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  80692a:	66 85 c0             	test   %ax,%ax
  80692d:	74 1a                	je     806949 <ip_output_if+0x166>
  80692f:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806933:	73 14                	jae    806949 <ip_output_if+0x166>
    return ip_frag(p,netif,dest);
  806935:	83 ec 04             	sub    $0x4,%esp
  806938:	ff 75 10             	pushl  0x10(%ebp)
  80693b:	ff 75 20             	pushl  0x20(%ebp)
  80693e:	56                   	push   %esi
  80693f:	e8 8d 07 00 00       	call   8070d1 <ip_frag>
  806944:	83 c4 10             	add    $0x10,%esp
  806947:	eb 1a                	jmp    806963 <ip_output_if+0x180>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806949:	83 ec 04             	sub    $0x4,%esp
  80694c:	ff 75 10             	pushl  0x10(%ebp)
  80694f:	56                   	push   %esi
  806950:	ff 75 20             	pushl  0x20(%ebp)
  806953:	8b 45 20             	mov    0x20(%ebp),%eax
  806956:	ff 50 14             	call   *0x14(%eax)
  806959:	83 c4 10             	add    $0x10,%esp
  80695c:	eb 05                	jmp    806963 <ip_output_if+0x180>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  80695e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  806963:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806966:	5b                   	pop    %ebx
  806967:	5e                   	pop    %esi
  806968:	5f                   	pop    %edi
  806969:	5d                   	pop    %ebp
  80696a:	c3                   	ret    

0080696b <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  80696b:	55                   	push   %ebp
  80696c:	89 e5                	mov    %esp,%ebp
  80696e:	57                   	push   %edi
  80696f:	56                   	push   %esi
  806970:	53                   	push   %ebx
  806971:	83 ec 18             	sub    $0x18,%esp
  806974:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806977:	8b 75 18             	mov    0x18(%ebp),%esi
  80697a:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  80697d:	ff 75 10             	pushl  0x10(%ebp)
  806980:	e8 f3 fa ff ff       	call   806478 <ip_route>
  806985:	83 c4 10             	add    $0x10,%esp
  806988:	85 c0                	test   %eax,%eax
  80698a:	74 27                	je     8069b3 <ip_output+0x48>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  80698c:	83 ec 04             	sub    $0x4,%esp
  80698f:	50                   	push   %eax
  806990:	89 f8                	mov    %edi,%eax
  806992:	0f b6 f8             	movzbl %al,%edi
  806995:	57                   	push   %edi
  806996:	89 f0                	mov    %esi,%eax
  806998:	0f b6 f0             	movzbl %al,%esi
  80699b:	56                   	push   %esi
  80699c:	0f b6 db             	movzbl %bl,%ebx
  80699f:	53                   	push   %ebx
  8069a0:	ff 75 10             	pushl  0x10(%ebp)
  8069a3:	ff 75 0c             	pushl  0xc(%ebp)
  8069a6:	ff 75 08             	pushl  0x8(%ebp)
  8069a9:	e8 35 fe ff ff       	call   8067e3 <ip_output_if>
  8069ae:	83 c4 20             	add    $0x20,%esp
  8069b1:	eb 05                	jmp    8069b8 <ip_output+0x4d>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  8069b3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  8069b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8069bb:	5b                   	pop    %ebx
  8069bc:	5e                   	pop    %esi
  8069bd:	5f                   	pop    %edi
  8069be:	5d                   	pop    %ebp
  8069bf:	c3                   	ret    

008069c0 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8069c0:	55                   	push   %ebp
  8069c1:	89 e5                	mov    %esp,%ebp
  8069c3:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  8069c6:	8b 0d a0 4a b3 00    	mov    0xb34aa0,%ecx
  8069cc:	39 c1                	cmp    %eax,%ecx
  8069ce:	75 0a                	jne    8069da <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  8069d0:	8b 11                	mov    (%ecx),%edx
  8069d2:	89 15 a0 4a b3 00    	mov    %edx,0xb34aa0
  8069d8:	eb 1f                	jmp    8069f9 <ip_reass_dequeue_datagram+0x39>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  8069da:	85 d2                	test   %edx,%edx
  8069dc:	75 17                	jne    8069f5 <ip_reass_dequeue_datagram+0x35>
  8069de:	83 ec 04             	sub    $0x4,%esp
  8069e1:	68 c9 1d 81 00       	push   $0x811dc9
  8069e6:	68 29 01 00 00       	push   $0x129
  8069eb:	68 e2 1d 81 00       	push   $0x811de2
  8069f0:	e8 ec 79 00 00       	call   80e3e1 <_panic>
    prev->next = ipr->next;
  8069f5:	8b 08                	mov    (%eax),%ecx
  8069f7:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  8069f9:	83 ec 08             	sub    $0x8,%esp
  8069fc:	50                   	push   %eax
  8069fd:	6a 05                	push   $0x5
  8069ff:	e8 78 da ff ff       	call   80447c <memp_free>
  806a04:	83 c4 10             	add    $0x10,%esp
}
  806a07:	c9                   	leave  
  806a08:	c3                   	ret    

00806a09 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806a09:	55                   	push   %ebp
  806a0a:	89 e5                	mov    %esp,%ebp
  806a0c:	57                   	push   %edi
  806a0d:	56                   	push   %esi
  806a0e:	53                   	push   %ebx
  806a0f:	83 ec 1c             	sub    $0x1c,%esp
  806a12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806a15:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  806a18:	39 c2                	cmp    %eax,%edx
  806a1a:	75 17                	jne    806a33 <ip_reass_free_complete_datagram+0x2a>
  806a1c:	83 ec 04             	sub    $0x4,%esp
  806a1f:	68 ff 1d 81 00       	push   $0x811dff
  806a24:	68 99 00 00 00       	push   $0x99
  806a29:	68 e2 1d 81 00       	push   $0x811de2
  806a2e:	e8 ae 79 00 00       	call   80e3e1 <_panic>
  if (prev != NULL) {
  806a33:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a36:	85 c0                	test   %eax,%eax
  806a38:	74 1e                	je     806a58 <ip_reass_free_complete_datagram+0x4f>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806a3a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806a3d:	39 10                	cmp    %edx,(%eax)
  806a3f:	74 17                	je     806a58 <ip_reass_free_complete_datagram+0x4f>
  806a41:	83 ec 04             	sub    $0x4,%esp
  806a44:	68 0b 1e 81 00       	push   $0x811e0b
  806a49:	68 9b 00 00 00       	push   $0x9b
  806a4e:	68 e2 1d 81 00       	push   $0x811de2
  806a53:	e8 89 79 00 00       	call   80e3e1 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806a58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a5b:	8b 58 04             	mov    0x4(%eax),%ebx
  806a5e:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  806a61:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  806a66:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806a6b:	75 3a                	jne    806aa7 <ip_reass_free_complete_datagram+0x9e>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  806a6d:	8b 00                	mov    (%eax),%eax
  806a6f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806a72:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806a75:	83 ec 04             	sub    $0x4,%esp
  806a78:	6a 14                	push   $0x14
  806a7a:	8d 41 08             	lea    0x8(%ecx),%eax
  806a7d:	50                   	push   %eax
  806a7e:	ff 73 04             	pushl  0x4(%ebx)
  806a81:	e8 b5 81 00 00       	call   80ec3b <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806a86:	83 c4 08             	add    $0x8,%esp
  806a89:	6a 01                	push   $0x1
  806a8b:	53                   	push   %ebx
  806a8c:	e8 11 78 00 00       	call   80e2a2 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806a91:	89 1c 24             	mov    %ebx,(%esp)
  806a94:	e8 a8 e1 ff ff       	call   804c41 <pbuf_clen>
  806a99:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806a9c:	89 1c 24             	mov    %ebx,(%esp)
  806a9f:	e8 4b dd ff ff       	call   8047ef <pbuf_free>
  806aa4:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  806aa7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806aaa:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806aad:	eb 20                	jmp    806acf <ip_reass_free_complete_datagram+0xc6>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  806aaf:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806ab2:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806ab4:	83 ec 0c             	sub    $0xc,%esp
  806ab7:	53                   	push   %ebx
  806ab8:	e8 84 e1 ff ff       	call   804c41 <pbuf_clen>
  806abd:	0f b6 c0             	movzbl %al,%eax
  806ac0:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806ac2:	89 1c 24             	mov    %ebx,(%esp)
  806ac5:	e8 25 dd ff ff       	call   8047ef <pbuf_free>
  806aca:	83 c4 10             	add    $0x10,%esp
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806acd:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  806acf:	85 db                	test   %ebx,%ebx
  806ad1:	75 dc                	jne    806aaf <ip_reass_free_complete_datagram+0xa6>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  806ad3:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806ad6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806ad9:	e8 e2 fe ff ff       	call   8069c0 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806ade:	0f b7 05 9c 4a b3 00 	movzwl 0xb34a9c,%eax
  806ae5:	0f b7 d0             	movzwl %ax,%edx
  806ae8:	39 f2                	cmp    %esi,%edx
  806aea:	7d 17                	jge    806b03 <ip_reass_free_complete_datagram+0xfa>
  806aec:	83 ec 04             	sub    $0x4,%esp
  806aef:	68 1d 1e 81 00       	push   $0x811e1d
  806af4:	68 bc 00 00 00       	push   $0xbc
  806af9:	68 e2 1d 81 00       	push   $0x811de2
  806afe:	e8 de 78 00 00       	call   80e3e1 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  806b03:	29 f0                	sub    %esi,%eax
  806b05:	66 a3 9c 4a b3 00    	mov    %ax,0xb34a9c

  return pbufs_freed;
}
  806b0b:	89 f0                	mov    %esi,%eax
  806b0d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806b10:	5b                   	pop    %ebx
  806b11:	5e                   	pop    %esi
  806b12:	5f                   	pop    %edi
  806b13:	5d                   	pop    %ebp
  806b14:	c3                   	ret    

00806b15 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  806b15:	55                   	push   %ebp
  806b16:	89 e5                	mov    %esp,%ebp
  806b18:	57                   	push   %edi
  806b19:	56                   	push   %esi
  806b1a:	53                   	push   %ebx
  806b1b:	83 ec 1c             	sub    $0x1c,%esp
  806b1e:	89 c6                	mov    %eax,%esi
  806b20:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  806b23:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  806b2a:	8b 0d a0 4a b3 00    	mov    0xb34aa0,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  806b30:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  806b35:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  806b3a:	b8 00 00 00 00       	mov    $0x0,%eax
  806b3f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806b42:	eb 39                	jmp    806b7d <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806b44:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806b47:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806b4a:	75 12                	jne    806b5e <ip_reass_remove_oldest_datagram+0x49>
  806b4c:	8b 7e 10             	mov    0x10(%esi),%edi
  806b4f:	39 79 18             	cmp    %edi,0x18(%ecx)
  806b52:	75 0a                	jne    806b5e <ip_reass_remove_oldest_datagram+0x49>
  806b54:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806b58:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806b5c:	74 16                	je     806b74 <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  806b5e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806b62:	85 c0                	test   %eax,%eax
  806b64:	74 0c                	je     806b72 <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  806b66:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806b6a:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806b6d:	0f 46 c1             	cmovbe %ecx,%eax
  806b70:	eb 02                	jmp    806b74 <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  806b72:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  806b74:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806b76:	85 ff                	test   %edi,%edi
  806b78:	0f 45 d1             	cmovne %ecx,%edx
  806b7b:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806b7d:	85 c9                	test   %ecx,%ecx
  806b7f:	75 c3                	jne    806b44 <ip_reass_remove_oldest_datagram+0x2f>
  806b81:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  806b84:	85 c0                	test   %eax,%eax
  806b86:	74 08                	je     806b90 <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806b88:	e8 7c fe ff ff       	call   806a09 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806b8d:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806b90:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806b93:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806b96:	7d 05                	jge    806b9d <ip_reass_remove_oldest_datagram+0x88>
  806b98:	83 fb 01             	cmp    $0x1,%ebx
  806b9b:	7f 8d                	jg     806b2a <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  806b9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806ba0:	83 c4 1c             	add    $0x1c,%esp
  806ba3:	5b                   	pop    %ebx
  806ba4:	5e                   	pop    %esi
  806ba5:	5f                   	pop    %edi
  806ba6:	5d                   	pop    %ebp
  806ba7:	c3                   	ret    

00806ba8 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  806ba8:	55                   	push   %ebp
  806ba9:	89 e5                	mov    %esp,%ebp
  806bab:	56                   	push   %esi
  806bac:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  806bad:	a1 a0 4a b3 00       	mov    0xb34aa0,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  806bb2:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  806bb7:	eb 1f                	jmp    806bd8 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  806bb9:	0f b6 48 1f          	movzbl 0x1f(%eax),%ecx
  806bbd:	84 c9                	test   %cl,%cl
  806bbf:	74 0c                	je     806bcd <ip_reass_tmr+0x25>
      r->timer--;
  806bc1:	83 e9 01             	sub    $0x1,%ecx
  806bc4:	88 48 1f             	mov    %cl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  806bc7:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806bc9:	8b 00                	mov    (%eax),%eax
  806bcb:	eb 0b                	jmp    806bd8 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806bcd:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  806bcf:	89 da                	mov    %ebx,%edx
  806bd1:	e8 33 fe ff ff       	call   806a09 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806bd6:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  806bd8:	85 c0                	test   %eax,%eax
  806bda:	75 dd                	jne    806bb9 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  806bdc:	5b                   	pop    %ebx
  806bdd:	5e                   	pop    %esi
  806bde:	5d                   	pop    %ebp
  806bdf:	c3                   	ret    

00806be0 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806be0:	55                   	push   %ebp
  806be1:	89 e5                	mov    %esp,%ebp
  806be3:	57                   	push   %edi
  806be4:	56                   	push   %esi
  806be5:	53                   	push   %ebx
  806be6:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806be9:	8b 45 08             	mov    0x8(%ebp),%eax
  806bec:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806bef:	0f b7 03             	movzwl (%ebx),%eax
  806bf2:	50                   	push   %eax
  806bf3:	e8 62 0a 00 00       	call   80765a <ntohs>
  806bf8:	66 c1 e8 08          	shr    $0x8,%ax
  806bfc:	83 e0 0f             	and    $0xf,%eax
  806bff:	83 c4 10             	add    $0x10,%esp
  806c02:	83 f8 05             	cmp    $0x5,%eax
  806c05:	0f 85 7a 04 00 00    	jne    807085 <ip_reass+0x4a5>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806c0b:	83 ec 0c             	sub    $0xc,%esp
  806c0e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806c12:	50                   	push   %eax
  806c13:	e8 42 0a 00 00       	call   80765a <ntohs>
  806c18:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806c1c:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806c20:	89 04 24             	mov    %eax,(%esp)
  806c23:	e8 32 0a 00 00       	call   80765a <ntohs>
  806c28:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  806c2c:	0f b7 03             	movzwl (%ebx),%eax
  806c2f:	89 04 24             	mov    %eax,(%esp)
  806c32:	e8 23 0a 00 00       	call   80765a <ntohs>
  806c37:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806c3b:	83 c4 04             	add    $0x4,%esp
  806c3e:	ff 75 08             	pushl  0x8(%ebp)
  806c41:	e8 fb df ff ff       	call   804c41 <pbuf_clen>
  806c46:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806c49:	0f b6 f0             	movzbl %al,%esi
  806c4c:	0f b7 05 9c 4a b3 00 	movzwl 0xb34a9c,%eax
  806c53:	01 f0                	add    %esi,%eax
  806c55:	83 c4 10             	add    $0x10,%esp
  806c58:	83 f8 0a             	cmp    $0xa,%eax
  806c5b:	7e 23                	jle    806c80 <ip_reass+0xa0>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806c5d:	89 f2                	mov    %esi,%edx
  806c5f:	89 d8                	mov    %ebx,%eax
  806c61:	e8 af fe ff ff       	call   806b15 <ip_reass_remove_oldest_datagram>
  806c66:	85 c0                	test   %eax,%eax
  806c68:	0f 84 17 04 00 00    	je     807085 <ip_reass+0x4a5>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806c6e:	0f b7 05 9c 4a b3 00 	movzwl 0xb34a9c,%eax
  806c75:	01 f0                	add    %esi,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806c77:	83 f8 0a             	cmp    $0xa,%eax
  806c7a:	0f 8f 05 04 00 00    	jg     807085 <ip_reass+0x4a5>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c80:	8b 3d a0 4a b3 00    	mov    0xb34aa0,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  806c86:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c8b:	eb 1e                	jmp    806cab <ip_reass+0xcb>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806c8d:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806c90:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806c93:	75 12                	jne    806ca7 <ip_reass+0xc7>
  806c95:	8b 53 10             	mov    0x10(%ebx),%edx
  806c98:	39 57 18             	cmp    %edx,0x18(%edi)
  806c9b:	75 0a                	jne    806ca7 <ip_reass+0xc7>
  806c9d:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806ca1:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806ca5:	74 7f                	je     806d26 <ip_reass+0x146>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806ca7:	89 f8                	mov    %edi,%eax
  806ca9:	8b 3f                	mov    (%edi),%edi
  806cab:	85 ff                	test   %edi,%edi
  806cad:	75 de                	jne    806c8d <ip_reass+0xad>
  806caf:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  806cb2:	83 ec 0c             	sub    $0xc,%esp
  806cb5:	6a 05                	push   $0x5
  806cb7:	e8 6a d7 ff ff       	call   804426 <memp_malloc>
  806cbc:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806cbe:	83 c4 10             	add    $0x10,%esp
  806cc1:	85 c0                	test   %eax,%eax
  806cc3:	75 28                	jne    806ced <ip_reass+0x10d>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806cc5:	89 f2                	mov    %esi,%edx
  806cc7:	89 d8                	mov    %ebx,%eax
  806cc9:	e8 47 fe ff ff       	call   806b15 <ip_reass_remove_oldest_datagram>
  806cce:	39 c6                	cmp    %eax,%esi
  806cd0:	0f 8f af 03 00 00    	jg     807085 <ip_reass+0x4a5>
      ipr = memp_malloc(MEMP_REASSDATA);
  806cd6:	83 ec 0c             	sub    $0xc,%esp
  806cd9:	6a 05                	push   $0x5
  806cdb:	e8 46 d7 ff ff       	call   804426 <memp_malloc>
  806ce0:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  806ce2:	83 c4 10             	add    $0x10,%esp
  806ce5:	85 c0                	test   %eax,%eax
  806ce7:	0f 84 98 03 00 00    	je     807085 <ip_reass+0x4a5>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806ced:	83 ec 04             	sub    $0x4,%esp
  806cf0:	6a 20                	push   $0x20
  806cf2:	6a 00                	push   $0x0
  806cf4:	57                   	push   %edi
  806cf5:	e8 8c 7e 00 00       	call   80eb86 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806cfa:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  806cfe:	a1 a0 4a b3 00       	mov    0xb34aa0,%eax
  806d03:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806d05:	89 3d a0 4a b3 00    	mov    %edi,0xb34aa0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806d0b:	83 c4 0c             	add    $0xc,%esp
  806d0e:	6a 14                	push   $0x14
  806d10:	53                   	push   %ebx
  806d11:	8d 47 08             	lea    0x8(%edi),%eax
  806d14:	50                   	push   %eax
  806d15:	e8 21 7f 00 00       	call   80ec3b <memcpy>

  if (ipr == NULL) {
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  806d1a:	83 c4 10             	add    $0x10,%esp
  806d1d:	85 ff                	test   %edi,%edi
  806d1f:	75 48                	jne    806d69 <ip_reass+0x189>
  806d21:	e9 5f 03 00 00       	jmp    807085 <ip_reass+0x4a5>
  806d26:	89 45 e0             	mov    %eax,-0x20(%ebp)
  806d29:	89 fe                	mov    %edi,%esi
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806d2b:	83 ec 0c             	sub    $0xc,%esp
  806d2e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d32:	50                   	push   %eax
  806d33:	e8 22 09 00 00       	call   80765a <ntohs>
  806d38:	83 c4 10             	add    $0x10,%esp
  806d3b:	66 a9 ff 1f          	test   $0x1fff,%ax
  806d3f:	75 28                	jne    806d69 <ip_reass+0x189>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806d41:	83 ec 0c             	sub    $0xc,%esp
  806d44:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806d48:	50                   	push   %eax
  806d49:	e8 0c 09 00 00       	call   80765a <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806d4e:	83 c4 10             	add    $0x10,%esp
  806d51:	66 a9 ff 1f          	test   $0x1fff,%ax
  806d55:	74 12                	je     806d69 <ip_reass+0x189>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806d57:	83 ec 04             	sub    $0x4,%esp
  806d5a:	6a 14                	push   $0x14
  806d5c:	53                   	push   %ebx
  806d5d:	83 c6 08             	add    $0x8,%esi
  806d60:	56                   	push   %esi
  806d61:	e8 d5 7e 00 00       	call   80ec3b <memcpy>
  806d66:	83 c4 10             	add    $0x10,%esp
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806d69:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806d6d:	66 01 05 9c 4a b3 00 	add    %ax,0xb34a9c

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806d74:	83 ec 0c             	sub    $0xc,%esp
  806d77:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d7b:	50                   	push   %eax
  806d7c:	e8 d9 08 00 00       	call   80765a <ntohs>
  806d81:	83 c4 10             	add    $0x10,%esp
  806d84:	f6 c4 20             	test   $0x20,%ah
  806d87:	75 20                	jne    806da9 <ip_reass+0x1c9>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806d89:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
  806d8d:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  806d91:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  806d95:	8d 04 c6             	lea    (%esi,%eax,8),%eax
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d98:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  806d9c:	66 c1 ea 06          	shr    $0x6,%dx
  806da0:	83 e2 3c             	and    $0x3c,%edx
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
  806da3:	29 d0                	sub    %edx,%eax
  806da5:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806da9:	8b 45 08             	mov    0x8(%ebp),%eax
  806dac:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806daf:	83 ec 0c             	sub    $0xc,%esp
  806db2:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806db6:	50                   	push   %eax
  806db7:	e8 9e 08 00 00       	call   80765a <ntohs>
  806dbc:	89 c6                	mov    %eax,%esi
  806dbe:	0f b7 03             	movzwl (%ebx),%eax
  806dc1:	89 04 24             	mov    %eax,(%esp)
  806dc4:	e8 91 08 00 00       	call   80765a <ntohs>
  806dc9:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806dcd:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806dd1:	89 04 24             	mov    %eax,(%esp)
  806dd4:	e8 81 08 00 00       	call   80765a <ntohs>
  806dd9:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  806de0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806de3:	8b 51 04             	mov    0x4(%ecx),%edx
  806de6:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  806de9:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806def:	66 89 5a 04          	mov    %bx,0x4(%edx)
  806df3:	01 de                	add    %ebx,%esi
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806df5:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806df9:	66 c1 e8 06          	shr    $0x6,%ax
  806dfd:	83 e0 3c             	and    $0x3c,%eax
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
  806e00:	29 c6                	sub    %eax,%esi
  806e02:	66 89 75 da          	mov    %si,-0x26(%ebp)
  806e06:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806e0a:	8b 47 04             	mov    0x4(%edi),%eax
  806e0d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806e10:	83 c4 10             	add    $0x10,%esp
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  806e13:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806e18:	be 00 00 00 00       	mov    $0x0,%esi
  806e1d:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806e20:	89 cf                	mov    %ecx,%edi
  806e22:	eb 6f                	jmp    806e93 <ip_reass+0x2b3>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806e24:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806e27:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806e2b:	66 39 cb             	cmp    %cx,%bx
  806e2e:	73 3c                	jae    806e6c <ip_reass+0x28c>
  806e30:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806e33:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  806e36:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806e39:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806e3b:	85 f6                	test   %esi,%esi
  806e3d:	74 22                	je     806e61 <ip_reass+0x281>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806e3f:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806e43:	0f 82 70 01 00 00    	jb     806fb9 <ip_reass+0x3d9>
  806e49:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  806e4d:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806e51:	0f 87 62 01 00 00    	ja     806fb9 <ip_reass+0x3d9>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  806e57:	8b 45 08             	mov    0x8(%ebp),%eax
  806e5a:	89 06                	mov    %eax,(%esi)
  806e5c:	e9 96 00 00 00       	jmp    806ef7 <ip_reass+0x317>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  806e61:	8b 45 08             	mov    0x8(%ebp),%eax
  806e64:	89 47 04             	mov    %eax,0x4(%edi)
  806e67:	e9 8b 00 00 00       	jmp    806ef7 <ip_reass+0x317>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  806e6c:	66 39 cb             	cmp    %cx,%bx
  806e6f:	0f 84 44 01 00 00    	je     806fb9 <ip_reass+0x3d9>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  806e75:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806e79:	0f 82 3a 01 00 00    	jb     806fb9 <ip_reass+0x3d9>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  806e7f:	85 f6                	test   %esi,%esi
  806e81:	74 0c                	je     806e8f <ip_reass+0x2af>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  806e83:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806e87:	b8 00 00 00 00       	mov    $0x0,%eax
  806e8c:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  806e8f:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806e91:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806e93:	85 c0                	test   %eax,%eax
  806e95:	75 8d                	jne    806e24 <ip_reass+0x244>
  806e97:	e9 05 02 00 00       	jmp    8070a1 <ip_reass+0x4c1>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806e9c:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806ea0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806ea3:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  806ea7:	76 17                	jbe    806ec0 <ip_reass+0x2e0>
  806ea9:	83 ec 04             	sub    $0x4,%esp
  806eac:	68 38 1e 81 00       	push   $0x811e38
  806eb1:	68 83 01 00 00       	push   $0x183
  806eb6:	68 e2 1d 81 00       	push   $0x811de2
  806ebb:	e8 21 75 00 00       	call   80e3e1 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  806ec0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806ec3:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  806ec5:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806ec8:	66 3b 46 04          	cmp    0x4(%esi),%ax
  806ecc:	0f 85 f2 01 00 00    	jne    8070c4 <ip_reass+0x4e4>
  806ed2:	eb 23                	jmp    806ef7 <ip_reass+0x317>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806ed4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  806ed8:	74 17                	je     806ef1 <ip_reass+0x311>
  806eda:	83 ec 04             	sub    $0x4,%esp
  806edd:	68 64 1e 81 00       	push   $0x811e64
  806ee2:	68 8c 01 00 00       	push   $0x18c
  806ee7:	68 e2 1d 81 00       	push   $0x811de2
  806eec:	e8 f0 74 00 00       	call   80e3e1 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  806ef1:	8b 45 08             	mov    0x8(%ebp),%eax
  806ef4:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806ef7:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806efb:	0f 84 c3 01 00 00    	je     8070c4 <ip_reass+0x4e4>
    /* and had no wholes so far */
    if (valid) {
  806f01:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806f05:	0f 84 b9 01 00 00    	je     8070c4 <ip_reass+0x4e4>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806f0b:	8b 4f 04             	mov    0x4(%edi),%ecx
  806f0e:	8b 59 04             	mov    0x4(%ecx),%ebx
  806f11:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806f16:	0f 85 a8 01 00 00    	jne    8070c4 <ip_reass+0x4e4>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  806f1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f1f:	8b 10                	mov    (%eax),%edx
  806f21:	89 c6                	mov    %eax,%esi
  806f23:	eb 15                	jmp    806f3a <ip_reass+0x35a>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806f25:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806f28:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806f2c:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806f30:	0f 85 64 01 00 00    	jne    80709a <ip_reass+0x4ba>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  806f36:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806f38:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  806f3a:	85 d2                	test   %edx,%edx
  806f3c:	75 e7                	jne    806f25 <ip_reass+0x345>
  806f3e:	e9 71 01 00 00       	jmp    8070b4 <ip_reass+0x4d4>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  806f43:	83 ec 04             	sub    $0x4,%esp
  806f46:	68 56 1e 81 00       	push   $0x811e56
  806f4b:	68 ac 01 00 00       	push   $0x1ac
  806f50:	68 e2 1d 81 00       	push   $0x811de2
  806f55:	e8 87 74 00 00       	call   80e3e1 <_panic>
          LWIP_ASSERT("sanity check",
  806f5a:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  806f5d:	75 17                	jne    806f76 <ip_reass+0x396>
  806f5f:	83 ec 04             	sub    $0x4,%esp
  806f62:	68 56 1e 81 00       	push   $0x811e56
  806f67:	68 ae 01 00 00       	push   $0x1ae
  806f6c:	68 e2 1d 81 00       	push   $0x811de2
  806f71:	e8 6b 74 00 00       	call   80e3e1 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  806f76:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f79:	83 38 00             	cmpl   $0x0,(%eax)
  806f7c:	74 17                	je     806f95 <ip_reass+0x3b5>
  806f7e:	83 ec 04             	sub    $0x4,%esp
  806f81:	68 9c 1e 81 00       	push   $0x811e9c
  806f86:	68 b0 01 00 00       	push   $0x1b0
  806f8b:	68 e2 1d 81 00       	push   $0x811de2
  806f90:	e8 4c 74 00 00       	call   80e3e1 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  806f95:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f98:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  806f9c:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  806fa0:	74 3f                	je     806fe1 <ip_reass+0x401>
  806fa2:	83 ec 04             	sub    $0x4,%esp
  806fa5:	68 c0 1e 81 00       	push   $0x811ec0
  806faa:	68 b2 01 00 00       	push   $0x1b2
  806faf:	68 e2 1d 81 00       	push   $0x811de2
  806fb4:	e8 28 74 00 00       	call   80e3e1 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  806fb9:	83 ec 0c             	sub    $0xc,%esp
  806fbc:	ff 75 08             	pushl  0x8(%ebp)
  806fbf:	e8 7d dc ff ff       	call   804c41 <pbuf_clen>
  806fc4:	0f b6 c0             	movzbl %al,%eax
  806fc7:	66 29 05 9c 4a b3 00 	sub    %ax,0xb34a9c
  pbuf_free(new_p);
  806fce:	83 c4 04             	add    $0x4,%esp
  806fd1:	ff 75 08             	pushl  0x8(%ebp)
  806fd4:	e8 16 d8 ff ff       	call   8047ef <pbuf_free>
  806fd9:	83 c4 10             	add    $0x10,%esp
  806fdc:	e9 e3 00 00 00       	jmp    8070c4 <ip_reass+0x4e4>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  806fe1:	83 c0 14             	add    $0x14,%eax
  806fe4:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  806fe8:	8b 47 04             	mov    0x4(%edi),%eax
  806feb:	8b 70 04             	mov    0x4(%eax),%esi
  806fee:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  806ff0:	83 ec 04             	sub    $0x4,%esp
  806ff3:	6a 14                	push   $0x14
  806ff5:	8d 47 08             	lea    0x8(%edi),%eax
  806ff8:	50                   	push   %eax
  806ff9:	56                   	push   %esi
  806ffa:	e8 3c 7c 00 00       	call   80ec3b <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  806fff:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807003:	89 04 24             	mov    %eax,(%esp)
  807006:	e8 42 06 00 00       	call   80764d <htons>
  80700b:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  80700f:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  807015:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80701b:	83 c4 08             	add    $0x8,%esp
  80701e:	6a 14                	push   $0x14
  807020:	56                   	push   %esi
  807021:	e8 00 05 00 00       	call   807526 <inet_chksum>
  807026:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  80702a:	8b 47 04             	mov    0x4(%edi),%eax
  80702d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807030:	83 c4 10             	add    $0x10,%esp
  807033:	89 7d dc             	mov    %edi,-0x24(%ebp)
  807036:	89 c7                	mov    %eax,%edi
  807038:	eb 1d                	jmp    807057 <ip_reass+0x477>
      iprh = (struct ip_reass_helper*)r->payload;
  80703a:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80703d:	83 ec 08             	sub    $0x8,%esp
  807040:	6a ec                	push   $0xffffffec
  807042:	53                   	push   %ebx
  807043:	e8 d5 d6 ff ff       	call   80471d <pbuf_header>
      pbuf_cat(p, r);
  807048:	83 c4 08             	add    $0x8,%esp
  80704b:	53                   	push   %ebx
  80704c:	57                   	push   %edi
  80704d:	e8 18 dc ff ff       	call   804c6a <pbuf_cat>
      r = iprh->next_pbuf;
  807052:	8b 1e                	mov    (%esi),%ebx
  807054:	83 c4 10             	add    $0x10,%esp
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807057:	85 db                	test   %ebx,%ebx
  807059:	75 df                	jne    80703a <ip_reass+0x45a>
  80705b:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80705e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807061:	89 f8                	mov    %edi,%eax
  807063:	e8 58 f9 ff ff       	call   8069c0 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  807068:	83 ec 0c             	sub    $0xc,%esp
  80706b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80706e:	56                   	push   %esi
  80706f:	e8 cd db ff ff       	call   804c41 <pbuf_clen>
  807074:	0f b6 c0             	movzbl %al,%eax
  807077:	66 29 05 9c 4a b3 00 	sub    %ax,0xb34a9c

    /* Return the pbuf chain */
    return p;
  80707e:	83 c4 10             	add    $0x10,%esp
  807081:	89 f0                	mov    %esi,%eax
  807083:	eb 44                	jmp    8070c9 <ip_reass+0x4e9>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  807085:	83 ec 0c             	sub    $0xc,%esp
  807088:	ff 75 08             	pushl  0x8(%ebp)
  80708b:	e8 5f d7 ff ff       	call   8047ef <pbuf_free>
  return NULL;
  807090:	83 c4 10             	add    $0x10,%esp
  807093:	b8 00 00 00 00       	mov    $0x0,%eax
  807098:	eb 2f                	jmp    8070c9 <ip_reass+0x4e9>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  80709a:	b8 00 00 00 00       	mov    $0x0,%eax
  80709f:	eb 28                	jmp    8070c9 <ip_reass+0x4e9>
  8070a1:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8070a4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  8070a7:	85 f6                	test   %esi,%esi
  8070a9:	0f 85 ed fd ff ff    	jne    806e9c <ip_reass+0x2bc>
  8070af:	e9 20 fe ff ff       	jmp    806ed4 <ip_reass+0x2f4>
  8070b4:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8070b7:	85 c9                	test   %ecx,%ecx
  8070b9:	0f 85 9b fe ff ff    	jne    806f5a <ip_reass+0x37a>
  8070bf:	e9 7f fe ff ff       	jmp    806f43 <ip_reass+0x363>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  8070c4:	b8 00 00 00 00       	mov    $0x0,%eax
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  8070c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8070cc:	5b                   	pop    %ebx
  8070cd:	5e                   	pop    %esi
  8070ce:	5f                   	pop    %edi
  8070cf:	5d                   	pop    %ebp
  8070d0:	c3                   	ret    

008070d1 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8070d1:	55                   	push   %ebp
  8070d2:	89 e5                	mov    %esp,%ebp
  8070d4:	57                   	push   %edi
  8070d5:	56                   	push   %esi
  8070d6:	53                   	push   %ebx
  8070d7:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  8070da:	8b 45 0c             	mov    0xc(%ebp),%eax
  8070dd:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8070e1:	6a 02                	push   $0x2
  8070e3:	6a 00                	push   $0x0
  8070e5:	6a 02                	push   $0x2
  8070e7:	e8 c9 d7 ff ff       	call   8048b5 <pbuf_alloc>
  8070ec:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8070ef:	83 c4 10             	add    $0x10,%esp
  8070f2:	85 c0                	test   %eax,%eax
  8070f4:	0f 84 a8 01 00 00    	je     8072a2 <ip_frag+0x1d1>
  8070fa:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8070fc:	66 89 58 0a          	mov    %bx,0xa(%eax)
  807100:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807104:	b8 c3 44 b3 00       	mov    $0xb344c3,%eax
  807109:	83 e0 fc             	and    $0xfffffffc,%eax
  80710c:	89 c7                	mov    %eax,%edi
  80710e:	89 7e 04             	mov    %edi,0x4(%esi)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  807111:	83 ec 04             	sub    $0x4,%esp
  807114:	6a 14                	push   $0x14
  807116:	8b 45 08             	mov    0x8(%ebp),%eax
  807119:	ff 70 04             	pushl  0x4(%eax)
  80711c:	57                   	push   %edi
  80711d:	e8 19 7b 00 00       	call   80ec3b <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  807122:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  807126:	89 04 24             	mov    %eax,(%esp)
  807129:	e8 2c 05 00 00       	call   80765a <ntohs>
  ofo = tmp & IP_OFFMASK;
  80712e:	89 c6                	mov    %eax,%esi
  807130:	66 81 e6 ff 1f       	and    $0x1fff,%si
  807135:	66 89 75 e2          	mov    %si,-0x1e(%ebp)
  omf = tmp & IP_MF;
  807139:	66 25 00 20          	and    $0x2000,%ax
  80713d:	66 89 45 da          	mov    %ax,-0x26(%ebp)

  left = p->tot_len - IP_HLEN;
  807141:	8b 45 08             	mov    0x8(%ebp),%eax
  807144:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807148:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80714c:	8d 70 ec             	lea    -0x14(%eax),%esi

  nfb = (mtu - IP_HLEN) / 8;
  80714f:	0f b7 db             	movzwl %bx,%ebx
  807152:	8d 43 f3             	lea    -0xd(%ebx),%eax
  807155:	83 c4 10             	add    $0x10,%esp
  807158:	83 eb 14             	sub    $0x14,%ebx
  80715b:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  80715e:	0f 49 c3             	cmovns %ebx,%eax
  807161:	c1 f8 03             	sar    $0x3,%eax
  807164:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  807168:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80716e:	c1 e0 03             	shl    $0x3,%eax
  807171:	66 89 45 ce          	mov    %ax,-0x32(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807175:	8d 47 14             	lea    0x14(%edi),%eax
  807178:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80717b:	e9 04 01 00 00       	jmp    807284 <ip_frag+0x1b3>
    last = (left <= mtu - IP_HLEN);
  807180:	0f b7 c6             	movzwl %si,%eax
  807183:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  807186:	0f 9d c0             	setge  %al
  807189:	0f b6 c0             	movzbl %al,%eax
  80718c:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807190:	0f b7 5d e2          	movzwl -0x1e(%ebp),%ebx
  807194:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  807199:	66 0b 5d da          	or     -0x26(%ebp),%bx
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80719d:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  8071a1:	66 85 c0             	test   %ax,%ax
  8071a4:	75 0b                	jne    8071b1 <ip_frag+0xe0>
      tmp = tmp | IP_MF;
  8071a6:	80 cf 20             	or     $0x20,%bh

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8071a9:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  8071ad:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8071b1:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8071b5:	50                   	push   %eax
  8071b6:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8071ba:	50                   	push   %eax
  8071bb:	ff 75 d0             	pushl  -0x30(%ebp)
  8071be:	ff 75 08             	pushl  0x8(%ebp)
  8071c1:	e8 7f dd ff ff       	call   804f45 <pbuf_copy_partial>
  8071c6:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8071ca:	0f b7 db             	movzwl %bx,%ebx
  8071cd:	89 1c 24             	mov    %ebx,(%esp)
  8071d0:	e8 78 04 00 00       	call   80764d <htons>
  8071d5:	66 89 47 06          	mov    %ax,0x6(%edi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8071d9:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  8071dd:	8d 41 14             	lea    0x14(%ecx),%eax
  8071e0:	0f b7 c0             	movzwl %ax,%eax
  8071e3:	89 04 24             	mov    %eax,(%esp)
  8071e6:	e8 62 04 00 00       	call   80764d <htons>
  8071eb:	66 89 47 02          	mov    %ax,0x2(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  8071ef:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8071f5:	83 c4 08             	add    $0x8,%esp
  8071f8:	6a 14                	push   $0x14
  8071fa:	57                   	push   %edi
  8071fb:	e8 26 03 00 00       	call   807526 <inet_chksum>
  807200:	66 89 47 0a          	mov    %ax,0xa(%edi)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  807204:	83 c4 10             	add    $0x10,%esp
  807207:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  80720c:	74 15                	je     807223 <ip_frag+0x152>
      pbuf_realloc(rambuf, left + IP_HLEN);
  80720e:	83 ec 08             	sub    $0x8,%esp
  807211:	8d 46 14             	lea    0x14(%esi),%eax
  807214:	0f b7 c0             	movzwl %ax,%eax
  807217:	50                   	push   %eax
  807218:	ff 75 dc             	pushl  -0x24(%ebp)
  80721b:	e8 14 d9 ff ff       	call   804b34 <pbuf_realloc>
  807220:	83 c4 10             	add    $0x10,%esp
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  807223:	83 ec 04             	sub    $0x4,%esp
  807226:	6a 00                	push   $0x0
  807228:	6a 00                	push   $0x0
  80722a:	6a 02                	push   $0x2
  80722c:	e8 84 d6 ff ff       	call   8048b5 <pbuf_alloc>
  807231:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  807233:	83 c4 10             	add    $0x10,%esp
  807236:	85 c0                	test   %eax,%eax
  807238:	74 35                	je     80726f <ip_frag+0x19e>
      pbuf_chain(header, rambuf);
  80723a:	83 ec 08             	sub    $0x8,%esp
  80723d:	ff 75 dc             	pushl  -0x24(%ebp)
  807240:	50                   	push   %eax
  807241:	e8 90 da ff ff       	call   804cd6 <pbuf_chain>
      netif->output(netif, header, dest);
  807246:	83 c4 0c             	add    $0xc,%esp
  807249:	ff 75 10             	pushl  0x10(%ebp)
  80724c:	53                   	push   %ebx
  80724d:	ff 75 0c             	pushl  0xc(%ebp)
  807250:	8b 45 0c             	mov    0xc(%ebp),%eax
  807253:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  807256:	89 1c 24             	mov    %ebx,(%esp)
  807259:	e8 91 d5 ff ff       	call   8047ef <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  80725e:	66 2b 75 e6          	sub    -0x1a(%ebp),%si
    ofo += nfb;
  807262:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  807266:	66 01 55 e2          	add    %dx,-0x1e(%ebp)
  80726a:	83 c4 10             	add    $0x10,%esp
  80726d:	eb 15                	jmp    807284 <ip_frag+0x1b3>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80726f:	83 ec 0c             	sub    $0xc,%esp
  807272:	ff 75 dc             	pushl  -0x24(%ebp)
  807275:	e8 75 d5 ff ff       	call   8047ef <pbuf_free>
      return ERR_MEM;
  80727a:	83 c4 10             	add    $0x10,%esp
  80727d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807282:	eb 23                	jmp    8072a7 <ip_frag+0x1d6>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807284:	66 85 f6             	test   %si,%si
  807287:	0f 85 f3 fe ff ff    	jne    807180 <ip_frag+0xaf>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80728d:	83 ec 0c             	sub    $0xc,%esp
  807290:	ff 75 dc             	pushl  -0x24(%ebp)
  807293:	e8 57 d5 ff ff       	call   8047ef <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807298:	83 c4 10             	add    $0x10,%esp
  80729b:	b8 00 00 00 00       	mov    $0x0,%eax
  8072a0:	eb 05                	jmp    8072a7 <ip_frag+0x1d6>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  8072a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  8072a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8072aa:	5b                   	pop    %ebx
  8072ab:	5e                   	pop    %esi
  8072ac:	5f                   	pop    %edi
  8072ad:	5d                   	pop    %ebp
  8072ae:	c3                   	ret    

008072af <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8072af:	55                   	push   %ebp
  8072b0:	89 e5                	mov    %esp,%ebp
  8072b2:	57                   	push   %edi
  8072b3:	56                   	push   %esi
  8072b4:	53                   	push   %ebx
  8072b5:	83 ec 1c             	sub    $0x1c,%esp
  8072b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  8072bb:	89 c3                	mov    %eax,%ebx
  while (len > 1) {
  8072bd:	89 d6                	mov    %edx,%esi
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8072bf:	bf 00 00 00 00       	mov    $0x0,%edi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8072c4:	eb 17                	jmp    8072dd <lwip_standard_chksum+0x2e>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8072c6:	0f b6 03             	movzbl (%ebx),%eax
  8072c9:	c1 e0 08             	shl    $0x8,%eax
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8072cc:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8072d0:	09 c8                	or     %ecx,%eax
  8072d2:	83 c3 02             	add    $0x2,%ebx
    octetptr++;
    acc += src;
  8072d5:	0f b7 c0             	movzwl %ax,%eax
  8072d8:	01 c7                	add    %eax,%edi
    len -= 2;
  8072da:	83 ee 02             	sub    $0x2,%esi
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8072dd:	66 83 fe 01          	cmp    $0x1,%si
  8072e1:	77 e3                	ja     8072c6 <lwip_standard_chksum+0x17>
  8072e3:	89 d0                	mov    %edx,%eax
  8072e5:	25 fe ff 00 00       	and    $0xfffe,%eax
  8072ea:	03 45 e4             	add    -0x1c(%ebp),%eax
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8072ed:	f6 c2 01             	test   $0x1,%dl
  8072f0:	74 0b                	je     8072fd <lwip_standard_chksum+0x4e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8072f2:	0f b6 00             	movzbl (%eax),%eax
  8072f5:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8072f8:	0f b7 c0             	movzwl %ax,%eax
  8072fb:	01 c7                	add    %eax,%edi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8072fd:	89 f8                	mov    %edi,%eax
  8072ff:	c1 e8 10             	shr    $0x10,%eax
  807302:	0f b7 ff             	movzwl %di,%edi
  807305:	01 c7                	add    %eax,%edi
  if ((acc & 0xffff0000) != 0) {
  807307:	f7 c7 00 00 ff ff    	test   $0xffff0000,%edi
  80730d:	74 0a                	je     807319 <lwip_standard_chksum+0x6a>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80730f:	89 f8                	mov    %edi,%eax
  807311:	c1 e8 10             	shr    $0x10,%eax
  807314:	0f b7 ff             	movzwl %di,%edi
  807317:	01 c7                	add    %eax,%edi
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807319:	83 ec 0c             	sub    $0xc,%esp
  80731c:	0f b7 ff             	movzwl %di,%edi
  80731f:	57                   	push   %edi
  807320:	e8 28 03 00 00       	call   80764d <htons>
}
  807325:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807328:	5b                   	pop    %ebx
  807329:	5e                   	pop    %esi
  80732a:	5f                   	pop    %edi
  80732b:	5d                   	pop    %ebp
  80732c:	c3                   	ret    

0080732d <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80732d:	55                   	push   %ebp
  80732e:	89 e5                	mov    %esp,%ebp
  807330:	57                   	push   %edi
  807331:	56                   	push   %esi
  807332:	53                   	push   %ebx
  807333:	83 ec 1c             	sub    $0x1c,%esp
  807336:	8b 75 08             	mov    0x8(%ebp),%esi
  807339:	8b 45 14             	mov    0x14(%ebp),%eax
  80733c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80733f:	8b 45 18             	mov    0x18(%ebp),%eax
  807342:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807345:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80734a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80734f:	89 f8                	mov    %edi,%eax
  807351:	89 df                	mov    %ebx,%edi
  807353:	89 c3                	mov    %eax,%ebx
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807355:	eb 3d                	jmp    807394 <inet_chksum_pseudo+0x67>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807357:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80735b:	8b 46 04             	mov    0x4(%esi),%eax
  80735e:	e8 4c ff ff ff       	call   8072af <lwip_standard_chksum>
  807363:	0f b7 c0             	movzwl %ax,%eax
  807366:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807368:	89 c7                	mov    %eax,%edi
  80736a:	c1 ef 10             	shr    $0x10,%edi
  80736d:	0f b7 c0             	movzwl %ax,%eax
  807370:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807372:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807376:	74 1a                	je     807392 <inet_chksum_pseudo+0x65>
      swapped = 1 - swapped;
  807378:	b8 01 00 00 00       	mov    $0x1,%eax
  80737d:	29 d8                	sub    %ebx,%eax
  80737f:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807381:	89 fa                	mov    %edi,%edx
  807383:	c1 e2 08             	shl    $0x8,%edx
  807386:	0f b7 d2             	movzwl %dx,%edx
  807389:	89 f8                	mov    %edi,%eax
  80738b:	0f b6 c4             	movzbl %ah,%eax
  80738e:	09 d0                	or     %edx,%eax
  807390:	89 c7                	mov    %eax,%edi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807392:	8b 36                	mov    (%esi),%esi
  807394:	85 f6                	test   %esi,%esi
  807396:	75 bf                	jne    807357 <inet_chksum_pseudo+0x2a>
  807398:	89 d8                	mov    %ebx,%eax
  80739a:	89 fb                	mov    %edi,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80739c:	84 c0                	test   %al,%al
  80739e:	74 0d                	je     8073ad <inet_chksum_pseudo+0x80>
    acc = SWAP_BYTES_IN_WORD(acc);
  8073a0:	89 f8                	mov    %edi,%eax
  8073a2:	c1 e0 08             	shl    $0x8,%eax
  8073a5:	0f b7 c0             	movzwl %ax,%eax
  8073a8:	0f b6 df             	movzbl %bh,%ebx
  8073ab:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  8073ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  8073b0:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8073b2:	8b 45 10             	mov    0x10(%ebp),%eax
  8073b5:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  8073b7:	89 d1                	mov    %edx,%ecx
  8073b9:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  8073bc:	0f b7 d2             	movzwl %dx,%edx
  8073bf:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8073c1:	0f b7 c8             	movzwl %ax,%ecx
  8073c4:	01 ca                	add    %ecx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8073c6:	c1 e8 10             	shr    $0x10,%eax
  8073c9:	01 d0                	add    %edx,%eax
  8073cb:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  8073cd:	83 ec 0c             	sub    $0xc,%esp
  8073d0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8073d4:	50                   	push   %eax
  8073d5:	e8 73 02 00 00       	call   80764d <htons>
  8073da:	0f b7 c0             	movzwl %ax,%eax
  8073dd:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  8073df:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8073e3:	89 04 24             	mov    %eax,(%esp)
  8073e6:	e8 62 02 00 00       	call   80764d <htons>
  8073eb:	0f b7 c0             	movzwl %ax,%eax
  8073ee:	01 d8                	add    %ebx,%eax

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8073f0:	89 c2                	mov    %eax,%edx
  8073f2:	c1 ea 10             	shr    $0x10,%edx
  8073f5:	0f b7 c0             	movzwl %ax,%eax
  8073f8:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  8073fa:	89 c2                	mov    %eax,%edx
  8073fc:	c1 ea 10             	shr    $0x10,%edx
  8073ff:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807401:	f7 d0                	not    %eax
}
  807403:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807406:	5b                   	pop    %ebx
  807407:	5e                   	pop    %esi
  807408:	5f                   	pop    %edi
  807409:	5d                   	pop    %ebp
  80740a:	c3                   	ret    

0080740b <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80740b:	55                   	push   %ebp
  80740c:	89 e5                	mov    %esp,%ebp
  80740e:	57                   	push   %edi
  80740f:	56                   	push   %esi
  807410:	53                   	push   %ebx
  807411:	83 ec 1c             	sub    $0x1c,%esp
  807414:	8b 75 08             	mov    0x8(%ebp),%esi
  807417:	8b 45 14             	mov    0x14(%ebp),%eax
  80741a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80741d:	8b 45 18             	mov    0x18(%ebp),%eax
  807420:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807423:	0f b7 5d 1c          	movzwl 0x1c(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807427:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  80742b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807432:	eb 6e                	jmp    8074a2 <inet_chksum_pseudo_partial+0x97>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807434:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  807438:	66 39 fb             	cmp    %di,%bx
  80743b:	0f 46 fb             	cmovbe %ebx,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80743e:	0f b7 d7             	movzwl %di,%edx
  807441:	8b 46 04             	mov    0x4(%esi),%eax
  807444:	e8 66 fe ff ff       	call   8072af <lwip_standard_chksum>
  807449:	0f b7 c0             	movzwl %ax,%eax
  80744c:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  80744f:	29 fb                	sub    %edi,%ebx
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807451:	66 81 fb fe 7f       	cmp    $0x7ffe,%bx
  807456:	76 17                	jbe    80746f <inet_chksum_pseudo_partial+0x64>
  807458:	83 ec 04             	sub    $0x4,%esp
  80745b:	68 ed 1e 81 00       	push   $0x811eed
  807460:	68 60 01 00 00       	push   $0x160
  807465:	68 f8 1e 81 00       	push   $0x811ef8
  80746a:	e8 72 6f 00 00       	call   80e3e1 <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80746f:	89 c2                	mov    %eax,%edx
  807471:	c1 ea 10             	shr    $0x10,%edx
  807474:	0f b7 c0             	movzwl %ax,%eax
  807477:	01 d0                	add    %edx,%eax
  807479:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80747c:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807480:	74 1e                	je     8074a0 <inet_chksum_pseudo_partial+0x95>
      swapped = 1 - swapped;
  807482:	b8 01 00 00 00       	mov    $0x1,%eax
  807487:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80748a:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80748d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807490:	89 c2                	mov    %eax,%edx
  807492:	c1 e2 08             	shl    $0x8,%edx
  807495:	0f b7 d2             	movzwl %dx,%edx
  807498:	0f b6 c4             	movzbl %ah,%eax
  80749b:	09 d0                	or     %edx,%eax
  80749d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8074a0:	8b 36                	mov    (%esi),%esi
  8074a2:	66 85 db             	test   %bx,%bx
  8074a5:	74 04                	je     8074ab <inet_chksum_pseudo_partial+0xa0>
  8074a7:	85 f6                	test   %esi,%esi
  8074a9:	75 89                	jne    807434 <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8074ab:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8074af:	74 13                	je     8074c4 <inet_chksum_pseudo_partial+0xb9>
    acc = SWAP_BYTES_IN_WORD(acc);
  8074b1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8074b4:	89 c8                	mov    %ecx,%eax
  8074b6:	c1 e0 08             	shl    $0x8,%eax
  8074b9:	0f b7 c0             	movzwl %ax,%eax
  8074bc:	0f b6 d5             	movzbl %ch,%edx
  8074bf:	09 c2                	or     %eax,%edx
  8074c1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  8074c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8074c7:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8074c9:	8b 45 10             	mov    0x10(%ebp),%eax
  8074cc:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  8074ce:	89 d1                	mov    %edx,%ecx
  8074d0:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  8074d3:	0f b7 d2             	movzwl %dx,%edx
  8074d6:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8074d8:	0f b7 d8             	movzwl %ax,%ebx
  8074db:	01 d3                	add    %edx,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8074dd:	c1 e8 10             	shr    $0x10,%eax
  8074e0:	01 c3                	add    %eax,%ebx
  8074e2:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8074e5:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons((u16_t)proto);
  8074e7:	83 ec 0c             	sub    $0xc,%esp
  8074ea:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  8074ee:	50                   	push   %eax
  8074ef:	e8 59 01 00 00       	call   80764d <htons>
  8074f4:	0f b7 c0             	movzwl %ax,%eax
  8074f7:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  acc += (u32_t)htons(proto_len);
  8074fa:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  8074fe:	89 04 24             	mov    %eax,(%esp)
  807501:	e8 47 01 00 00       	call   80764d <htons>
  807506:	0f b7 c0             	movzwl %ax,%eax
  807509:	01 d8                	add    %ebx,%eax

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80750b:	89 c2                	mov    %eax,%edx
  80750d:	c1 ea 10             	shr    $0x10,%edx
  807510:	0f b7 c0             	movzwl %ax,%eax
  807513:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  807515:	89 c2                	mov    %eax,%edx
  807517:	c1 ea 10             	shr    $0x10,%edx
  80751a:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80751c:	f7 d0                	not    %eax
}
  80751e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807521:	5b                   	pop    %ebx
  807522:	5e                   	pop    %esi
  807523:	5f                   	pop    %edi
  807524:	5d                   	pop    %ebp
  807525:	c3                   	ret    

00807526 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807526:	55                   	push   %ebp
  807527:	89 e5                	mov    %esp,%ebp
  807529:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80752c:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807530:	8b 45 08             	mov    0x8(%ebp),%eax
  807533:	e8 77 fd ff ff       	call   8072af <lwip_standard_chksum>
  807538:	f7 d0                	not    %eax
}
  80753a:	c9                   	leave  
  80753b:	c3                   	ret    

0080753c <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80753c:	55                   	push   %ebp
  80753d:	89 e5                	mov    %esp,%ebp
  80753f:	57                   	push   %edi
  807540:	56                   	push   %esi
  807541:	53                   	push   %ebx
  807542:	83 ec 0c             	sub    $0xc,%esp
  807545:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807548:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80754d:	bb 00 00 00 00       	mov    $0x0,%ebx
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807552:	eb 3b                	jmp    80758f <inet_chksum_pbuf+0x53>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807554:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807558:	8b 46 04             	mov    0x4(%esi),%eax
  80755b:	e8 4f fd ff ff       	call   8072af <lwip_standard_chksum>
  807560:	0f b7 c0             	movzwl %ax,%eax
  807563:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  807565:	89 d8                	mov    %ebx,%eax
  807567:	c1 e8 10             	shr    $0x10,%eax
  80756a:	0f b7 db             	movzwl %bx,%ebx
  80756d:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  80756f:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807573:	74 18                	je     80758d <inet_chksum_pbuf+0x51>
      swapped = 1 - swapped;
  807575:	b8 01 00 00 00       	mov    $0x1,%eax
  80757a:	89 f9                	mov    %edi,%ecx
  80757c:	29 c8                	sub    %ecx,%eax
  80757e:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807580:	89 da                	mov    %ebx,%edx
  807582:	c1 e2 08             	shl    $0x8,%edx
  807585:	0f b7 d2             	movzwl %dx,%edx
  807588:	0f b6 df             	movzbl %bh,%ebx
  80758b:	09 d3                	or     %edx,%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80758d:	8b 36                	mov    (%esi),%esi
  80758f:	85 f6                	test   %esi,%esi
  807591:	75 c1                	jne    807554 <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807593:	89 f8                	mov    %edi,%eax
  807595:	84 c0                	test   %al,%al
  807597:	74 0d                	je     8075a6 <inet_chksum_pbuf+0x6a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807599:	89 da                	mov    %ebx,%edx
  80759b:	c1 e2 08             	shl    $0x8,%edx
  80759e:	0f b7 d2             	movzwl %dx,%edx
  8075a1:	0f b6 df             	movzbl %bh,%ebx
  8075a4:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  8075a6:	89 d8                	mov    %ebx,%eax
  8075a8:	f7 d0                	not    %eax
}
  8075aa:	83 c4 0c             	add    $0xc,%esp
  8075ad:	5b                   	pop    %ebx
  8075ae:	5e                   	pop    %esi
  8075af:	5f                   	pop    %edi
  8075b0:	5d                   	pop    %ebp
  8075b1:	c3                   	ret    

008075b2 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  8075b2:	55                   	push   %ebp
  8075b3:	89 e5                	mov    %esp,%ebp
  8075b5:	57                   	push   %edi
  8075b6:	56                   	push   %esi
  8075b7:	53                   	push   %ebx
  8075b8:	83 ec 14             	sub    $0x14,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  8075bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8075be:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  8075c1:	8d 7d f0             	lea    -0x10(%ebp),%edi
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  8075c4:	c7 45 e0 a4 4a b3 00 	movl   $0xb34aa4,-0x20(%ebp)
  8075cb:	0f b6 1f             	movzbl (%edi),%ebx
  8075ce:	b9 00 00 00 00       	mov    $0x0,%ecx
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  8075d3:	0f b6 d3             	movzbl %bl,%edx
  8075d6:	8d 04 92             	lea    (%edx,%edx,4),%eax
  8075d9:	8d 04 c2             	lea    (%edx,%eax,8),%eax
  8075dc:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8075df:	66 c1 e8 0b          	shr    $0xb,%ax
  8075e3:	89 c2                	mov    %eax,%edx
  8075e5:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8075e8:	01 c0                	add    %eax,%eax
  8075ea:	29 c3                	sub    %eax,%ebx
  8075ec:	89 d8                	mov    %ebx,%eax
      *ap /= (u8_t)10;
  8075ee:	89 d3                	mov    %edx,%ebx
      inv[i++] = '0' + rem;
  8075f0:	8d 71 01             	lea    0x1(%ecx),%esi
  8075f3:	0f b6 c9             	movzbl %cl,%ecx
  8075f6:	83 c0 30             	add    $0x30,%eax
  8075f9:	88 44 0d ed          	mov    %al,-0x13(%ebp,%ecx,1)
  8075fd:	89 f1                	mov    %esi,%ecx
    } while(*ap);
  8075ff:	84 d2                	test   %dl,%dl
  807601:	75 d0                	jne    8075d3 <inet_ntoa+0x21>
  807603:	89 f2                	mov    %esi,%edx
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
  807605:	89 f3                	mov    %esi,%ebx
  807607:	c6 07 00             	movb   $0x0,(%edi)
  80760a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80760d:	eb 0d                	jmp    80761c <inet_ntoa+0x6a>
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  80760f:	0f b6 c2             	movzbl %dl,%eax
  807612:	0f b6 44 05 ed       	movzbl -0x13(%ebp,%eax,1),%eax
  807617:	88 01                	mov    %al,(%ecx)
  807619:	83 c1 01             	add    $0x1,%ecx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80761c:	83 ea 01             	sub    $0x1,%edx
  80761f:	80 fa ff             	cmp    $0xff,%dl
  807622:	75 eb                	jne    80760f <inet_ntoa+0x5d>
  807624:	0f b6 db             	movzbl %bl,%ebx
  807627:	03 5d e0             	add    -0x20(%ebp),%ebx
      *rp++ = inv[i];
    *rp++ = '.';
  80762a:	8d 43 01             	lea    0x1(%ebx),%eax
  80762d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  807630:	c6 03 2e             	movb   $0x2e,(%ebx)
    ap++;
  807633:	83 c7 01             	add    $0x1,%edi
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807636:	8d 45 f4             	lea    -0xc(%ebp),%eax
  807639:	39 c7                	cmp    %eax,%edi
  80763b:	75 8e                	jne    8075cb <inet_ntoa+0x19>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  80763d:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  807640:	b8 a4 4a b3 00       	mov    $0xb34aa4,%eax
  807645:	83 c4 14             	add    $0x14,%esp
  807648:	5b                   	pop    %ebx
  807649:	5e                   	pop    %esi
  80764a:	5f                   	pop    %edi
  80764b:	5d                   	pop    %ebp
  80764c:	c3                   	ret    

0080764d <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80764d:	55                   	push   %ebp
  80764e:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807650:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807654:	66 c1 c0 08          	rol    $0x8,%ax
}
  807658:	5d                   	pop    %ebp
  807659:	c3                   	ret    

0080765a <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80765a:	55                   	push   %ebp
  80765b:	89 e5                	mov    %esp,%ebp
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  80765d:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807661:	66 c1 c0 08          	rol    $0x8,%ax
 */
u16_t
ntohs(u16_t n)
{
  return htons(n);
}
  807665:	5d                   	pop    %ebp
  807666:	c3                   	ret    

00807667 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807667:	55                   	push   %ebp
  807668:	89 e5                	mov    %esp,%ebp
  80766a:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  80766d:	89 d1                	mov    %edx,%ecx
  80766f:	c1 e9 18             	shr    $0x18,%ecx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807672:	89 d0                	mov    %edx,%eax
  807674:	c1 e0 18             	shl    $0x18,%eax
  807677:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807679:	89 d1                	mov    %edx,%ecx
  80767b:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807681:	c1 e1 08             	shl    $0x8,%ecx
  807684:	09 c8                	or     %ecx,%eax
    ((n & 0xff0000UL) >> 8) |
  807686:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80768c:	c1 ea 08             	shr    $0x8,%edx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  80768f:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807691:	5d                   	pop    %ebp
  807692:	c3                   	ret    

00807693 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807693:	55                   	push   %ebp
  807694:	89 e5                	mov    %esp,%ebp
  807696:	57                   	push   %edi
  807697:	56                   	push   %esi
  807698:	53                   	push   %ebx
  807699:	83 ec 1c             	sub    $0x1c,%esp
  80769c:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80769f:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  8076a2:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  8076a5:	89 75 d8             	mov    %esi,-0x28(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  8076a8:	8d 4a d0             	lea    -0x30(%edx),%ecx
  8076ab:	80 f9 09             	cmp    $0x9,%cl
  8076ae:	0f 87 a6 01 00 00    	ja     80785a <inet_aton+0x1c7>
      return (0);
    val = 0;
    base = 10;
  8076b4:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
    if (c == '0') {
  8076bb:	83 fa 30             	cmp    $0x30,%edx
  8076be:	75 2b                	jne    8076eb <inet_aton+0x58>
      c = *++cp;
  8076c0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  8076c4:	89 d1                	mov    %edx,%ecx
  8076c6:	83 e1 df             	and    $0xffffffdf,%ecx
  8076c9:	80 f9 58             	cmp    $0x58,%cl
  8076cc:	74 0f                	je     8076dd <inet_aton+0x4a>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  8076ce:	83 c0 01             	add    $0x1,%eax
  8076d1:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  8076d4:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  8076db:	eb 0e                	jmp    8076eb <inet_aton+0x58>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  8076dd:	0f be 50 02          	movsbl 0x2(%eax),%edx
  8076e1:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  8076e4:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  8076eb:	83 c0 01             	add    $0x1,%eax
  8076ee:	bf 00 00 00 00       	mov    $0x0,%edi
  8076f3:	eb 03                	jmp    8076f8 <inet_aton+0x65>
  8076f5:	83 c0 01             	add    $0x1,%eax
  8076f8:	8d 58 ff             	lea    -0x1(%eax),%ebx
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  8076fb:	89 d6                	mov    %edx,%esi
  8076fd:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807700:	80 f9 09             	cmp    $0x9,%cl
  807703:	77 0d                	ja     807712 <inet_aton+0x7f>
        val = (val * base) + (int)(c - '0');
  807705:	0f af 7d e0          	imul   -0x20(%ebp),%edi
  807709:	8d 7c 3a d0          	lea    -0x30(%edx,%edi,1),%edi
        c = *++cp;
  80770d:	0f be 10             	movsbl (%eax),%edx
  807710:	eb e3                	jmp    8076f5 <inet_aton+0x62>
      } else if (base == 16 && isxdigit(c)) {
  807712:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  807716:	75 2e                	jne    807746 <inet_aton+0xb3>
  807718:	8d 4e 9f             	lea    -0x61(%esi),%ecx
  80771b:	88 4d df             	mov    %cl,-0x21(%ebp)
  80771e:	89 d1                	mov    %edx,%ecx
  807720:	83 e1 df             	and    $0xffffffdf,%ecx
  807723:	83 e9 41             	sub    $0x41,%ecx
  807726:	80 f9 05             	cmp    $0x5,%cl
  807729:	77 21                	ja     80774c <inet_aton+0xb9>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80772b:	c1 e7 04             	shl    $0x4,%edi
  80772e:	83 c2 0a             	add    $0xa,%edx
  807731:	80 7d df 1a          	cmpb   $0x1a,-0x21(%ebp)
  807735:	19 c9                	sbb    %ecx,%ecx
  807737:	83 e1 20             	and    $0x20,%ecx
  80773a:	83 c1 41             	add    $0x41,%ecx
  80773d:	29 ca                	sub    %ecx,%edx
  80773f:	09 d7                	or     %edx,%edi
        c = *++cp;
  807741:	0f be 10             	movsbl (%eax),%edx
  807744:	eb af                	jmp    8076f5 <inet_aton+0x62>
  807746:	89 d0                	mov    %edx,%eax
  807748:	89 f9                	mov    %edi,%ecx
  80774a:	eb 04                	jmp    807750 <inet_aton+0xbd>
  80774c:	89 d0                	mov    %edx,%eax
  80774e:	89 f9                	mov    %edi,%ecx
      } else
        break;
    }
    if (c == '.') {
  807750:	83 f8 2e             	cmp    $0x2e,%eax
  807753:	75 23                	jne    807778 <inet_aton+0xe5>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807755:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807758:	8d 75 f0             	lea    -0x10(%ebp),%esi
  80775b:	39 f0                	cmp    %esi,%eax
  80775d:	0f 84 fe 00 00 00    	je     807861 <inet_aton+0x1ce>
        return (0);
      *pp++ = val;
  807763:	83 c0 04             	add    $0x4,%eax
  807766:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807769:	89 48 fc             	mov    %ecx,-0x4(%eax)
      c = *++cp;
  80776c:	8d 43 01             	lea    0x1(%ebx),%eax
  80776f:	0f be 53 01          	movsbl 0x1(%ebx),%edx
    } else
      break;
  }
  807773:	e9 30 ff ff ff       	jmp    8076a8 <inet_aton+0x15>
  807778:	89 f9                	mov    %edi,%ecx
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80777a:	85 d2                	test   %edx,%edx
  80777c:	74 29                	je     8077a7 <inet_aton+0x114>
    return (0);
  80777e:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807783:	89 f3                	mov    %esi,%ebx
  807785:	80 fb 1f             	cmp    $0x1f,%bl
  807788:	0f 86 e6 00 00 00    	jbe    807874 <inet_aton+0x1e1>
  80778e:	84 d2                	test   %dl,%dl
  807790:	0f 88 d2 00 00 00    	js     807868 <inet_aton+0x1d5>
  807796:	83 fa 20             	cmp    $0x20,%edx
  807799:	74 0c                	je     8077a7 <inet_aton+0x114>
  80779b:	83 ea 09             	sub    $0x9,%edx
  80779e:	83 fa 04             	cmp    $0x4,%edx
  8077a1:	0f 87 cd 00 00 00    	ja     807874 <inet_aton+0x1e1>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  8077a7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8077aa:	8b 55 d8             	mov    -0x28(%ebp),%edx
  8077ad:	29 c2                	sub    %eax,%edx
  8077af:	c1 fa 02             	sar    $0x2,%edx
  8077b2:	83 c2 01             	add    $0x1,%edx
  switch (n) {
  8077b5:	83 fa 02             	cmp    $0x2,%edx
  8077b8:	74 20                	je     8077da <inet_aton+0x147>
  8077ba:	83 fa 02             	cmp    $0x2,%edx
  8077bd:	7f 0f                	jg     8077ce <inet_aton+0x13b>

  case 0:
    return (0);       /* initial nondigit */
  8077bf:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  8077c4:	85 d2                	test   %edx,%edx
  8077c6:	0f 84 a8 00 00 00    	je     807874 <inet_aton+0x1e1>
  8077cc:	eb 71                	jmp    80783f <inet_aton+0x1ac>
  8077ce:	83 fa 03             	cmp    $0x3,%edx
  8077d1:	74 24                	je     8077f7 <inet_aton+0x164>
  8077d3:	83 fa 04             	cmp    $0x4,%edx
  8077d6:	74 40                	je     807818 <inet_aton+0x185>
  8077d8:	eb 65                	jmp    80783f <inet_aton+0x1ac>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  8077da:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  8077df:	81 f9 ff ff ff 00    	cmp    $0xffffff,%ecx
  8077e5:	0f 87 89 00 00 00    	ja     807874 <inet_aton+0x1e1>
      return (0);
    val |= parts[0] << 24;
  8077eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8077ee:	c1 e0 18             	shl    $0x18,%eax
  8077f1:	89 cf                	mov    %ecx,%edi
  8077f3:	09 c7                	or     %eax,%edi
    break;
  8077f5:	eb 48                	jmp    80783f <inet_aton+0x1ac>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  8077f7:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  8077fc:	81 f9 ff ff 00 00    	cmp    $0xffff,%ecx
  807802:	77 70                	ja     807874 <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807804:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807807:	c1 e2 10             	shl    $0x10,%edx
  80780a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80780d:	c1 e0 18             	shl    $0x18,%eax
  807810:	09 d0                	or     %edx,%eax
  807812:	09 c8                	or     %ecx,%eax
  807814:	89 c7                	mov    %eax,%edi
    break;
  807816:	eb 27                	jmp    80783f <inet_aton+0x1ac>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807818:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80781d:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  807823:	77 4f                	ja     807874 <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807825:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807828:	c1 e2 10             	shl    $0x10,%edx
  80782b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80782e:	c1 e0 18             	shl    $0x18,%eax
  807831:	09 c2                	or     %eax,%edx
  807833:	8b 45 ec             	mov    -0x14(%ebp),%eax
  807836:	c1 e0 08             	shl    $0x8,%eax
  807839:	09 d0                	or     %edx,%eax
  80783b:	09 c8                	or     %ecx,%eax
  80783d:	89 c7                	mov    %eax,%edi
    break;
  }
  if (addr)
  80783f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807843:	74 2a                	je     80786f <inet_aton+0x1dc>
    addr->s_addr = htonl(val);
  807845:	57                   	push   %edi
  807846:	e8 1c fe ff ff       	call   807667 <htonl>
  80784b:	83 c4 04             	add    $0x4,%esp
  80784e:	8b 75 0c             	mov    0xc(%ebp),%esi
  807851:	89 06                	mov    %eax,(%esi)
  return (1);
  807853:	b8 01 00 00 00       	mov    $0x1,%eax
  807858:	eb 1a                	jmp    807874 <inet_aton+0x1e1>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  80785a:	b8 00 00 00 00       	mov    $0x0,%eax
  80785f:	eb 13                	jmp    807874 <inet_aton+0x1e1>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  807861:	b8 00 00 00 00       	mov    $0x0,%eax
  807866:	eb 0c                	jmp    807874 <inet_aton+0x1e1>
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
    return (0);
  807868:	b8 00 00 00 00       	mov    $0x0,%eax
  80786d:	eb 05                	jmp    807874 <inet_aton+0x1e1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  80786f:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807874:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807877:	5b                   	pop    %ebx
  807878:	5e                   	pop    %esi
  807879:	5f                   	pop    %edi
  80787a:	5d                   	pop    %ebp
  80787b:	c3                   	ret    

0080787c <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80787c:	55                   	push   %ebp
  80787d:	89 e5                	mov    %esp,%ebp
  80787f:	83 ec 10             	sub    $0x10,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  807882:	8d 45 fc             	lea    -0x4(%ebp),%eax
  807885:	50                   	push   %eax
  807886:	ff 75 08             	pushl  0x8(%ebp)
  807889:	e8 05 fe ff ff       	call   807693 <inet_aton>
  80788e:	83 c4 08             	add    $0x8,%esp
    return (val.s_addr);
  807891:	85 c0                	test   %eax,%eax
  807893:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807898:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  80789c:	c9                   	leave  
  80789d:	c3                   	ret    

0080789e <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80789e:	55                   	push   %ebp
  80789f:	89 e5                	mov    %esp,%ebp
  return htonl(n);
  8078a1:	ff 75 08             	pushl  0x8(%ebp)
  8078a4:	e8 be fd ff ff       	call   807667 <htonl>
  8078a9:	83 c4 04             	add    $0x4,%esp
}
  8078ac:	c9                   	leave  
  8078ad:	c3                   	ret    

008078ae <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  8078ae:	55                   	push   %ebp
  8078af:	89 e5                	mov    %esp,%ebp
  8078b1:	57                   	push   %edi
  8078b2:	56                   	push   %esi
  8078b3:	53                   	push   %ebx
  8078b4:	83 ec 3c             	sub    $0x3c,%esp
  8078b7:	8b 7d 08             	mov    0x8(%ebp),%edi
  8078ba:	8b 45 10             	mov    0x10(%ebp),%eax
  8078bd:	89 c1                	mov    %eax,%ecx
  8078bf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  8078c2:	8b 45 14             	mov    0x14(%ebp),%eax
  8078c5:	89 c6                	mov    %eax,%esi
  8078c7:	89 45 bc             	mov    %eax,-0x44(%ebp)
  8078ca:	8b 45 18             	mov    0x18(%ebp),%eax
  8078cd:	89 c3                	mov    %eax,%ebx
  8078cf:	89 45 b8             	mov    %eax,-0x48(%ebp)
  8078d2:	8b 45 20             	mov    0x20(%ebp),%eax
  8078d5:	66 89 4d c2          	mov    %cx,-0x3e(%ebp)
  8078d9:	89 f2                	mov    %esi,%edx
  8078db:	88 55 d2             	mov    %dl,-0x2e(%ebp)
  8078de:	89 da                	mov    %ebx,%edx
  8078e0:	88 45 cb             	mov    %al,-0x35(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  8078e3:	66 85 c9             	test   %cx,%cx
  8078e6:	74 1b                	je     807903 <tcp_enqueue+0x55>
  8078e8:	84 c0                	test   %al,%al
  8078ea:	74 17                	je     807903 <tcp_enqueue+0x55>
  8078ec:	83 ec 04             	sub    $0x4,%esp
  8078ef:	68 1c 1f 81 00       	push   $0x811f1c
  8078f4:	68 90 00 00 00       	push   $0x90
  8078f9:	68 be 20 81 00       	push   $0x8120be
  8078fe:	e8 de 6a 00 00       	call   80e3e1 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807903:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807907:	0f 95 45 ca          	setne  -0x36(%ebp)
  80790b:	0f b6 4d ca          	movzbl -0x36(%ebp),%ecx
  80790f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807913:	0f 95 45 d3          	setne  -0x2d(%ebp)
  807917:	0f b6 5d d3          	movzbl -0x2d(%ebp),%ebx
  80791b:	84 c9                	test   %cl,%cl
  80791d:	74 1b                	je     80793a <tcp_enqueue+0x8c>
  80791f:	84 db                	test   %bl,%bl
  807921:	74 17                	je     80793a <tcp_enqueue+0x8c>
  807923:	83 ec 04             	sub    $0x4,%esp
  807926:	68 5c 1f 81 00       	push   $0x811f5c
  80792b:	68 92 00 00 00       	push   $0x92
  807930:	68 be 20 81 00       	push   $0x8120be
  807935:	e8 a7 6a 00 00       	call   80e3e1 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80793a:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  80793e:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  807942:	76 0e                	jbe    807952 <tcp_enqueue+0xa4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  807944:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807948:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80794d:	e9 d7 05 00 00       	jmp    807f29 <tcp_enqueue+0x67b>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807952:	8b 4f 68             	mov    0x68(%edi),%ecx
  807955:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807958:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  80795c:	66 89 4d dc          	mov    %cx,-0x24(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807960:	66 83 f9 1f          	cmp    $0x1f,%cx
  807964:	76 0e                	jbe    807974 <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  807966:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  80796a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80796f:	e9 b5 05 00 00       	jmp    807f29 <tcp_enqueue+0x67b>
  }
  if (queuelen != 0) {
  807974:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%ebp)
  807979:	74 58                	je     8079d3 <tcp_enqueue+0x125>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80797b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80797f:	74 35                	je     8079b6 <tcp_enqueue+0x108>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807981:	c0 e8 02             	shr    $0x2,%al
  807984:	c1 e0 0c             	shl    $0xc,%eax
  807987:	66 05 00 50          	add    $0x5000,%ax
  80798b:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  80798f:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807993:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807997:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80799b:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  8079a2:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8079a7:	83 e2 01             	and    $0x1,%edx
  8079aa:	88 55 c9             	mov    %dl,-0x37(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8079ad:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
  8079b1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8079b4:	eb 40                	jmp    8079f6 <tcp_enqueue+0x148>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8079b6:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8079ba:	75 c5                	jne    807981 <tcp_enqueue+0xd3>
  8079bc:	83 ec 04             	sub    $0x4,%esp
  8079bf:	68 a4 1f 81 00       	push   $0x811fa4
  8079c4:	68 ae 00 00 00       	push   $0xae
  8079c9:	68 be 20 81 00       	push   $0x8120be
  8079ce:	e8 0e 6a 00 00       	call   80e3e1 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8079d3:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8079d7:	75 06                	jne    8079df <tcp_enqueue+0x131>
  8079d9:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8079dd:	74 a2                	je     807981 <tcp_enqueue+0xd3>
  8079df:	83 ec 04             	sub    $0x4,%esp
  8079e2:	68 e0 1f 81 00       	push   $0x811fe0
  8079e7:	68 b1 00 00 00       	push   $0xb1
  8079ec:	68 be 20 81 00       	push   $0x8120be
  8079f1:	e8 eb 69 00 00       	call   80e3e1 <_panic>
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  8079f6:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  8079fa:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
  8079fe:	66 39 c2             	cmp    %ax,%dx
  807a01:	0f 46 c2             	cmovbe %edx,%eax
  807a04:	66 89 45 de          	mov    %ax,-0x22(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807a08:	83 ec 0c             	sub    $0xc,%esp
  807a0b:	6a 04                	push   $0x4
  807a0d:	e8 14 ca ff ff       	call   804426 <memp_malloc>
  807a12:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807a14:	83 c4 10             	add    $0x10,%esp
  807a17:	85 c0                	test   %eax,%eax
  807a19:	0f 84 9c 04 00 00    	je     807ebb <tcp_enqueue+0x60d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  807a1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807a25:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  807a2c:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
  807a30:	75 1f                	jne    807a51 <tcp_enqueue+0x1a3>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807a32:	85 f6                	test   %esi,%esi
  807a34:	75 17                	jne    807a4d <tcp_enqueue+0x19f>
  807a36:	83 ec 04             	sub    $0x4,%esp
  807a39:	68 d6 20 81 00       	push   $0x8120d6
  807a3e:	68 ce 00 00 00       	push   $0xce
  807a43:	68 be 20 81 00       	push   $0x8120be
  807a48:	e8 94 69 00 00       	call   80e3e1 <_panic>
      useg->next = seg;
  807a4d:	89 06                	mov    %eax,(%esi)
  807a4f:	eb 03                	jmp    807a54 <tcp_enqueue+0x1a6>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807a51:	89 45 cc             	mov    %eax,-0x34(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  807a54:	80 7d d3 00          	cmpb   $0x0,-0x2d(%ebp)
  807a58:	74 5f                	je     807ab9 <tcp_enqueue+0x20b>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a5a:	83 ec 04             	sub    $0x4,%esp
  807a5d:	6a 00                	push   $0x0
  807a5f:	ff 75 d4             	pushl  -0x2c(%ebp)
  807a62:	6a 00                	push   $0x0
  807a64:	e8 4c ce ff ff       	call   8048b5 <pbuf_alloc>
  807a69:	89 43 04             	mov    %eax,0x4(%ebx)
  807a6c:	83 c4 10             	add    $0x10,%esp
  807a6f:	85 c0                	test   %eax,%eax
  807a71:	0f 84 44 04 00 00    	je     807ebb <tcp_enqueue+0x60d>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807a77:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
  807a7b:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807a7f:	73 17                	jae    807a98 <tcp_enqueue+0x1ea>
  807a81:	83 ec 04             	sub    $0x4,%esp
  807a84:	68 14 20 81 00       	push   $0x812014
  807a89:	68 df 00 00 00       	push   $0xdf
  807a8e:	68 be 20 81 00       	push   $0x8120be
  807a93:	e8 49 69 00 00       	call   80e3e1 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  807a98:	83 ec 0c             	sub    $0xc,%esp
  807a9b:	50                   	push   %eax
  807a9c:	e8 a0 d1 ff ff       	call   804c41 <pbuf_clen>
  807aa1:	0f b6 c0             	movzbl %al,%eax
  807aa4:	66 01 45 dc          	add    %ax,-0x24(%ebp)
      seg->dataptr = seg->p->payload;
  807aa8:	8b 43 04             	mov    0x4(%ebx),%eax
  807aab:	8b 40 04             	mov    0x4(%eax),%eax
  807aae:	89 43 08             	mov    %eax,0x8(%ebx)
  807ab1:	83 c4 10             	add    $0x10,%esp
  807ab4:	e9 00 01 00 00       	jmp    807bb9 <tcp_enqueue+0x30b>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807ab9:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807abd:	74 7c                	je     807b3b <tcp_enqueue+0x28d>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807abf:	83 ec 04             	sub    $0x4,%esp
  807ac2:	6a 00                	push   $0x0
  807ac4:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  807ac8:	0f b7 c6             	movzwl %si,%eax
  807acb:	50                   	push   %eax
  807acc:	6a 00                	push   $0x0
  807ace:	e8 e2 cd ff ff       	call   8048b5 <pbuf_alloc>
  807ad3:	89 43 04             	mov    %eax,0x4(%ebx)
  807ad6:	83 c4 10             	add    $0x10,%esp
  807ad9:	85 c0                	test   %eax,%eax
  807adb:	0f 84 da 03 00 00    	je     807ebb <tcp_enqueue+0x60d>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807ae1:	66 3b 70 0a          	cmp    0xa(%eax),%si
  807ae5:	76 17                	jbe    807afe <tcp_enqueue+0x250>
  807ae7:	83 ec 04             	sub    $0x4,%esp
  807aea:	68 3c 20 81 00       	push   $0x81203c
  807aef:	68 ea 00 00 00       	push   $0xea
  807af4:	68 be 20 81 00       	push   $0x8120be
  807af9:	e8 e3 68 00 00       	call   80e3e1 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  807afe:	83 ec 0c             	sub    $0xc,%esp
  807b01:	50                   	push   %eax
  807b02:	e8 3a d1 ff ff       	call   804c41 <pbuf_clen>
  807b07:	0f b6 c0             	movzbl %al,%eax
  807b0a:	66 01 45 dc          	add    %ax,-0x24(%ebp)
      if (arg != NULL) {
  807b0e:	83 c4 10             	add    $0x10,%esp
  807b11:	80 7d ca 00          	cmpb   $0x0,-0x36(%ebp)
  807b15:	74 19                	je     807b30 <tcp_enqueue+0x282>
        MEMCPY(seg->p->payload, ptr, seglen);
  807b17:	83 ec 04             	sub    $0x4,%esp
  807b1a:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807b1e:	50                   	push   %eax
  807b1f:	ff 75 0c             	pushl  0xc(%ebp)
  807b22:	8b 43 04             	mov    0x4(%ebx),%eax
  807b25:	ff 70 04             	pushl  0x4(%eax)
  807b28:	e8 0e 71 00 00       	call   80ec3b <memcpy>
  807b2d:	83 c4 10             	add    $0x10,%esp
      }
      seg->dataptr = seg->p->payload;
  807b30:	8b 43 04             	mov    0x4(%ebx),%eax
  807b33:	8b 40 04             	mov    0x4(%eax),%eax
  807b36:	89 43 08             	mov    %eax,0x8(%ebx)
  807b39:	eb 7e                	jmp    807bb9 <tcp_enqueue+0x30b>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807b3b:	83 ec 04             	sub    $0x4,%esp
  807b3e:	6a 01                	push   $0x1
  807b40:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807b44:	50                   	push   %eax
  807b45:	6a 00                	push   $0x0
  807b47:	e8 69 cd ff ff       	call   8048b5 <pbuf_alloc>
  807b4c:	89 c6                	mov    %eax,%esi
  807b4e:	83 c4 10             	add    $0x10,%esp
  807b51:	85 c0                	test   %eax,%eax
  807b53:	0f 84 62 03 00 00    	je     807ebb <tcp_enqueue+0x60d>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  807b59:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  807b5d:	83 c0 01             	add    $0x1,%eax
  807b60:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  807b64:	8b 45 0c             	mov    0xc(%ebp),%eax
  807b67:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807b6a:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807b6d:	83 ec 04             	sub    $0x4,%esp
  807b70:	6a 00                	push   $0x0
  807b72:	6a 00                	push   $0x0
  807b74:	6a 00                	push   $0x0
  807b76:	e8 3a cd ff ff       	call   8048b5 <pbuf_alloc>
  807b7b:	89 43 04             	mov    %eax,0x4(%ebx)
  807b7e:	83 c4 10             	add    $0x10,%esp
  807b81:	85 c0                	test   %eax,%eax
  807b83:	75 11                	jne    807b96 <tcp_enqueue+0x2e8>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  807b85:	83 ec 0c             	sub    $0xc,%esp
  807b88:	56                   	push   %esi
  807b89:	e8 61 cc ff ff       	call   8047ef <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  807b8e:	83 c4 10             	add    $0x10,%esp
  807b91:	e9 25 03 00 00       	jmp    807ebb <tcp_enqueue+0x60d>
      }
      queuelen += pbuf_clen(seg->p);
  807b96:	83 ec 0c             	sub    $0xc,%esp
  807b99:	50                   	push   %eax
  807b9a:	e8 a2 d0 ff ff       	call   804c41 <pbuf_clen>
  807b9f:	0f b6 c0             	movzbl %al,%eax
  807ba2:	66 03 45 e0          	add    -0x20(%ebp),%ax
  807ba6:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807baa:	83 c4 08             	add    $0x8,%esp
  807bad:	56                   	push   %esi
  807bae:	ff 73 04             	pushl  0x4(%ebx)
  807bb1:	e8 b4 d0 ff ff       	call   804c6a <pbuf_cat>
  807bb6:	83 c4 10             	add    $0x10,%esp
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807bb9:	66 83 7d dc 20       	cmpw   $0x20,-0x24(%ebp)
  807bbe:	0f 87 f7 02 00 00    	ja     807ebb <tcp_enqueue+0x60d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  807bc4:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807bc8:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807bcc:	83 ec 08             	sub    $0x8,%esp
  807bcf:	6a 14                	push   $0x14
  807bd1:	ff 73 04             	pushl  0x4(%ebx)
  807bd4:	e8 44 cb ff ff       	call   80471d <pbuf_header>
  807bd9:	83 c4 10             	add    $0x10,%esp
  807bdc:	84 c0                	test   %al,%al
  807bde:	0f 85 d7 02 00 00    	jne    807ebb <tcp_enqueue+0x60d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  807be4:	8b 43 04             	mov    0x4(%ebx),%eax
  807be7:	8b 70 04             	mov    0x4(%eax),%esi
  807bea:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807bed:	83 ec 0c             	sub    $0xc,%esp
  807bf0:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807bf4:	50                   	push   %eax
  807bf5:	e8 53 fa ff ff       	call   80764d <htons>
  807bfa:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807bfd:	8b 73 10             	mov    0x10(%ebx),%esi
  807c00:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807c04:	89 04 24             	mov    %eax,(%esp)
  807c07:	e8 41 fa ff ff       	call   80764d <htons>
  807c0c:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807c10:	8b 73 10             	mov    0x10(%ebx),%esi
  807c13:	83 c4 04             	add    $0x4,%esp
  807c16:	ff 75 d8             	pushl  -0x28(%ebp)
  807c19:	e8 49 fa ff ff       	call   807667 <htonl>
  807c1e:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807c21:	8b 43 10             	mov    0x10(%ebx),%eax
  807c24:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807c2a:	8b 73 10             	mov    0x10(%ebx),%esi
  807c2d:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c31:	89 04 24             	mov    %eax,(%esp)
  807c34:	e8 21 fa ff ff       	call   80765a <ntohs>
  807c39:	83 e0 c0             	and    $0xffffffc0,%eax
  807c3c:	0f b6 55 d2          	movzbl -0x2e(%ebp),%edx
  807c40:	09 d0                	or     %edx,%eax
  807c42:	0f b7 c0             	movzwl %ax,%eax
  807c45:	89 04 24             	mov    %eax,(%esp)
  807c48:	e8 00 fa ff ff       	call   80764d <htons>
  807c4d:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  807c51:	83 c4 10             	add    $0x10,%esp
  807c54:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807c58:	75 27                	jne    807c81 <tcp_enqueue+0x3d3>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807c5a:	8b 73 10             	mov    0x10(%ebx),%esi
  807c5d:	83 ec 0c             	sub    $0xc,%esp
  807c60:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c64:	50                   	push   %eax
  807c65:	e8 f0 f9 ff ff       	call   80765a <ntohs>
  807c6a:	83 e0 3f             	and    $0x3f,%eax
  807c6d:	80 cc 50             	or     $0x50,%ah
  807c70:	89 04 24             	mov    %eax,(%esp)
  807c73:	e8 d5 f9 ff ff       	call   80764d <htons>
  807c78:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807c7c:	83 c4 10             	add    $0x10,%esp
  807c7f:	eb 3a                	jmp    807cbb <tcp_enqueue+0x40d>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807c81:	8b 73 10             	mov    0x10(%ebx),%esi
  807c84:	83 ec 0c             	sub    $0xc,%esp
  807c87:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c8b:	50                   	push   %eax
  807c8c:	e8 c9 f9 ff ff       	call   80765a <ntohs>
  807c91:	83 e0 3f             	and    $0x3f,%eax
  807c94:	66 0b 45 d0          	or     -0x30(%ebp),%ax
  807c98:	0f b7 c0             	movzwl %ax,%eax
  807c9b:	89 04 24             	mov    %eax,(%esp)
  807c9e:	e8 aa f9 ff ff       	call   80764d <htons>
  807ca3:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807ca7:	83 c4 0c             	add    $0xc,%esp
  807caa:	ff 75 d4             	pushl  -0x2c(%ebp)
  807cad:	ff 75 1c             	pushl  0x1c(%ebp)
  807cb0:	ff 73 08             	pushl  0x8(%ebx)
  807cb3:	e8 83 6f 00 00       	call   80ec3b <memcpy>
  807cb8:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  807cbb:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  807cbf:	66 29 55 e4          	sub    %dx,-0x1c(%ebp)
  807cc3:	0f b7 4d e4          	movzwl -0x1c(%ebp),%ecx
    seqno += seglen;
  807cc7:	0f b7 c2             	movzwl %dx,%eax
  807cca:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807ccd:	01 45 0c             	add    %eax,0xc(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807cd0:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  807cd4:	0f 94 45 e0          	sete   -0x20(%ebp)
  807cd8:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807cdc:	89 de                	mov    %ebx,%esi

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807cde:	84 c0                	test   %al,%al
  807ce0:	0f 85 10 fd ff ff    	jne    8079f6 <tcp_enqueue+0x148>
  807ce6:	66 85 c9             	test   %cx,%cx
  807ce9:	0f 85 07 fd ff ff    	jne    8079f6 <tcp_enqueue+0x148>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807cef:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807cf2:	8b 77 74             	mov    0x74(%edi),%esi
  807cf5:	85 f6                	test   %esi,%esi
  807cf7:	75 07                	jne    807d00 <tcp_enqueue+0x452>
  807cf9:	e9 00 01 00 00       	jmp    807dfe <tcp_enqueue+0x550>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807cfe:	89 c6                	mov    %eax,%esi
  807d00:	8b 06                	mov    (%esi),%eax
  807d02:	85 c0                	test   %eax,%eax
  807d04:	75 f8                	jne    807cfe <tcp_enqueue+0x450>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807d06:	85 f6                	test   %esi,%esi
  807d08:	0f 84 f0 00 00 00    	je     807dfe <tcp_enqueue+0x550>
    TCP_TCPLEN(useg) != 0 &&
  807d0e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807d12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807d15:	83 ec 0c             	sub    $0xc,%esp
  807d18:	8b 46 10             	mov    0x10(%esi),%eax
  807d1b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d1f:	50                   	push   %eax
  807d20:	e8 35 f9 ff ff       	call   80765a <ntohs>
  807d25:	83 c4 10             	add    $0x10,%esp
  807d28:	ba 01 00 00 00       	mov    $0x1,%edx
  807d2d:	a8 01                	test   $0x1,%al
  807d2f:	75 1b                	jne    807d4c <tcp_enqueue+0x49e>
  807d31:	83 ec 0c             	sub    $0xc,%esp
  807d34:	8b 46 10             	mov    0x10(%esi),%eax
  807d37:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d3b:	50                   	push   %eax
  807d3c:	e8 19 f9 ff ff       	call   80765a <ntohs>
  807d41:	66 d1 e8             	shr    %ax
  807d44:	89 c2                	mov    %eax,%edx
  807d46:	83 e2 01             	and    $0x1,%edx
  807d49:	83 c4 10             	add    $0x10,%esp
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807d4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807d4f:	01 d0                	add    %edx,%eax
  807d51:	0f 84 c8 01 00 00    	je     807f1f <tcp_enqueue+0x671>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807d57:	83 ec 0c             	sub    $0xc,%esp
  807d5a:	8b 46 10             	mov    0x10(%esi),%eax
  807d5d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d61:	50                   	push   %eax
  807d62:	e8 f3 f8 ff ff       	call   80765a <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807d67:	83 c4 10             	add    $0x10,%esp
  807d6a:	a8 03                	test   $0x3,%al
  807d6c:	0f 85 ad 01 00 00    	jne    807f1f <tcp_enqueue+0x671>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807d72:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807d76:	0f 85 a3 01 00 00    	jne    807f1f <tcp_enqueue+0x671>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  807d7c:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  807d80:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807d83:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d87:	01 d0                	add    %edx,%eax
  807d89:	0f b7 57 34          	movzwl 0x34(%edi),%edx
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807d8d:	39 d0                	cmp    %edx,%eax
  807d8f:	0f 8f 8a 01 00 00    	jg     807f1f <tcp_enqueue+0x671>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807d95:	83 ec 08             	sub    $0x8,%esp
  807d98:	6a ec                	push   $0xffffffec
  807d9a:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807d9d:	ff 70 04             	pushl  0x4(%eax)
  807da0:	e8 78 c9 ff ff       	call   80471d <pbuf_header>
  807da5:	83 c4 10             	add    $0x10,%esp
  807da8:	84 c0                	test   %al,%al
  807daa:	74 17                	je     807dc3 <tcp_enqueue+0x515>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807dac:	83 ec 04             	sub    $0x4,%esp
  807daf:	68 e3 20 81 00       	push   $0x8120e3
  807db4:	68 52 01 00 00       	push   $0x152
  807db9:	68 be 20 81 00       	push   $0x8120be
  807dbe:	e8 1e 66 00 00       	call   80e3e1 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807dc3:	83 ec 08             	sub    $0x8,%esp
  807dc6:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807dc9:	ff 70 04             	pushl  0x4(%eax)
  807dcc:	ff 76 04             	pushl  0x4(%esi)
  807dcf:	e8 96 ce ff ff       	call   804c6a <pbuf_cat>
    useg->len += queue->len;
  807dd4:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  807dd7:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  807ddb:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  807ddf:	8b 01                	mov    (%ecx),%eax
  807de1:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807de3:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807de6:	3b 4d e0             	cmp    -0x20(%ebp),%ecx
  807de9:	b8 00 00 00 00       	mov    $0x0,%eax
  807dee:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807df1:	51                   	push   %ecx
  807df2:	6a 04                	push   $0x4
  807df4:	e8 83 c6 ff ff       	call   80447c <memp_free>
  807df9:	83 c4 10             	add    $0x10,%esp
  807dfc:	eb 1f                	jmp    807e1d <tcp_enqueue+0x56f>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  807dfe:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807e01:	89 47 74             	mov    %eax,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807e04:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807e08:	83 e2 03             	and    $0x3,%edx
    ++len;
  807e0b:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807e0f:	83 c0 01             	add    $0x1,%eax
  807e12:	84 d2                	test   %dl,%dl
  807e14:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807e19:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  807e1d:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807e21:	74 04                	je     807e27 <tcp_enqueue+0x579>
    pcb->flags |= TF_FIN;
  807e23:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  807e27:	0f b7 4d c2          	movzwl -0x3e(%ebp),%ecx
  807e2b:	0f b7 c1             	movzwl %cx,%eax
  807e2e:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  807e31:	66 29 4f 6e          	sub    %cx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  807e35:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  807e39:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  807e3d:	66 85 c0             	test   %ax,%ax
  807e40:	74 23                	je     807e65 <tcp_enqueue+0x5b7>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807e42:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807e46:	75 1d                	jne    807e65 <tcp_enqueue+0x5b7>
  807e48:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807e4c:	75 17                	jne    807e65 <tcp_enqueue+0x5b7>
  807e4e:	83 ec 04             	sub    $0x4,%esp
  807e51:	68 70 20 81 00       	push   $0x812070
  807e56:	68 7a 01 00 00       	push   $0x17a
  807e5b:	68 be 20 81 00       	push   $0x8120be
  807e60:	e8 7c 65 00 00       	call   80e3e1 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807e65:	85 db                	test   %ebx,%ebx
  807e67:	0f 84 8f 00 00 00    	je     807efc <tcp_enqueue+0x64e>
  807e6d:	66 83 7d de 00       	cmpw   $0x0,-0x22(%ebp)
  807e72:	0f 84 84 00 00 00    	je     807efc <tcp_enqueue+0x64e>
  807e78:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807e7b:	85 db                	test   %ebx,%ebx
  807e7d:	0f 84 80 00 00 00    	je     807f03 <tcp_enqueue+0x655>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807e83:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807e88:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807e8c:	0f 85 97 00 00 00    	jne    807f29 <tcp_enqueue+0x67b>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807e92:	83 ec 0c             	sub    $0xc,%esp
  807e95:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  807e99:	50                   	push   %eax
  807e9a:	e8 bb f7 ff ff       	call   80765a <ntohs>
  807e9f:	83 c8 08             	or     $0x8,%eax
  807ea2:	0f b7 c0             	movzwl %ax,%eax
  807ea5:	89 04 24             	mov    %eax,(%esp)
  807ea8:	e8 a0 f7 ff ff       	call   80764d <htons>
  807ead:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807eb1:	83 c4 10             	add    $0x10,%esp
  }

  return ERR_OK;
  807eb4:	b8 00 00 00 00       	mov    $0x0,%eax
  807eb9:	eb 6e                	jmp    807f29 <tcp_enqueue+0x67b>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807ebb:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807ebf:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807ec2:	85 c0                	test   %eax,%eax
  807ec4:	74 0c                	je     807ed2 <tcp_enqueue+0x624>
    tcp_segs_free(queue);
  807ec6:	83 ec 0c             	sub    $0xc,%esp
  807ec9:	50                   	push   %eax
  807eca:	e8 b8 d8 ff ff       	call   805787 <tcp_segs_free>
  807ecf:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807ed2:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807ed7:	74 31                	je     807f0a <tcp_enqueue+0x65c>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807ed9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807edd:	75 32                	jne    807f11 <tcp_enqueue+0x663>
  807edf:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807ee3:	75 33                	jne    807f18 <tcp_enqueue+0x66a>
  807ee5:	83 ec 04             	sub    $0x4,%esp
  807ee8:	68 70 20 81 00       	push   $0x812070
  807eed:	68 8d 01 00 00       	push   $0x18d
  807ef2:	68 be 20 81 00       	push   $0x8120be
  807ef7:	e8 e5 64 00 00       	call   80e3e1 <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807efc:	b8 00 00 00 00       	mov    $0x0,%eax
  807f01:	eb 26                	jmp    807f29 <tcp_enqueue+0x67b>
  807f03:	b8 00 00 00 00       	mov    $0x0,%eax
  807f08:	eb 1f                	jmp    807f29 <tcp_enqueue+0x67b>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807f0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f0f:	eb 18                	jmp    807f29 <tcp_enqueue+0x67b>
  807f11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f16:	eb 11                	jmp    807f29 <tcp_enqueue+0x67b>
  807f18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f1d:	eb 0a                	jmp    807f29 <tcp_enqueue+0x67b>
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  807f1f:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807f22:	89 06                	mov    %eax,(%esi)
  807f24:	e9 db fe ff ff       	jmp    807e04 <tcp_enqueue+0x556>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  807f29:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807f2c:	5b                   	pop    %ebx
  807f2d:	5e                   	pop    %esi
  807f2e:	5f                   	pop    %edi
  807f2f:	5d                   	pop    %ebp
  807f30:	c3                   	ret    

00807f31 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  807f31:	55                   	push   %ebp
  807f32:	89 e5                	mov    %esp,%ebp
  807f34:	83 ec 0c             	sub    $0xc,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807f37:	6a 00                	push   $0x0
  807f39:	6a 00                	push   $0x0
  807f3b:	6a 01                	push   $0x1
  807f3d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807f41:	50                   	push   %eax
  807f42:	6a 00                	push   $0x0
  807f44:	6a 00                	push   $0x0
  807f46:	ff 75 08             	pushl  0x8(%ebp)
  807f49:	e8 60 f9 ff ff       	call   8078ae <tcp_enqueue>
}
  807f4e:	c9                   	leave  
  807f4f:	c3                   	ret    

00807f50 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  807f50:	55                   	push   %ebp
  807f51:	89 e5                	mov    %esp,%ebp
  807f53:	56                   	push   %esi
  807f54:	53                   	push   %ebx
  807f55:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807f58:	8b 55 10             	mov    0x10(%ebp),%edx
  807f5b:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  807f5e:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  807f61:	8d 70 fe             	lea    -0x2(%eax),%esi
     pcb->state == SYN_SENT ||
  807f64:	83 fe 02             	cmp    $0x2,%esi
  807f67:	76 05                	jbe    807f6e <tcp_write+0x1e>
  807f69:	83 f8 07             	cmp    $0x7,%eax
  807f6c:	75 29                	jne    807f97 <tcp_write+0x47>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  807f6e:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  807f73:	66 85 d2             	test   %dx,%dx
  807f76:	74 24                	je     807f9c <tcp_write+0x4c>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807f78:	83 ec 04             	sub    $0x4,%esp
  807f7b:	6a 00                	push   $0x0
  807f7d:	6a 00                	push   $0x0
  807f7f:	0f b6 db             	movzbl %bl,%ebx
  807f82:	53                   	push   %ebx
  807f83:	6a 00                	push   $0x0
  807f85:	0f b7 d2             	movzwl %dx,%edx
  807f88:	52                   	push   %edx
  807f89:	ff 75 0c             	pushl  0xc(%ebp)
  807f8c:	51                   	push   %ecx
  807f8d:	e8 1c f9 ff ff       	call   8078ae <tcp_enqueue>
  807f92:	83 c4 20             	add    $0x20,%esp
  807f95:	eb 05                	jmp    807f9c <tcp_write+0x4c>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  807f97:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  807f9c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807f9f:	5b                   	pop    %ebx
  807fa0:	5e                   	pop    %esi
  807fa1:	5d                   	pop    %ebp
  807fa2:	c3                   	ret    

00807fa3 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  807fa3:	55                   	push   %ebp
  807fa4:	89 e5                	mov    %esp,%ebp
  807fa6:	57                   	push   %edi
  807fa7:	56                   	push   %esi
  807fa8:	53                   	push   %ebx
  807fa9:	83 ec 1c             	sub    $0x1c,%esp
  807fac:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  807faf:	39 3d 98 b3 b3 00    	cmp    %edi,0xb3b398
  807fb5:	0f 84 36 04 00 00    	je     8083f1 <tcp_output+0x44e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  807fbb:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  807fbf:	66 39 47 5c          	cmp    %ax,0x5c(%edi)
  807fc3:	66 0f 46 47 5c       	cmovbe 0x5c(%edi),%ax
  807fc8:	0f b7 c0             	movzwl %ax,%eax
  807fcb:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  807fce:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  807fd1:	8b 47 78             	mov    0x78(%edi),%eax
  807fd4:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807fd7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  807fda:	85 c0                	test   %eax,%eax
  807fdc:	75 06                	jne    807fe4 <tcp_output+0x41>
  807fde:	eb 0d                	jmp    807fed <tcp_output+0x4a>
    for (; useg->next != NULL; useg = useg->next);
  807fe0:	89 c2                	mov    %eax,%edx
  807fe2:	eb 00                	jmp    807fe4 <tcp_output+0x41>
  807fe4:	8b 02                	mov    (%edx),%eax
  807fe6:	85 c0                	test   %eax,%eax
  807fe8:	75 f6                	jne    807fe0 <tcp_output+0x3d>
  807fea:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  807fed:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  807ff1:	75 0b                	jne    807ffe <tcp_output+0x5b>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  807ff3:	8d 47 04             	lea    0x4(%edi),%eax
  807ff6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807ff9:	e9 8c 03 00 00       	jmp    80838a <tcp_output+0x3e7>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  807ffe:	85 db                	test   %ebx,%ebx
  808000:	74 1f                	je     808021 <tcp_output+0x7e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808002:	83 ec 0c             	sub    $0xc,%esp
  808005:	8b 43 10             	mov    0x10(%ebx),%eax
  808008:	ff 70 04             	pushl  0x4(%eax)
  80800b:	e8 8e f8 ff ff       	call   80789e <ntohl>
  808010:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808014:	2b 57 48             	sub    0x48(%edi),%edx
  808017:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  808019:	83 c4 10             	add    $0x10,%esp
  80801c:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80801f:	73 d2                	jae    807ff3 <tcp_output+0x50>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808021:	83 ec 04             	sub    $0x4,%esp
  808024:	6a 00                	push   $0x0
  808026:	6a 14                	push   $0x14
  808028:	6a 01                	push   $0x1
  80802a:	e8 86 c8 ff ff       	call   8048b5 <pbuf_alloc>
  80802f:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808031:	83 c4 10             	add    $0x10,%esp
  808034:	85 c0                	test   %eax,%eax
  808036:	0f 84 bc 03 00 00    	je     8083f8 <tcp_output+0x455>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80803c:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  808040:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  808043:	83 ec 0c             	sub    $0xc,%esp
  808046:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80804a:	50                   	push   %eax
  80804b:	e8 fd f5 ff ff       	call   80764d <htons>
  808050:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  808053:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  808057:	89 04 24             	mov    %eax,(%esp)
  80805a:	e8 ee f5 ff ff       	call   80764d <htons>
  80805f:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  808063:	83 c4 04             	add    $0x4,%esp
  808066:	ff 77 54             	pushl  0x54(%edi)
  808069:	e8 f9 f5 ff ff       	call   807667 <htonl>
  80806e:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  808071:	83 c4 04             	add    $0x4,%esp
  808074:	ff 77 24             	pushl  0x24(%edi)
  808077:	e8 eb f5 ff ff       	call   807667 <htonl>
  80807c:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80807f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808083:	89 04 24             	mov    %eax,(%esp)
  808086:	e8 cf f5 ff ff       	call   80765a <ntohs>
  80808b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808090:	83 c8 10             	or     $0x10,%eax
  808093:	89 04 24             	mov    %eax,(%esp)
  808096:	e8 b2 f5 ff ff       	call   80764d <htons>
  80809b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80809f:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8080a3:	89 04 24             	mov    %eax,(%esp)
  8080a6:	e8 a2 f5 ff ff       	call   80764d <htons>
  8080ab:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8080af:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8080b5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8080b9:	89 04 24             	mov    %eax,(%esp)
  8080bc:	e8 99 f5 ff ff       	call   80765a <ntohs>
  8080c1:	83 e0 3f             	and    $0x3f,%eax
  8080c4:	80 cc 50             	or     $0x50,%ah
  8080c7:	89 04 24             	mov    %eax,(%esp)
  8080ca:	e8 7e f5 ff ff       	call   80764d <htons>
  8080cf:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  8080d3:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  8080d9:	8d 47 04             	lea    0x4(%edi),%eax
  8080dc:	89 c1                	mov    %eax,%ecx
  8080de:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8080e2:	89 04 24             	mov    %eax,(%esp)
  8080e5:	6a 06                	push   $0x6
  8080e7:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8080ea:	51                   	push   %ecx
  8080eb:	57                   	push   %edi
  8080ec:	56                   	push   %esi
  8080ed:	e8 3b f2 ff ff       	call   80732d <inet_chksum_pseudo>
  8080f2:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8080f6:	83 c4 18             	add    $0x18,%esp
  8080f9:	6a 06                	push   $0x6
  8080fb:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  8080ff:	50                   	push   %eax
  808100:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808104:	50                   	push   %eax
  808105:	ff 75 e4             	pushl  -0x1c(%ebp)
  808108:	57                   	push   %edi
  808109:	56                   	push   %esi
  80810a:	e8 5c e8 ff ff       	call   80696b <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80810f:	83 c4 14             	add    $0x14,%esp
  808112:	56                   	push   %esi
  808113:	e8 d7 c6 ff ff       	call   8047ef <pbuf_free>

    return ERR_OK;
  808118:	83 c4 10             	add    $0x10,%esp
  80811b:	b8 00 00 00 00       	mov    $0x0,%eax
  808120:	e9 ed 02 00 00       	jmp    808412 <tcp_output+0x46f>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808125:	83 ec 0c             	sub    $0xc,%esp
  808128:	8b 43 10             	mov    0x10(%ebx),%eax
  80812b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80812f:	50                   	push   %eax
  808130:	e8 25 f5 ff ff       	call   80765a <ntohs>
  808135:	83 c4 10             	add    $0x10,%esp
  808138:	a8 04                	test   $0x4,%al
  80813a:	74 17                	je     808153 <tcp_output+0x1b0>
  80813c:	83 ec 04             	sub    $0x4,%esp
  80813f:	68 f7 20 81 00       	push   $0x8120f7
  808144:	68 05 02 00 00       	push   $0x205
  808149:	68 be 20 81 00       	push   $0x8120be
  80814e:	e8 8e 62 00 00       	call   80e3e1 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808153:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808157:	74 1c                	je     808175 <tcp_output+0x1d2>
  808159:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80815d:	a8 40                	test   $0x40,%al
  80815f:	75 14                	jne    808175 <tcp_output+0x1d2>
  808161:	8b 57 74             	mov    0x74(%edi),%edx
  808164:	85 d2                	test   %edx,%edx
  808166:	0f 84 93 02 00 00    	je     8083ff <tcp_output+0x45c>
  80816c:	83 3a 00             	cmpl   $0x0,(%edx)
  80816f:	0f 84 8a 02 00 00    	je     8083ff <tcp_output+0x45c>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  808175:	8b 03                	mov    (%ebx),%eax
  808177:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  80817a:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80817e:	74 29                	je     8081a9 <tcp_output+0x206>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808180:	8b 73 10             	mov    0x10(%ebx),%esi
  808183:	83 ec 0c             	sub    $0xc,%esp
  808186:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80818a:	50                   	push   %eax
  80818b:	e8 ca f4 ff ff       	call   80765a <ntohs>
  808190:	83 c8 10             	or     $0x10,%eax
  808193:	0f b7 c0             	movzwl %ax,%eax
  808196:	89 04 24             	mov    %eax,(%esp)
  808199:	e8 af f4 ff ff       	call   80764d <htons>
  80819e:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8081a2:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8081a6:	83 c4 10             	add    $0x10,%esp
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8081a9:	8b 73 10             	mov    0x10(%ebx),%esi
  8081ac:	83 ec 0c             	sub    $0xc,%esp
  8081af:	ff 77 24             	pushl  0x24(%edi)
  8081b2:	e8 b0 f4 ff ff       	call   807667 <htonl>
  8081b7:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8081ba:	8b 73 10             	mov    0x10(%ebx),%esi
  8081bd:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8081c1:	89 04 24             	mov    %eax,(%esp)
  8081c4:	e8 84 f4 ff ff       	call   80764d <htons>
  8081c9:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  8081cd:	83 c4 10             	add    $0x10,%esp
  8081d0:	85 ff                	test   %edi,%edi
  8081d2:	74 05                	je     8081d9 <tcp_output+0x236>
  8081d4:	83 3f 00             	cmpl   $0x0,(%edi)
  8081d7:	75 27                	jne    808200 <tcp_output+0x25d>
    netif = ip_route(&(pcb->remote_ip));
  8081d9:	83 ec 0c             	sub    $0xc,%esp
  8081dc:	ff 75 e4             	pushl  -0x1c(%ebp)
  8081df:	e8 94 e2 ff ff       	call   806478 <ip_route>
    if (netif == NULL) {
  8081e4:	83 c4 10             	add    $0x10,%esp
  8081e7:	85 c0                	test   %eax,%eax
  8081e9:	0f 84 a2 00 00 00    	je     808291 <tcp_output+0x2ee>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8081ef:	83 f8 fc             	cmp    $0xfffffffc,%eax
  8081f2:	74 05                	je     8081f9 <tcp_output+0x256>
  8081f4:	8b 40 04             	mov    0x4(%eax),%eax
  8081f7:	eb 05                	jmp    8081fe <tcp_output+0x25b>
  8081f9:	b8 00 00 00 00       	mov    $0x0,%eax
  8081fe:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  808200:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808205:	75 06                	jne    80820d <tcp_output+0x26a>
    pcb->rtime = 0;
  808207:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  80820d:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  808211:	75 1c                	jne    80822f <tcp_output+0x28c>
    pcb->rttest = tcp_ticks;
  808213:	a1 80 b3 b3 00       	mov    0xb3b380,%eax
  808218:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80821b:	83 ec 0c             	sub    $0xc,%esp
  80821e:	8b 43 10             	mov    0x10(%ebx),%eax
  808221:	ff 70 04             	pushl  0x4(%eax)
  808224:	e8 75 f6 ff ff       	call   80789e <ntohl>
  808229:	89 47 3c             	mov    %eax,0x3c(%edi)
  80822c:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80822f:	8b 53 04             	mov    0x4(%ebx),%edx
  808232:	8b 43 10             	mov    0x10(%ebx),%eax
  808235:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  808238:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  80823c:	8b 53 04             	mov    0x4(%ebx),%edx
  80823f:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808243:	8b 43 04             	mov    0x4(%ebx),%eax
  808246:	8b 53 10             	mov    0x10(%ebx),%edx
  808249:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  80824c:	8b 43 10             	mov    0x10(%ebx),%eax
  80824f:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808255:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808258:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80825b:	83 ec 0c             	sub    $0xc,%esp
  80825e:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808262:	52                   	push   %edx
  808263:	6a 06                	push   $0x6
  808265:	ff 75 e4             	pushl  -0x1c(%ebp)
  808268:	57                   	push   %edi
  808269:	50                   	push   %eax
  80826a:	e8 be f0 ff ff       	call   80732d <inet_chksum_pseudo>
  80826f:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808273:	83 c4 18             	add    $0x18,%esp
  808276:	6a 06                	push   $0x6
  808278:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80827c:	50                   	push   %eax
  80827d:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808281:	50                   	push   %eax
  808282:	ff 75 e4             	pushl  -0x1c(%ebp)
  808285:	57                   	push   %edi
  808286:	ff 73 04             	pushl  0x4(%ebx)
  808289:	e8 dd e6 ff ff       	call   80696b <ip_output>
  80828e:	83 c4 20             	add    $0x20,%esp
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808291:	83 ec 0c             	sub    $0xc,%esp
  808294:	8b 43 10             	mov    0x10(%ebx),%eax
  808297:	ff 70 04             	pushl  0x4(%eax)
  80829a:	e8 ff f5 ff ff       	call   80789e <ntohl>
  80829f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8082a2:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8082a6:	8b 43 10             	mov    0x10(%ebx),%eax
  8082a9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082ad:	89 04 24             	mov    %eax,(%esp)
  8082b0:	e8 a5 f3 ff ff       	call   80765a <ntohs>
  8082b5:	83 c4 10             	add    $0x10,%esp
  8082b8:	ba 01 00 00 00       	mov    $0x1,%edx
  8082bd:	a8 01                	test   $0x1,%al
  8082bf:	75 1b                	jne    8082dc <tcp_output+0x339>
  8082c1:	83 ec 0c             	sub    $0xc,%esp
  8082c4:	8b 43 10             	mov    0x10(%ebx),%eax
  8082c7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082cb:	50                   	push   %eax
  8082cc:	e8 89 f3 ff ff       	call   80765a <ntohs>
  8082d1:	66 d1 e8             	shr    %ax
  8082d4:	89 c2                	mov    %eax,%edx
  8082d6:	83 e2 01             	and    $0x1,%edx
  8082d9:	83 c4 10             	add    $0x10,%esp
  8082dc:	01 d6                	add    %edx,%esi
  8082de:	03 75 e0             	add    -0x20(%ebp),%esi
  8082e1:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8082e4:	39 77 58             	cmp    %esi,0x58(%edi)
  8082e7:	79 03                	jns    8082ec <tcp_output+0x349>
      pcb->snd_max = pcb->snd_nxt;
  8082e9:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  8082ec:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8082f0:	83 ec 0c             	sub    $0xc,%esp
  8082f3:	8b 43 10             	mov    0x10(%ebx),%eax
  8082f6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082fa:	50                   	push   %eax
  8082fb:	e8 5a f3 ff ff       	call   80765a <ntohs>
  808300:	83 c4 10             	add    $0x10,%esp
  808303:	ba 01 00 00 00       	mov    $0x1,%edx
  808308:	a8 01                	test   $0x1,%al
  80830a:	75 1b                	jne    808327 <tcp_output+0x384>
  80830c:	83 ec 0c             	sub    $0xc,%esp
  80830f:	8b 43 10             	mov    0x10(%ebx),%eax
  808312:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808316:	50                   	push   %eax
  808317:	e8 3e f3 ff ff       	call   80765a <ntohs>
  80831c:	66 d1 e8             	shr    %ax
  80831f:	89 c2                	mov    %eax,%edx
  808321:	83 e2 01             	and    $0x1,%edx
  808324:	83 c4 10             	add    $0x10,%esp
  808327:	01 d6                	add    %edx,%esi
  808329:	74 50                	je     80837b <tcp_output+0x3d8>
      seg->next = NULL;
  80832b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808331:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808335:	75 08                	jne    80833f <tcp_output+0x39c>
        pcb->unacked = seg;
  808337:	89 5f 78             	mov    %ebx,0x78(%edi)
  80833a:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  80833d:	eb 48                	jmp    808387 <tcp_output+0x3e4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80833f:	83 ec 0c             	sub    $0xc,%esp
  808342:	8b 43 10             	mov    0x10(%ebx),%eax
  808345:	ff 70 04             	pushl  0x4(%eax)
  808348:	e8 51 f5 ff ff       	call   80789e <ntohl>
  80834d:	89 c6                	mov    %eax,%esi
  80834f:	83 c4 04             	add    $0x4,%esp
  808352:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808355:	8b 40 10             	mov    0x10(%eax),%eax
  808358:	ff 70 04             	pushl  0x4(%eax)
  80835b:	e8 3e f5 ff ff       	call   80789e <ntohl>
  808360:	83 c4 10             	add    $0x10,%esp
  808363:	39 c6                	cmp    %eax,%esi
  808365:	79 0a                	jns    808371 <tcp_output+0x3ce>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  808367:	8b 47 78             	mov    0x78(%edi),%eax
  80836a:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80836c:	89 5f 78             	mov    %ebx,0x78(%edi)
  80836f:	eb 16                	jmp    808387 <tcp_output+0x3e4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  808371:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808374:	89 18                	mov    %ebx,(%eax)
  808376:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808379:	eb 0c                	jmp    808387 <tcp_output+0x3e4>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80837b:	83 ec 0c             	sub    $0xc,%esp
  80837e:	53                   	push   %ebx
  80837f:	e8 bf d3 ff ff       	call   805743 <tcp_seg_free>
  808384:	83 c4 10             	add    $0x10,%esp
    }
    seg = pcb->unsent;
  808387:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80838a:	85 db                	test   %ebx,%ebx
  80838c:	74 58                	je     8083e6 <tcp_output+0x443>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80838e:	83 ec 0c             	sub    $0xc,%esp
  808391:	8b 43 10             	mov    0x10(%ebx),%eax
  808394:	ff 70 04             	pushl  0x4(%eax)
  808397:	e8 02 f5 ff ff       	call   80789e <ntohl>
  80839c:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8083a0:	2b 57 48             	sub    0x48(%edi),%edx
  8083a3:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8083a5:	83 c4 10             	add    $0x10,%esp
  8083a8:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8083ab:	0f 83 74 fd ff ff    	jae    808125 <tcp_output+0x182>
  8083b1:	eb 54                	jmp    808407 <tcp_output+0x464>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  8083b3:	83 ec 0c             	sub    $0xc,%esp
  8083b6:	8b 43 10             	mov    0x10(%ebx),%eax
  8083b9:	ff 70 04             	pushl  0x4(%eax)
  8083bc:	e8 dd f4 ff ff       	call   80789e <ntohl>
  8083c1:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8083c5:	2b 57 48             	sub    0x48(%edi),%edx
  8083c8:	01 d0                	add    %edx,%eax
  8083ca:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  8083ce:	83 c4 10             	add    $0x10,%esp
  8083d1:	39 d0                	cmp    %edx,%eax
  8083d3:	76 11                	jbe    8083e6 <tcp_output+0x443>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  8083d5:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  8083dc:	00 00 00 
    pcb->persist_backoff = 1;
  8083df:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  8083e6:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  8083ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8083ef:	eb 21                	jmp    808412 <tcp_output+0x46f>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  8083f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8083f6:	eb 1a                	jmp    808412 <tcp_output+0x46f>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  8083f8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8083fd:	eb 13                	jmp    808412 <tcp_output+0x46f>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8083ff:	a8 a0                	test   $0xa0,%al
  808401:	0f 85 6e fd ff ff    	jne    808175 <tcp_output+0x1d2>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808407:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80840e:	75 d6                	jne    8083e6 <tcp_output+0x443>
  808410:	eb a1                	jmp    8083b3 <tcp_output+0x410>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808412:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808415:	5b                   	pop    %ebx
  808416:	5e                   	pop    %esi
  808417:	5f                   	pop    %edi
  808418:	5d                   	pop    %ebp
  808419:	c3                   	ret    

0080841a <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80841a:	55                   	push   %ebp
  80841b:	89 e5                	mov    %esp,%ebp
  80841d:	57                   	push   %edi
  80841e:	56                   	push   %esi
  80841f:	53                   	push   %ebx
  808420:	83 ec 20             	sub    $0x20,%esp
  808423:	8b 7d 18             	mov    0x18(%ebp),%edi
  808426:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808429:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80842c:	6a 00                	push   $0x0
  80842e:	6a 14                	push   $0x14
  808430:	6a 01                	push   $0x1
  808432:	e8 7e c4 ff ff       	call   8048b5 <pbuf_alloc>
  808437:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  808439:	83 c4 10             	add    $0x10,%esp
  80843c:	85 c0                	test   %eax,%eax
  80843e:	0f 84 f3 00 00 00    	je     808537 <tcp_rst+0x11d>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808444:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808449:	77 17                	ja     808462 <tcp_rst+0x48>
  80844b:	83 ec 04             	sub    $0x4,%esp
  80844e:	68 90 20 81 00       	push   $0x812090
  808453:	68 be 02 00 00       	push   $0x2be
  808458:	68 be 20 81 00       	push   $0x8120be
  80845d:	e8 7f 5f 00 00       	call   80e3e1 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808462:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808465:	83 ec 0c             	sub    $0xc,%esp
  808468:	0f b7 ff             	movzwl %di,%edi
  80846b:	57                   	push   %edi
  80846c:	e8 dc f1 ff ff       	call   80764d <htons>
  808471:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808474:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808478:	89 04 24             	mov    %eax,(%esp)
  80847b:	e8 cd f1 ff ff       	call   80764d <htons>
  808480:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808484:	83 c4 04             	add    $0x4,%esp
  808487:	ff 75 08             	pushl  0x8(%ebp)
  80848a:	e8 d8 f1 ff ff       	call   807667 <htonl>
  80848f:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808492:	83 c4 04             	add    $0x4,%esp
  808495:	ff 75 0c             	pushl  0xc(%ebp)
  808498:	e8 ca f1 ff ff       	call   807667 <htonl>
  80849d:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8084a0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8084a4:	89 04 24             	mov    %eax,(%esp)
  8084a7:	e8 ae f1 ff ff       	call   80765a <ntohs>
  8084ac:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8084b1:	83 c8 14             	or     $0x14,%eax
  8084b4:	89 04 24             	mov    %eax,(%esp)
  8084b7:	e8 91 f1 ff ff       	call   80764d <htons>
  8084bc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  8084c0:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  8084c7:	e8 81 f1 ff ff       	call   80764d <htons>
  8084cc:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8084d0:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8084d6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8084da:	89 04 24             	mov    %eax,(%esp)
  8084dd:	e8 78 f1 ff ff       	call   80765a <ntohs>
  8084e2:	83 e0 3f             	and    $0x3f,%eax
  8084e5:	80 cc 50             	or     $0x50,%ah
  8084e8:	89 04 24             	mov    %eax,(%esp)
  8084eb:	e8 5d f1 ff ff       	call   80764d <htons>
  8084f0:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  8084f4:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  8084fa:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8084fe:	89 04 24             	mov    %eax,(%esp)
  808501:	6a 06                	push   $0x6
  808503:	ff 75 14             	pushl  0x14(%ebp)
  808506:	ff 75 10             	pushl  0x10(%ebp)
  808509:	56                   	push   %esi
  80850a:	e8 1e ee ff ff       	call   80732d <inet_chksum_pseudo>
  80850f:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808513:	83 c4 18             	add    $0x18,%esp
  808516:	6a 06                	push   $0x6
  808518:	6a 00                	push   $0x0
  80851a:	68 ff 00 00 00       	push   $0xff
  80851f:	ff 75 14             	pushl  0x14(%ebp)
  808522:	ff 75 10             	pushl  0x10(%ebp)
  808525:	56                   	push   %esi
  808526:	e8 40 e4 ff ff       	call   80696b <ip_output>
  pbuf_free(p);
  80852b:	83 c4 14             	add    $0x14,%esp
  80852e:	56                   	push   %esi
  80852f:	e8 bb c2 ff ff       	call   8047ef <pbuf_free>
  808534:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808537:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80853a:	5b                   	pop    %ebx
  80853b:	5e                   	pop    %esi
  80853c:	5f                   	pop    %edi
  80853d:	5d                   	pop    %ebp
  80853e:	c3                   	ret    

0080853f <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80853f:	55                   	push   %ebp
  808540:	89 e5                	mov    %esp,%ebp
  808542:	53                   	push   %ebx
  808543:	83 ec 04             	sub    $0x4,%esp
  808546:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808549:	8b 53 78             	mov    0x78(%ebx),%edx
  80854c:	85 d2                	test   %edx,%edx
  80854e:	75 04                	jne    808554 <tcp_rexmit_rto+0x15>
  808550:	eb 41                	jmp    808593 <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  808552:	89 c2                	mov    %eax,%edx
  808554:	8b 02                	mov    (%edx),%eax
  808556:	85 c0                	test   %eax,%eax
  808558:	75 f8                	jne    808552 <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80855a:	8b 43 74             	mov    0x74(%ebx),%eax
  80855d:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80855f:	8b 43 78             	mov    0x78(%ebx),%eax
  808562:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808565:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80856c:	83 ec 0c             	sub    $0xc,%esp
  80856f:	8b 40 10             	mov    0x10(%eax),%eax
  808572:	ff 70 04             	pushl  0x4(%eax)
  808575:	e8 24 f3 ff ff       	call   80789e <ntohl>
  80857a:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80857d:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808581:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808588:	89 1c 24             	mov    %ebx,(%esp)
  80858b:	e8 13 fa ff ff       	call   807fa3 <tcp_output>
  808590:	83 c4 10             	add    $0x10,%esp
}
  808593:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808596:	c9                   	leave  
  808597:	c3                   	ret    

00808598 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808598:	55                   	push   %ebp
  808599:	89 e5                	mov    %esp,%ebp
  80859b:	53                   	push   %ebx
  80859c:	83 ec 04             	sub    $0x4,%esp
  80859f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085a2:	8b 43 78             	mov    0x78(%ebx),%eax
  8085a5:	85 c0                	test   %eax,%eax
  8085a7:	74 37                	je     8085e0 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  8085a9:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  8085ab:	8b 4b 74             	mov    0x74(%ebx),%ecx
  8085ae:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  8085b0:	8b 43 78             	mov    0x78(%ebx),%eax
  8085b3:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  8085b6:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8085b9:	83 ec 0c             	sub    $0xc,%esp
  8085bc:	8b 40 10             	mov    0x10(%eax),%eax
  8085bf:	ff 70 04             	pushl  0x4(%eax)
  8085c2:	e8 d7 f2 ff ff       	call   80789e <ntohl>
  8085c7:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  8085ca:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  8085ce:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  8085d5:	89 1c 24             	mov    %ebx,(%esp)
  8085d8:	e8 c6 f9 ff ff       	call   807fa3 <tcp_output>
  8085dd:	83 c4 10             	add    $0x10,%esp
}
  8085e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8085e3:	c9                   	leave  
  8085e4:	c3                   	ret    

008085e5 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  8085e5:	55                   	push   %ebp
  8085e6:	89 e5                	mov    %esp,%ebp
  8085e8:	57                   	push   %edi
  8085e9:	56                   	push   %esi
  8085ea:	53                   	push   %ebx
  8085eb:	83 ec 20             	sub    $0x20,%esp
  8085ee:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8085f1:	6a 00                	push   $0x0
  8085f3:	6a 14                	push   $0x14
  8085f5:	6a 01                	push   $0x1
  8085f7:	e8 b9 c2 ff ff       	call   8048b5 <pbuf_alloc>
  8085fc:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8085fe:	83 c4 10             	add    $0x10,%esp
  808601:	85 c0                	test   %eax,%eax
  808603:	0f 84 f6 00 00 00    	je     8086ff <tcp_keepalive+0x11a>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808609:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80860e:	77 17                	ja     808627 <tcp_keepalive+0x42>
  808610:	83 ec 04             	sub    $0x4,%esp
  808613:	68 90 20 81 00       	push   $0x812090
  808618:	68 3a 03 00 00       	push   $0x33a
  80861d:	68 be 20 81 00       	push   $0x8120be
  808622:	e8 ba 5d 00 00       	call   80e3e1 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808627:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80862a:	83 ec 0c             	sub    $0xc,%esp
  80862d:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808631:	50                   	push   %eax
  808632:	e8 16 f0 ff ff       	call   80764d <htons>
  808637:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80863a:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80863e:	89 04 24             	mov    %eax,(%esp)
  808641:	e8 07 f0 ff ff       	call   80764d <htons>
  808646:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80864a:	8b 46 54             	mov    0x54(%esi),%eax
  80864d:	83 e8 01             	sub    $0x1,%eax
  808650:	89 04 24             	mov    %eax,(%esp)
  808653:	e8 0f f0 ff ff       	call   807667 <htonl>
  808658:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80865b:	83 c4 04             	add    $0x4,%esp
  80865e:	ff 76 24             	pushl  0x24(%esi)
  808661:	e8 01 f0 ff ff       	call   807667 <htonl>
  808666:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808669:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80866d:	89 04 24             	mov    %eax,(%esp)
  808670:	e8 e5 ef ff ff       	call   80765a <ntohs>
  808675:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80867a:	89 04 24             	mov    %eax,(%esp)
  80867d:	e8 cb ef ff ff       	call   80764d <htons>
  808682:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808686:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80868a:	89 04 24             	mov    %eax,(%esp)
  80868d:	e8 bb ef ff ff       	call   80764d <htons>
  808692:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808696:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80869c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8086a0:	89 04 24             	mov    %eax,(%esp)
  8086a3:	e8 b2 ef ff ff       	call   80765a <ntohs>
  8086a8:	83 e0 3f             	and    $0x3f,%eax
  8086ab:	80 cc 50             	or     $0x50,%ah
  8086ae:	89 04 24             	mov    %eax,(%esp)
  8086b1:	e8 97 ef ff ff       	call   80764d <htons>
  8086b6:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  8086ba:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  8086c0:	8d 46 04             	lea    0x4(%esi),%eax
  8086c3:	89 c2                	mov    %eax,%edx
  8086c5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8086c9:	89 04 24             	mov    %eax,(%esp)
  8086cc:	6a 06                	push   $0x6
  8086ce:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8086d1:	52                   	push   %edx
  8086d2:	56                   	push   %esi
  8086d3:	57                   	push   %edi
  8086d4:	e8 54 ec ff ff       	call   80732d <inet_chksum_pseudo>
  8086d9:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8086dd:	83 c4 18             	add    $0x18,%esp
  8086e0:	6a 06                	push   $0x6
  8086e2:	6a 00                	push   $0x0
  8086e4:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8086e8:	50                   	push   %eax
  8086e9:	ff 75 e4             	pushl  -0x1c(%ebp)
  8086ec:	56                   	push   %esi
  8086ed:	57                   	push   %edi
  8086ee:	e8 78 e2 ff ff       	call   80696b <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8086f3:	83 c4 14             	add    $0x14,%esp
  8086f6:	57                   	push   %edi
  8086f7:	e8 f3 c0 ff ff       	call   8047ef <pbuf_free>
  8086fc:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8086ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808702:	5b                   	pop    %ebx
  808703:	5e                   	pop    %esi
  808704:	5f                   	pop    %edi
  808705:	5d                   	pop    %ebp
  808706:	c3                   	ret    

00808707 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808707:	55                   	push   %ebp
  808708:	89 e5                	mov    %esp,%ebp
  80870a:	57                   	push   %edi
  80870b:	56                   	push   %esi
  80870c:	53                   	push   %ebx
  80870d:	83 ec 1c             	sub    $0x1c,%esp
  808710:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808713:	8b 46 78             	mov    0x78(%esi),%eax
  808716:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808719:	85 c0                	test   %eax,%eax
  80871b:	75 0e                	jne    80872b <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80871d:	8b 46 74             	mov    0x74(%esi),%eax
  808720:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808723:	85 c0                	test   %eax,%eax
  808725:	0f 84 1b 01 00 00    	je     808846 <tcp_zero_window_probe+0x13f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80872b:	83 ec 04             	sub    $0x4,%esp
  80872e:	6a 00                	push   $0x0
  808730:	6a 15                	push   $0x15
  808732:	6a 01                	push   $0x1
  808734:	e8 7c c1 ff ff       	call   8048b5 <pbuf_alloc>
  808739:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80873b:	83 c4 10             	add    $0x10,%esp
  80873e:	85 c0                	test   %eax,%eax
  808740:	0f 84 00 01 00 00    	je     808846 <tcp_zero_window_probe+0x13f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808746:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80874b:	77 17                	ja     808764 <tcp_zero_window_probe+0x5d>
  80874d:	83 ec 04             	sub    $0x4,%esp
  808750:	68 90 20 81 00       	push   $0x812090
  808755:	68 8d 03 00 00       	push   $0x38d
  80875a:	68 be 20 81 00       	push   $0x8120be
  80875f:	e8 7d 5c 00 00       	call   80e3e1 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808764:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808767:	83 ec 0c             	sub    $0xc,%esp
  80876a:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80876e:	50                   	push   %eax
  80876f:	e8 d9 ee ff ff       	call   80764d <htons>
  808774:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808777:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80877b:	89 04 24             	mov    %eax,(%esp)
  80877e:	e8 ca ee ff ff       	call   80764d <htons>
  808783:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808787:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80878a:	8b 40 10             	mov    0x10(%eax),%eax
  80878d:	8b 40 04             	mov    0x4(%eax),%eax
  808790:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808793:	83 c4 04             	add    $0x4,%esp
  808796:	ff 76 24             	pushl  0x24(%esi)
  808799:	e8 c9 ee ff ff       	call   807667 <htonl>
  80879e:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8087a1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8087a5:	89 04 24             	mov    %eax,(%esp)
  8087a8:	e8 ad ee ff ff       	call   80765a <ntohs>
  8087ad:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8087b2:	89 04 24             	mov    %eax,(%esp)
  8087b5:	e8 93 ee ff ff       	call   80764d <htons>
  8087ba:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8087be:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8087c2:	89 04 24             	mov    %eax,(%esp)
  8087c5:	e8 83 ee ff ff       	call   80764d <htons>
  8087ca:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8087ce:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8087d4:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8087d8:	89 04 24             	mov    %eax,(%esp)
  8087db:	e8 7a ee ff ff       	call   80765a <ntohs>
  8087e0:	83 e0 3f             	and    $0x3f,%eax
  8087e3:	80 cc 50             	or     $0x50,%ah
  8087e6:	89 04 24             	mov    %eax,(%esp)
  8087e9:	e8 5f ee ff ff       	call   80764d <htons>
  8087ee:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  8087f2:	8b 47 04             	mov    0x4(%edi),%eax
  8087f5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8087f8:	8b 51 08             	mov    0x8(%ecx),%edx
  8087fb:	0f b6 12             	movzbl (%edx),%edx
  8087fe:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808801:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808807:	8d 46 04             	lea    0x4(%esi),%eax
  80880a:	89 c1                	mov    %eax,%ecx
  80880c:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808810:	89 04 24             	mov    %eax,(%esp)
  808813:	6a 06                	push   $0x6
  808815:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808818:	51                   	push   %ecx
  808819:	56                   	push   %esi
  80881a:	57                   	push   %edi
  80881b:	e8 0d eb ff ff       	call   80732d <inet_chksum_pseudo>
  808820:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808824:	83 c4 18             	add    $0x18,%esp
  808827:	6a 06                	push   $0x6
  808829:	6a 00                	push   $0x0
  80882b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80882f:	50                   	push   %eax
  808830:	ff 75 e4             	pushl  -0x1c(%ebp)
  808833:	56                   	push   %esi
  808834:	57                   	push   %edi
  808835:	e8 31 e1 ff ff       	call   80696b <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80883a:	83 c4 14             	add    $0x14,%esp
  80883d:	57                   	push   %edi
  80883e:	e8 ac bf ff ff       	call   8047ef <pbuf_free>
  808843:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808846:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808849:	5b                   	pop    %ebx
  80884a:	5e                   	pop    %esi
  80884b:	5f                   	pop    %edi
  80884c:	5d                   	pop    %ebp
  80884d:	c3                   	ret    

0080884e <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80884e:	55                   	push   %ebp
  80884f:	89 e5                	mov    %esp,%ebp
  808851:	57                   	push   %edi
  808852:	56                   	push   %esi
  808853:	53                   	push   %ebx
  808854:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808857:	8b 45 08             	mov    0x8(%ebp),%eax
  80885a:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80885d:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  808861:	0f b7 07             	movzwl (%edi),%eax
  808864:	50                   	push   %eax
  808865:	e8 f0 ed ff ff       	call   80765a <ntohs>
  80886a:	66 c1 e8 08          	shr    $0x8,%ax
  80886e:	83 e0 0f             	and    $0xf,%eax
  808871:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808878:	83 c4 10             	add    $0x10,%esp
  80887b:	39 c3                	cmp    %eax,%ebx
  80887d:	7c 29                	jl     8088a8 <udp_input+0x5a>
  80887f:	83 ec 0c             	sub    $0xc,%esp
  808882:	0f b7 07             	movzwl (%edi),%eax
  808885:	50                   	push   %eax
  808886:	e8 cf ed ff ff       	call   80765a <ntohs>
  80888b:	83 c4 08             	add    $0x8,%esp
  80888e:	66 c1 e8 06          	shr    $0x6,%ax
  808892:	83 e0 3c             	and    $0x3c,%eax
  808895:	f7 d8                	neg    %eax
  808897:	98                   	cwtl   
  808898:	50                   	push   %eax
  808899:	ff 75 08             	pushl  0x8(%ebp)
  80889c:	e8 7c be ff ff       	call   80471d <pbuf_header>
  8088a1:	83 c4 10             	add    $0x10,%esp
  8088a4:	84 c0                	test   %al,%al
  8088a6:	74 13                	je     8088bb <udp_input+0x6d>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  8088a8:	83 ec 0c             	sub    $0xc,%esp
  8088ab:	ff 75 08             	pushl  0x8(%ebp)
  8088ae:	e8 3c bf ff ff       	call   8047ef <pbuf_free>
    goto end;
  8088b3:	83 c4 10             	add    $0x10,%esp
  8088b6:	e9 c9 02 00 00       	jmp    808b84 <udp_input+0x336>
  }

  udphdr = (struct udp_hdr *)p->payload;
  8088bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8088be:	8b 40 04             	mov    0x4(%eax),%eax
  8088c1:	89 c6                	mov    %eax,%esi
  8088c3:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  8088c6:	83 ec 0c             	sub    $0xc,%esp
  8088c9:	0f b7 00             	movzwl (%eax),%eax
  8088cc:	50                   	push   %eax
  8088cd:	e8 88 ed ff ff       	call   80765a <ntohs>
  8088d2:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  8088d6:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8088da:	89 04 24             	mov    %eax,(%esp)
  8088dd:	e8 78 ed ff ff       	call   80765a <ntohs>
  8088e2:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  8088e4:	83 c4 10             	add    $0x10,%esp
  8088e7:	66 83 f8 44          	cmp    $0x44,%ax
  8088eb:	75 49                	jne    808936 <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  8088ed:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  8088f2:	0f 85 fd 00 00 00    	jne    8089f5 <udp_input+0x1a7>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  8088f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8088fb:	8b 40 20             	mov    0x20(%eax),%eax
  8088fe:	85 c0                	test   %eax,%eax
  808900:	0f 84 ef 00 00 00    	je     8089f5 <udp_input+0x1a7>
  808906:	8b 40 08             	mov    0x8(%eax),%eax
  808909:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80890c:	85 c0                	test   %eax,%eax
  80890e:	0f 84 e1 00 00 00    	je     8089f5 <udp_input+0x1a7>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808914:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808917:	0f 84 ee 00 00 00    	je     808a0b <udp_input+0x1bd>
  80891d:	8b 40 04             	mov    0x4(%eax),%eax
  808920:	85 c0                	test   %eax,%eax
  808922:	0f 84 e3 00 00 00    	je     808a0b <udp_input+0x1bd>
  808928:	3b 47 0c             	cmp    0xc(%edi),%eax
  80892b:	0f 85 c4 00 00 00    	jne    8089f5 <udp_input+0x1a7>
  808931:	e9 d5 00 00 00       	jmp    808a0b <udp_input+0x1bd>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808936:	8b 1d 94 b3 b3 00    	mov    0xb3b394,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  80893c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  808943:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80894a:	8d 47 10             	lea    0x10(%edi),%eax
  80894d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808950:	e9 92 00 00 00       	jmp    8089e7 <udp_input+0x199>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  808955:	66 39 73 12          	cmp    %si,0x12(%ebx)
  808959:	0f 85 82 00 00 00    	jne    8089e1 <udp_input+0x193>
  80895f:	85 db                	test   %ebx,%ebx
  808961:	74 20                	je     808983 <udp_input+0x135>
          (ip_addr_isany(&pcb->local_ip) ||
  808963:	8b 03                	mov    (%ebx),%eax
  808965:	85 c0                	test   %eax,%eax
  808967:	74 1a                	je     808983 <udp_input+0x135>
  808969:	3b 47 10             	cmp    0x10(%edi),%eax
  80896c:	74 15                	je     808983 <udp_input+0x135>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80896e:	83 ec 08             	sub    $0x8,%esp
  808971:	ff 75 0c             	pushl  0xc(%ebp)
  808974:	ff 75 d8             	pushl  -0x28(%ebp)
  808977:	e8 b0 da ff ff       	call   80642c <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  80897c:	83 c4 10             	add    $0x10,%esp
  80897f:	84 c0                	test   %al,%al
  808981:	74 5e                	je     8089e1 <udp_input+0x193>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  808983:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  808987:	0f 85 dc 01 00 00    	jne    808b69 <udp_input+0x31b>
  80898d:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808991:	83 e0 04             	and    $0x4,%eax
  808994:	8b 45 e0             	mov    -0x20(%ebp),%eax
  808997:	0f 44 c3             	cmove  %ebx,%eax
  80899a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80899d:	e9 c7 01 00 00       	jmp    808b69 <udp_input+0x31b>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  8089a2:	83 fb fc             	cmp    $0xfffffffc,%ebx
  8089a5:	74 10                	je     8089b7 <udp_input+0x169>
          (ip_addr_isany(&pcb->remote_ip) ||
  8089a7:	8b 43 04             	mov    0x4(%ebx),%eax
  8089aa:	85 c0                	test   %eax,%eax
  8089ac:	74 0d                	je     8089bb <udp_input+0x16d>
  8089ae:	3b 47 0c             	cmp    0xc(%edi),%eax
  8089b1:	75 2e                	jne    8089e1 <udp_input+0x193>
  8089b3:	89 d8                	mov    %ebx,%eax
  8089b5:	eb 06                	jmp    8089bd <udp_input+0x16f>
  8089b7:	89 d8                	mov    %ebx,%eax
  8089b9:	eb 02                	jmp    8089bd <udp_input+0x16f>
  8089bb:	89 d8                	mov    %ebx,%eax
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  8089bd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8089c0:	85 c9                	test   %ecx,%ecx
  8089c2:	0f 84 b4 01 00 00    	je     808b7c <udp_input+0x32e>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  8089c8:	8b 50 0c             	mov    0xc(%eax),%edx
  8089cb:	89 51 0c             	mov    %edx,0xc(%ecx)
          pcb->next = udp_pcbs;
  8089ce:	8b 15 94 b3 b3 00    	mov    0xb3b394,%edx
  8089d4:	89 50 0c             	mov    %edx,0xc(%eax)
          udp_pcbs = pcb;
  8089d7:	a3 94 b3 b3 00       	mov    %eax,0xb3b394
  8089dc:	e9 9b 01 00 00       	jmp    808b7c <udp_input+0x32e>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089e1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8089e4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8089e7:	85 db                	test   %ebx,%ebx
  8089e9:	0f 85 66 ff ff ff    	jne    808955 <udp_input+0x107>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  8089ef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8089f3:	75 16                	jne    808a0b <udp_input+0x1bd>
  8089f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8089f8:	8b 57 10             	mov    0x10(%edi),%edx
  8089fb:	39 50 04             	cmp    %edx,0x4(%eax)
  8089fe:	0f 85 55 01 00 00    	jne    808b59 <udp_input+0x30b>
  808a04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  808a0b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808a0e:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808a13:	74 38                	je     808a4d <udp_input+0x1ff>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808a15:	83 ec 0c             	sub    $0xc,%esp
  808a18:	8b 45 08             	mov    0x8(%ebp),%eax
  808a1b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808a1f:	50                   	push   %eax
  808a20:	6a 11                	push   $0x11
  808a22:	8d 47 10             	lea    0x10(%edi),%eax
  808a25:	50                   	push   %eax
  808a26:	8d 47 0c             	lea    0xc(%edi),%eax
  808a29:	50                   	push   %eax
  808a2a:	ff 75 08             	pushl  0x8(%ebp)
  808a2d:	e8 fb e8 ff ff       	call   80732d <inet_chksum_pseudo>
  808a32:	83 c4 20             	add    $0x20,%esp
  808a35:	66 85 c0             	test   %ax,%ax
  808a38:	74 13                	je     808a4d <udp_input+0x1ff>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  808a3a:	83 ec 0c             	sub    $0xc,%esp
  808a3d:	ff 75 08             	pushl  0x8(%ebp)
  808a40:	e8 aa bd ff ff       	call   8047ef <pbuf_free>
          goto end;
  808a45:	83 c4 10             	add    $0x10,%esp
  808a48:	e9 37 01 00 00       	jmp    808b84 <udp_input+0x336>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  808a4d:	83 ec 08             	sub    $0x8,%esp
  808a50:	6a f8                	push   $0xfffffff8
  808a52:	ff 75 08             	pushl  0x8(%ebp)
  808a55:	e8 c3 bc ff ff       	call   80471d <pbuf_header>
  808a5a:	83 c4 10             	add    $0x10,%esp
  808a5d:	84 c0                	test   %al,%al
  808a5f:	74 17                	je     808a78 <udp_input+0x22a>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808a61:	83 ec 04             	sub    $0x4,%esp
  808a64:	68 e3 20 81 00       	push   $0x8120e3
  808a69:	68 0a 01 00 00       	push   $0x10a
  808a6e:	68 0e 21 81 00       	push   $0x81210e
  808a73:	e8 69 59 00 00       	call   80e3e1 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  808a78:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  808a7b:	85 c9                	test   %ecx,%ecx
  808a7d:	74 37                	je     808ab6 <udp_input+0x268>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  808a7f:	8b 41 18             	mov    0x18(%ecx),%eax
  808a82:	85 c0                	test   %eax,%eax
  808a84:	74 1d                	je     808aa3 <udp_input+0x255>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808a86:	83 ec 0c             	sub    $0xc,%esp
  808a89:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  808a8d:	52                   	push   %edx
  808a8e:	83 c7 0c             	add    $0xc,%edi
  808a91:	57                   	push   %edi
  808a92:	ff 75 08             	pushl  0x8(%ebp)
  808a95:	51                   	push   %ecx
  808a96:	ff 71 1c             	pushl  0x1c(%ecx)
  808a99:	ff d0                	call   *%eax
  808a9b:	83 c4 20             	add    $0x20,%esp
  808a9e:	e9 e1 00 00 00       	jmp    808b84 <udp_input+0x336>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  808aa3:	83 ec 0c             	sub    $0xc,%esp
  808aa6:	ff 75 08             	pushl  0x8(%ebp)
  808aa9:	e8 41 bd ff ff       	call   8047ef <pbuf_free>
        goto end;
  808aae:	83 c4 10             	add    $0x10,%esp
  808ab1:	e9 ce 00 00 00       	jmp    808b84 <udp_input+0x336>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808ab6:	83 ec 08             	sub    $0x8,%esp
  808ab9:	ff 75 0c             	pushl  0xc(%ebp)
  808abc:	8d 47 10             	lea    0x10(%edi),%eax
  808abf:	50                   	push   %eax
  808ac0:	e8 67 d9 ff ff       	call   80642c <ip_addr_isbroadcast>
  808ac5:	83 c4 10             	add    $0x10,%esp
  808ac8:	84 c0                	test   %al,%al
  808aca:	75 7d                	jne    808b49 <udp_input+0x2fb>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808acc:	8b 5f 10             	mov    0x10(%edi),%ebx
  808acf:	83 ec 0c             	sub    $0xc,%esp
  808ad2:	68 00 00 00 f0       	push   $0xf0000000
  808ad7:	e8 c2 ed ff ff       	call   80789e <ntohl>
  808adc:	21 c3                	and    %eax,%ebx
  808ade:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808ae5:	e8 b4 ed ff ff       	call   80789e <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808aea:	83 c4 10             	add    $0x10,%esp
  808aed:	39 c3                	cmp    %eax,%ebx
  808aef:	74 58                	je     808b49 <udp_input+0x2fb>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808af1:	83 ec 0c             	sub    $0xc,%esp
  808af4:	0f b7 07             	movzwl (%edi),%eax
  808af7:	50                   	push   %eax
  808af8:	e8 5d eb ff ff       	call   80765a <ntohs>
  808afd:	83 c4 08             	add    $0x8,%esp
  808b00:	66 c1 e8 08          	shr    $0x8,%ax
  808b04:	83 e0 0f             	and    $0xf,%eax
  808b07:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808b0e:	50                   	push   %eax
  808b0f:	ff 75 08             	pushl  0x8(%ebp)
  808b12:	e8 06 bc ff ff       	call   80471d <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808b17:	83 c4 10             	add    $0x10,%esp
  808b1a:	8b 45 08             	mov    0x8(%ebp),%eax
  808b1d:	39 78 04             	cmp    %edi,0x4(%eax)
  808b20:	74 17                	je     808b39 <udp_input+0x2eb>
  808b22:	83 ec 04             	sub    $0x4,%esp
  808b25:	68 22 21 81 00       	push   $0x812122
  808b2a:	68 25 01 00 00       	push   $0x125
  808b2f:	68 0e 21 81 00       	push   $0x81210e
  808b34:	e8 a8 58 00 00       	call   80e3e1 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808b39:	83 ec 08             	sub    $0x8,%esp
  808b3c:	6a 03                	push   $0x3
  808b3e:	ff 75 08             	pushl  0x8(%ebp)
  808b41:	e8 7d 56 00 00       	call   80e1c3 <icmp_dest_unreach>
  808b46:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  808b49:	83 ec 0c             	sub    $0xc,%esp
  808b4c:	ff 75 08             	pushl  0x8(%ebp)
  808b4f:	e8 9b bc ff ff       	call   8047ef <pbuf_free>
  808b54:	83 c4 10             	add    $0x10,%esp
  808b57:	eb 2b                	jmp    808b84 <udp_input+0x336>
    }
  } else {
    pbuf_free(p);
  808b59:	83 ec 0c             	sub    $0xc,%esp
  808b5c:	ff 75 08             	pushl  0x8(%ebp)
  808b5f:	e8 8b bc ff ff       	call   8047ef <pbuf_free>
  808b64:	83 c4 10             	add    $0x10,%esp
  808b67:	eb 1b                	jmp    808b84 <udp_input+0x336>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  808b69:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  808b6d:	66 39 43 14          	cmp    %ax,0x14(%ebx)
  808b71:	0f 85 6a fe ff ff    	jne    8089e1 <udp_input+0x193>
  808b77:	e9 26 fe ff ff       	jmp    8089a2 <udp_input+0x154>
  808b7c:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  808b7f:	e9 87 fe ff ff       	jmp    808a0b <udp_input+0x1bd>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808b84:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808b87:	5b                   	pop    %ebx
  808b88:	5e                   	pop    %esi
  808b89:	5f                   	pop    %edi
  808b8a:	5d                   	pop    %ebp
  808b8b:	c3                   	ret    

00808b8c <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808b8c:	55                   	push   %ebp
  808b8d:	89 e5                	mov    %esp,%ebp
  808b8f:	57                   	push   %edi
  808b90:	56                   	push   %esi
  808b91:	53                   	push   %ebx
  808b92:	83 ec 1c             	sub    $0x1c,%esp
  808b95:	8b 55 08             	mov    0x8(%ebp),%edx
  808b98:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808b9b:	8b 45 10             	mov    0x10(%ebp),%eax
  808b9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808ba1:	89 c1                	mov    %eax,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ba3:	a1 94 b3 b3 00       	mov    0xb3b394,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  808ba8:	be 00 00 00 00       	mov    $0x0,%esi
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808bad:	eb 29                	jmp    808bd8 <udp_bind+0x4c>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  808baf:	39 c2                	cmp    %eax,%edx
  808bb1:	75 22                	jne    808bd5 <udp_bind+0x49>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808bb3:	89 f3                	mov    %esi,%ebx
  808bb5:	84 db                	test   %bl,%bl
  808bb7:	74 17                	je     808bd0 <udp_bind+0x44>
  808bb9:	83 ec 04             	sub    $0x4,%esp
  808bbc:	68 36 21 81 00       	push   $0x812136
  808bc1:	68 41 02 00 00       	push   $0x241
  808bc6:	68 0e 21 81 00       	push   $0x81210e
  808bcb:	e8 11 58 00 00       	call   80e3e1 <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  808bd0:	be 01 00 00 00       	mov    $0x1,%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808bd5:	8b 40 0c             	mov    0xc(%eax),%eax
  808bd8:	85 c0                	test   %eax,%eax
  808bda:	75 d3                	jne    808baf <udp_bind+0x23>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808bdc:	85 ff                	test   %edi,%edi
  808bde:	74 04                	je     808be4 <udp_bind+0x58>
  808be0:	8b 07                	mov    (%edi),%eax
  808be2:	eb 05                	jmp    808be9 <udp_bind+0x5d>
  808be4:	b8 00 00 00 00       	mov    $0x0,%eax
  808be9:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808beb:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  808bf0:	75 36                	jne    808c28 <udp_bind+0x9c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808bf2:	8b 3d 94 b3 b3 00    	mov    0xb3b394,%edi
  808bf8:	89 f8                	mov    %edi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  808bfa:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808bff:	eb 13                	jmp    808c14 <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808c01:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  808c05:	66 39 cb             	cmp    %cx,%bx
  808c08:	75 07                	jne    808c11 <udp_bind+0x85>
        /* port is already used by another udp_pcb */
        port++;
  808c0a:	8d 4b 01             	lea    0x1(%ebx),%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  808c0d:	89 f8                	mov    %edi,%eax
  808c0f:	eb 03                	jmp    808c14 <udp_bind+0x88>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808c11:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c14:	85 c0                	test   %eax,%eax
  808c16:	0f 95 c3             	setne  %bl
  808c19:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808c1e:	74 04                	je     808c24 <udp_bind+0x98>
  808c20:	84 db                	test   %bl,%bl
  808c22:	75 dd                	jne    808c01 <udp_bind+0x75>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  808c24:	84 db                	test   %bl,%bl
  808c26:	75 24                	jne    808c4c <udp_bind+0xc0>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808c28:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808c2c:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  808c31:	89 f1                	mov    %esi,%ecx
  808c33:	84 c9                	test   %cl,%cl
  808c35:	75 1a                	jne    808c51 <udp_bind+0xc5>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  808c37:	a1 94 b3 b3 00       	mov    0xb3b394,%eax
  808c3c:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808c3f:	89 15 94 b3 b3 00    	mov    %edx,0xb3b394
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808c45:	b8 00 00 00 00       	mov    $0x0,%eax
  808c4a:	eb 05                	jmp    808c51 <udp_bind+0xc5>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  808c4c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  808c51:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808c54:	5b                   	pop    %ebx
  808c55:	5e                   	pop    %esi
  808c56:	5f                   	pop    %edi
  808c57:	5d                   	pop    %ebp
  808c58:	c3                   	ret    

00808c59 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  808c59:	55                   	push   %ebp
  808c5a:	89 e5                	mov    %esp,%ebp
  808c5c:	57                   	push   %edi
  808c5d:	56                   	push   %esi
  808c5e:	53                   	push   %ebx
  808c5f:	83 ec 1c             	sub    $0x1c,%esp
  808c62:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808c65:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  808c68:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808c6d:	75 17                	jne    808c86 <udp_sendto_if+0x2d>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808c6f:	83 ec 04             	sub    $0x4,%esp
  808c72:	6a 00                	push   $0x0
  808c74:	53                   	push   %ebx
  808c75:	53                   	push   %ebx
  808c76:	e8 11 ff ff ff       	call   808b8c <udp_bind>
    if (err != ERR_OK) {
  808c7b:	83 c4 10             	add    $0x10,%esp
  808c7e:	84 c0                	test   %al,%al
  808c80:	0f 85 54 01 00 00    	jne    808dda <udp_sendto_if+0x181>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808c86:	83 ec 08             	sub    $0x8,%esp
  808c89:	6a 08                	push   $0x8
  808c8b:	ff 75 0c             	pushl  0xc(%ebp)
  808c8e:	e8 8a ba ff ff       	call   80471d <pbuf_header>
  808c93:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  808c96:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808c99:	84 c0                	test   %al,%al
  808c9b:	74 2a                	je     808cc7 <udp_sendto_if+0x6e>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808c9d:	83 ec 04             	sub    $0x4,%esp
  808ca0:	6a 00                	push   $0x0
  808ca2:	6a 08                	push   $0x8
  808ca4:	6a 01                	push   $0x1
  808ca6:	e8 0a bc ff ff       	call   8048b5 <pbuf_alloc>
  808cab:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  808cad:	83 c4 10             	add    $0x10,%esp
  808cb0:	85 c0                	test   %eax,%eax
  808cb2:	0f 84 1d 01 00 00    	je     808dd5 <udp_sendto_if+0x17c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  808cb8:	83 ec 08             	sub    $0x8,%esp
  808cbb:	ff 75 0c             	pushl  0xc(%ebp)
  808cbe:	50                   	push   %eax
  808cbf:	e8 12 c0 ff ff       	call   804cd6 <pbuf_chain>
  808cc4:	83 c4 10             	add    $0x10,%esp
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808cc7:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  808ccc:	77 17                	ja     808ce5 <udp_sendto_if+0x8c>
  808cce:	83 ec 04             	sub    $0x4,%esp
  808cd1:	68 44 21 81 00       	push   $0x812144
  808cd6:	68 b2 01 00 00       	push   $0x1b2
  808cdb:	68 0e 21 81 00       	push   $0x81210e
  808ce0:	e8 fc 56 00 00       	call   80e3e1 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  808ce5:	8b 46 04             	mov    0x4(%esi),%eax
  808ce8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  808ceb:	83 ec 0c             	sub    $0xc,%esp
  808cee:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  808cf2:	50                   	push   %eax
  808cf3:	e8 55 e9 ff ff       	call   80764d <htons>
  808cf8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808cfb:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  808cfe:	0f b7 ff             	movzwl %di,%edi
  808d01:	89 3c 24             	mov    %edi,(%esp)
  808d04:	e8 44 e9 ff ff       	call   80764d <htons>
  808d09:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808d0c:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  808d10:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  808d16:	89 df                	mov    %ebx,%edi
  808d18:	83 c4 10             	add    $0x10,%esp
  808d1b:	85 db                	test   %ebx,%ebx
  808d1d:	74 06                	je     808d25 <udp_sendto_if+0xcc>
  808d1f:	8b 03                	mov    (%ebx),%eax
  808d21:	85 c0                	test   %eax,%eax
  808d23:	75 08                	jne    808d2d <udp_sendto_if+0xd4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  808d25:	8b 45 18             	mov    0x18(%ebp),%eax
  808d28:	8d 78 04             	lea    0x4(%eax),%edi
  808d2b:	eb 2c                	jmp    808d59 <udp_sendto_if+0x100>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808d2d:	8b 55 18             	mov    0x18(%ebp),%edx
  808d30:	3b 42 04             	cmp    0x4(%edx),%eax
  808d33:	74 24                	je     808d59 <udp_sendto_if+0x100>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808d35:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  808d3a:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808d3d:	0f 84 97 00 00 00    	je     808dda <udp_sendto_if+0x181>
        /* free the header pbuf */
        pbuf_free(q);
  808d43:	83 ec 0c             	sub    $0xc,%esp
  808d46:	56                   	push   %esi
  808d47:	e8 a3 ba ff ff       	call   8047ef <pbuf_free>
  808d4c:	83 c4 10             	add    $0x10,%esp
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808d4f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  808d54:	e9 81 00 00 00       	jmp    808dda <udp_sendto_if+0x181>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  808d59:	83 ec 0c             	sub    $0xc,%esp
  808d5c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808d60:	50                   	push   %eax
  808d61:	e8 e7 e8 ff ff       	call   80764d <htons>
  808d66:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808d69:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808d6d:	83 c4 10             	add    $0x10,%esp
  808d70:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  808d74:	75 29                	jne    808d9f <udp_sendto_if+0x146>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808d76:	83 ec 0c             	sub    $0xc,%esp
  808d79:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808d7d:	50                   	push   %eax
  808d7e:	6a 11                	push   $0x11
  808d80:	ff 75 10             	pushl  0x10(%ebp)
  808d83:	57                   	push   %edi
  808d84:	56                   	push   %esi
  808d85:	e8 a3 e5 ff ff       	call   80732d <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808d8a:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808d8d:	66 85 c0             	test   %ax,%ax
  808d90:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808d95:	0f 44 c2             	cmove  %edx,%eax
  808d98:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808d9b:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808d9f:	83 ec 04             	sub    $0x4,%esp
  808da2:	ff 75 18             	pushl  0x18(%ebp)
  808da5:	6a 11                	push   $0x11
  808da7:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808dab:	50                   	push   %eax
  808dac:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808db0:	50                   	push   %eax
  808db1:	ff 75 10             	pushl  0x10(%ebp)
  808db4:	57                   	push   %edi
  808db5:	56                   	push   %esi
  808db6:	e8 28 da ff ff       	call   8067e3 <ip_output_if>
  808dbb:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  808dbd:	83 c4 20             	add    $0x20,%esp
  808dc0:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808dc3:	74 15                	je     808dda <udp_sendto_if+0x181>
    /* free the header pbuf */
    pbuf_free(q);
  808dc5:	83 ec 0c             	sub    $0xc,%esp
  808dc8:	56                   	push   %esi
  808dc9:	e8 21 ba ff ff       	call   8047ef <pbuf_free>
  808dce:	83 c4 10             	add    $0x10,%esp
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  808dd1:	89 d8                	mov    %ebx,%eax
  808dd3:	eb 05                	jmp    808dda <udp_sendto_if+0x181>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  808dd5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  808dda:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ddd:	5b                   	pop    %ebx
  808dde:	5e                   	pop    %esi
  808ddf:	5f                   	pop    %edi
  808de0:	5d                   	pop    %ebp
  808de1:	c3                   	ret    

00808de2 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  808de2:	55                   	push   %ebp
  808de3:	89 e5                	mov    %esp,%ebp
  808de5:	56                   	push   %esi
  808de6:	53                   	push   %ebx
  808de7:	8b 75 10             	mov    0x10(%ebp),%esi
  808dea:	8b 5d 14             	mov    0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  808ded:	83 ec 0c             	sub    $0xc,%esp
  808df0:	56                   	push   %esi
  808df1:	e8 82 d6 ff ff       	call   806478 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  808df6:	83 c4 10             	add    $0x10,%esp
  808df9:	85 c0                	test   %eax,%eax
  808dfb:	74 19                	je     808e16 <udp_sendto+0x34>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808dfd:	83 ec 0c             	sub    $0xc,%esp
  808e00:	50                   	push   %eax
  808e01:	0f b7 db             	movzwl %bx,%ebx
  808e04:	53                   	push   %ebx
  808e05:	56                   	push   %esi
  808e06:	ff 75 0c             	pushl  0xc(%ebp)
  808e09:	ff 75 08             	pushl  0x8(%ebp)
  808e0c:	e8 48 fe ff ff       	call   808c59 <udp_sendto_if>
  808e11:	83 c4 20             	add    $0x20,%esp
  808e14:	eb 05                	jmp    808e1b <udp_sendto+0x39>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  808e16:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  808e1b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808e1e:	5b                   	pop    %ebx
  808e1f:	5e                   	pop    %esi
  808e20:	5d                   	pop    %ebp
  808e21:	c3                   	ret    

00808e22 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  808e22:	55                   	push   %ebp
  808e23:	89 e5                	mov    %esp,%ebp
  808e25:	83 ec 08             	sub    $0x8,%esp
  808e28:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808e2b:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808e2f:	52                   	push   %edx
  808e30:	8d 50 04             	lea    0x4(%eax),%edx
  808e33:	52                   	push   %edx
  808e34:	ff 75 0c             	pushl  0xc(%ebp)
  808e37:	50                   	push   %eax
  808e38:	e8 a5 ff ff ff       	call   808de2 <udp_sendto>
}
  808e3d:	c9                   	leave  
  808e3e:	c3                   	ret    

00808e3f <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808e3f:	55                   	push   %ebp
  808e40:	89 e5                	mov    %esp,%ebp
  808e42:	57                   	push   %edi
  808e43:	56                   	push   %esi
  808e44:	53                   	push   %ebx
  808e45:	83 ec 0c             	sub    $0xc,%esp
  808e48:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808e4b:	8b 75 0c             	mov    0xc(%ebp),%esi
  808e4e:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808e51:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808e56:	75 15                	jne    808e6d <udp_connect+0x2e>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808e58:	83 ec 04             	sub    $0x4,%esp
  808e5b:	6a 00                	push   $0x0
  808e5d:	53                   	push   %ebx
  808e5e:	53                   	push   %ebx
  808e5f:	e8 28 fd ff ff       	call   808b8c <udp_bind>
  808e64:	89 c2                	mov    %eax,%edx
    if (err != ERR_OK)
  808e66:	83 c4 10             	add    $0x10,%esp
  808e69:	84 d2                	test   %dl,%dl
  808e6b:	75 3d                	jne    808eaa <udp_connect+0x6b>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808e6d:	85 f6                	test   %esi,%esi
  808e6f:	74 04                	je     808e75 <udp_connect+0x36>
  808e71:	8b 06                	mov    (%esi),%eax
  808e73:	eb 05                	jmp    808e7a <udp_connect+0x3b>
  808e75:	b8 00 00 00 00       	mov    $0x0,%eax
  808e7a:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808e7d:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808e81:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e85:	8b 15 94 b3 b3 00    	mov    0xb3b394,%edx
  808e8b:	89 d0                	mov    %edx,%eax
  808e8d:	eb 07                	jmp    808e96 <udp_connect+0x57>
    if (pcb == ipcb) {
  808e8f:	39 c3                	cmp    %eax,%ebx
  808e91:	74 12                	je     808ea5 <udp_connect+0x66>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e93:	8b 40 0c             	mov    0xc(%eax),%eax
  808e96:	85 c0                	test   %eax,%eax
  808e98:	75 f5                	jne    808e8f <udp_connect+0x50>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808e9a:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808e9d:	89 1d 94 b3 b3 00    	mov    %ebx,0xb3b394
  return ERR_OK;
  808ea3:	eb 05                	jmp    808eaa <udp_connect+0x6b>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  808ea5:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  808eaa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ead:	5b                   	pop    %ebx
  808eae:	5e                   	pop    %esi
  808eaf:	5f                   	pop    %edi
  808eb0:	5d                   	pop    %ebp
  808eb1:	c3                   	ret    

00808eb2 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808eb2:	55                   	push   %ebp
  808eb3:	89 e5                	mov    %esp,%ebp
  808eb5:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808eb8:	8b 15 80 1d 81 00    	mov    0x811d80,%edx
  808ebe:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808ec1:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808ec7:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808ecb:	5d                   	pop    %ebp
  808ecc:	c3                   	ret    

00808ecd <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808ecd:	55                   	push   %ebp
  808ece:	89 e5                	mov    %esp,%ebp
  808ed0:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808ed3:	8b 55 0c             	mov    0xc(%ebp),%edx
  808ed6:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808ed9:	8b 55 10             	mov    0x10(%ebp),%edx
  808edc:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808edf:	5d                   	pop    %ebp
  808ee0:	c3                   	ret    

00808ee1 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808ee1:	55                   	push   %ebp
  808ee2:	89 e5                	mov    %esp,%ebp
  808ee4:	83 ec 08             	sub    $0x8,%esp
  808ee7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808eea:	a1 94 b3 b3 00       	mov    0xb3b394,%eax
  808eef:	39 c8                	cmp    %ecx,%eax
  808ef1:	75 1e                	jne    808f11 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808ef3:	8b 40 0c             	mov    0xc(%eax),%eax
  808ef6:	a3 94 b3 b3 00       	mov    %eax,0xb3b394
  808efb:	eb 18                	jmp    808f15 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808efd:	8b 50 0c             	mov    0xc(%eax),%edx
  808f00:	39 d1                	cmp    %edx,%ecx
  808f02:	75 0a                	jne    808f0e <udp_remove+0x2d>
  808f04:	85 d2                	test   %edx,%edx
  808f06:	74 06                	je     808f0e <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  808f08:	8b 51 0c             	mov    0xc(%ecx),%edx
  808f0b:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808f0e:	8b 40 0c             	mov    0xc(%eax),%eax
  808f11:	85 c0                	test   %eax,%eax
  808f13:	75 e8                	jne    808efd <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808f15:	83 ec 08             	sub    $0x8,%esp
  808f18:	51                   	push   %ecx
  808f19:	6a 01                	push   $0x1
  808f1b:	e8 5c b5 ff ff       	call   80447c <memp_free>
  808f20:	83 c4 10             	add    $0x10,%esp
}
  808f23:	c9                   	leave  
  808f24:	c3                   	ret    

00808f25 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808f25:	55                   	push   %ebp
  808f26:	89 e5                	mov    %esp,%ebp
  808f28:	53                   	push   %ebx
  808f29:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808f2c:	6a 01                	push   $0x1
  808f2e:	e8 f3 b4 ff ff       	call   804426 <memp_malloc>
  808f33:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808f35:	83 c4 10             	add    $0x10,%esp
  808f38:	85 c0                	test   %eax,%eax
  808f3a:	74 14                	je     808f50 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808f3c:	83 ec 04             	sub    $0x4,%esp
  808f3f:	6a 20                	push   $0x20
  808f41:	6a 00                	push   $0x0
  808f43:	50                   	push   %eax
  808f44:	e8 3d 5c 00 00       	call   80eb86 <memset>
    pcb->ttl = UDP_TTL;
  808f49:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808f4d:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808f50:	89 d8                	mov    %ebx,%eax
  808f52:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808f55:	c9                   	leave  
  808f56:	c3                   	ret    

00808f57 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808f57:	55                   	push   %ebp
  808f58:	89 e5                	mov    %esp,%ebp
  808f5a:	56                   	push   %esi
  808f5b:	53                   	push   %ebx
  808f5c:	89 c3                	mov    %eax,%ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808f5e:	85 c0                	test   %eax,%eax
  808f60:	75 17                	jne    808f79 <free_etharp_q+0x22>
  808f62:	83 ec 04             	sub    $0x4,%esp
  808f65:	68 88 18 81 00       	push   $0x811888
  808f6a:	68 93 00 00 00       	push   $0x93
  808f6f:	68 72 21 81 00       	push   $0x812172
  808f74:	e8 68 54 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808f79:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  808f7d:	75 17                	jne    808f96 <free_etharp_q+0x3f>
  808f7f:	83 ec 04             	sub    $0x4,%esp
  808f82:	68 8a 21 81 00       	push   $0x81218a
  808f87:	68 94 00 00 00       	push   $0x94
  808f8c:	68 72 21 81 00       	push   $0x812172
  808f91:	e8 4b 54 00 00       	call   80e3e1 <_panic>
  while (q) {
    r = q;
    q = q->next;
  808f96:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  808f98:	8b 43 04             	mov    0x4(%ebx),%eax
  808f9b:	85 c0                	test   %eax,%eax
  808f9d:	75 17                	jne    808fb6 <free_etharp_q+0x5f>
  808f9f:	83 ec 04             	sub    $0x4,%esp
  808fa2:	68 97 21 81 00       	push   $0x812197
  808fa7:	68 98 00 00 00       	push   $0x98
  808fac:	68 72 21 81 00       	push   $0x812172
  808fb1:	e8 2b 54 00 00       	call   80e3e1 <_panic>
    pbuf_free(r->p);
  808fb6:	83 ec 0c             	sub    $0xc,%esp
  808fb9:	50                   	push   %eax
  808fba:	e8 30 b8 ff ff       	call   8047ef <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  808fbf:	83 c4 08             	add    $0x8,%esp
  808fc2:	53                   	push   %ebx
  808fc3:	6a 0a                	push   $0xa
  808fc5:	e8 b2 b4 ff ff       	call   80447c <memp_free>
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
  808fca:	89 f3                	mov    %esi,%ebx
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  808fcc:	83 c4 10             	add    $0x10,%esp
  808fcf:	85 f6                	test   %esi,%esi
  808fd1:	75 c3                	jne    808f96 <free_etharp_q+0x3f>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  808fd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808fd6:	5b                   	pop    %ebx
  808fd7:	5e                   	pop    %esi
  808fd8:	5d                   	pop    %ebp
  808fd9:	c3                   	ret    

00808fda <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  808fda:	55                   	push   %ebp
  808fdb:	89 e5                	mov    %esp,%ebp
  808fdd:	57                   	push   %edi
  808fde:	56                   	push   %esi
  808fdf:	53                   	push   %ebx
  808fe0:	83 ec 1c             	sub    $0x1c,%esp
  808fe3:	89 d7                	mov    %edx,%edi
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  808fe5:	85 c0                	test   %eax,%eax
  808fe7:	74 2e                	je     809017 <find_entry+0x3d>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  808fe9:	0f b6 15 c0 4a b3 00 	movzbl 0xb34ac0,%edx
  808ff0:	0f b6 ca             	movzbl %dl,%ecx
  808ff3:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  808ff6:	83 bb 10 4b b3 00 02 	cmpl   $0x2,0xb34b10(%ebx)
  808ffd:	75 37                	jne    809036 <find_entry+0x5c>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  808fff:	8b 8b 04 4b b3 00    	mov    0xb34b04(%ebx),%ecx
  809005:	39 08                	cmp    %ecx,(%eax)
  809007:	75 4c                	jne    809055 <find_entry+0x7b>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  809009:	89 d0                	mov    %edx,%eax
  80900b:	e9 26 02 00 00       	jmp    809236 <find_entry+0x25c>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809010:	80 f9 0a             	cmp    $0xa,%cl
  809013:	75 78                	jne    80908d <find_entry+0xb3>
  809015:	eb 5b                	jmp    809072 <find_entry+0x98>
  809017:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80901b:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  80901f:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809023:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809027:	ba 00 00 00 00       	mov    $0x0,%edx
  80902c:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809030:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809034:	eb 3c                	jmp    809072 <find_entry+0x98>
  809036:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80903a:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  80903e:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809042:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809046:	ba 00 00 00 00       	mov    $0x0,%edx
  80904b:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80904f:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809053:	eb 1d                	jmp    809072 <find_entry+0x98>
  809055:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809059:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  80905d:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809061:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809065:	ba 00 00 00 00       	mov    $0x0,%edx
  80906a:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80906e:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809072:	0f b6 ca             	movzbl %dl,%ecx
  809075:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  809078:	83 b9 10 4b b3 00 00 	cmpl   $0x0,0xb34b10(%ecx)
  80907f:	75 07                	jne    809088 <find_entry+0xae>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  809081:	89 d1                	mov    %edx,%ecx
  809083:	e9 a3 00 00 00       	jmp    80912b <find_entry+0x151>
  809088:	b9 0a 00 00 00       	mov    $0xa,%ecx
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80908d:	0f b6 da             	movzbl %dl,%ebx
  809090:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809093:	8b b6 10 4b b3 00    	mov    0xb34b10(%esi),%esi
  809099:	83 fe 01             	cmp    $0x1,%esi
  80909c:	75 55                	jne    8090f3 <find_entry+0x119>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80909e:	85 c0                	test   %eax,%eax
  8090a0:	74 1a                	je     8090bc <find_entry+0xe2>
  8090a2:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8090a5:	8b b6 04 4b b3 00    	mov    0xb34b04(%esi),%esi
  8090ab:	39 30                	cmp    %esi,(%eax)
  8090ad:	75 0d                	jne    8090bc <find_entry+0xe2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8090af:	88 15 c0 4a b3 00    	mov    %dl,0xb34ac0
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8090b5:	89 d0                	mov    %edx,%eax
  8090b7:	e9 7a 01 00 00       	jmp    809236 <find_entry+0x25c>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  8090bc:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8090bf:	83 be 00 4b b3 00 00 	cmpl   $0x0,0xb34b00(%esi)
  8090c6:	74 14                	je     8090dc <find_entry+0x102>
        if (arp_table[i].ctime >= age_queue) {
  8090c8:	0f b6 9e 14 4b b3 00 	movzbl 0xb34b14(%esi),%ebx
  8090cf:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  8090d2:	72 57                	jb     80912b <find_entry+0x151>
          old_queue = i;
  8090d4:	88 55 e4             	mov    %dl,-0x1c(%ebp)
          age_queue = arp_table[i].ctime;
  8090d7:	88 5d e7             	mov    %bl,-0x19(%ebp)
  8090da:	eb 4f                	jmp    80912b <find_entry+0x151>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  8090dc:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  8090df:	0f b6 9b 14 4b b3 00 	movzbl 0xb34b14(%ebx),%ebx
  8090e6:	3a 5d e3             	cmp    -0x1d(%ebp),%bl
  8090e9:	72 40                	jb     80912b <find_entry+0x151>
          old_pending = i;
  8090eb:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  8090ee:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  8090f1:	eb 38                	jmp    80912b <find_entry+0x151>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8090f3:	83 fe 02             	cmp    $0x2,%esi
  8090f6:	75 33                	jne    80912b <find_entry+0x151>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8090f8:	85 c0                	test   %eax,%eax
  8090fa:	74 1a                	je     809116 <find_entry+0x13c>
  8090fc:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8090ff:	8b b6 04 4b b3 00    	mov    0xb34b04(%esi),%esi
  809105:	39 30                	cmp    %esi,(%eax)
  809107:	75 0d                	jne    809116 <find_entry+0x13c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809109:	88 15 c0 4a b3 00    	mov    %dl,0xb34ac0
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80910f:	89 d0                	mov    %edx,%eax
  809111:	e9 20 01 00 00       	jmp    809236 <find_entry+0x25c>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809116:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809119:	0f b6 9b 14 4b b3 00 	movzbl 0xb34b14(%ebx),%ebx
  809120:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  809123:	72 06                	jb     80912b <find_entry+0x151>
        old_stable = i;
  809125:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809128:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80912b:	83 c2 01             	add    $0x1,%edx
  80912e:	80 fa 09             	cmp    $0x9,%dl
  809131:	0f 86 d9 fe ff ff    	jbe    809010 <find_entry+0x36>
  809137:	89 fa                	mov    %edi,%edx
  809139:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80913b:	80 f9 0a             	cmp    $0xa,%cl
  80913e:	75 0e                	jne    80914e <find_entry+0x174>
  809140:	f6 c2 01             	test   $0x1,%dl
  809143:	0f 85 e2 00 00 00    	jne    80922b <find_entry+0x251>
  809149:	e9 c1 00 00 00       	jmp    80920f <find_entry+0x235>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80914e:	f6 c2 02             	test   $0x2,%dl
  809151:	0f 85 bf 00 00 00    	jne    809216 <find_entry+0x23c>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  809157:	89 ce                	mov    %ecx,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  809159:	80 f9 09             	cmp    $0x9,%cl
  80915c:	7e 63                	jle    8091c1 <find_entry+0x1e7>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80915e:	80 7d e5 09          	cmpb   $0x9,-0x1b(%ebp)
  809162:	7f 2c                	jg     809190 <find_entry+0x1b6>
    /* recycle oldest stable*/
    i = old_stable;
  809164:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809168:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80916a:	0f b6 c0             	movzbl %al,%eax
  80916d:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809170:	83 b8 00 4b b3 00 00 	cmpl   $0x0,0xb34b00(%eax)
  809177:	74 48                	je     8091c1 <find_entry+0x1e7>
  809179:	83 ec 04             	sub    $0x4,%esp
  80917c:	68 a4 21 81 00       	push   $0x8121a4
  809181:	68 75 01 00 00       	push   $0x175
  809186:	68 72 21 81 00       	push   $0x812172
  80918b:	e8 51 52 00 00       	call   80e3e1 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809190:	80 7d e2 09          	cmpb   $0x9,-0x1e(%ebp)
  809194:	7f 06                	jg     80919c <find_entry+0x1c2>
    /* recycle oldest pending */
    i = old_pending;
  809196:	0f b6 75 e2          	movzbl -0x1e(%ebp),%esi
  80919a:	eb 25                	jmp    8091c1 <find_entry+0x1e7>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80919c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8091a0:	3c 09                	cmp    $0x9,%al
  8091a2:	7f 79                	jg     80921d <find_entry+0x243>
    /* recycle oldest pending */
    i = old_queue;
  8091a4:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  8091a6:	0f b6 f8             	movzbl %al,%edi
  8091a9:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8091ac:	8b 87 00 4b b3 00    	mov    0xb34b00(%edi),%eax
  8091b2:	e8 a0 fd ff ff       	call   808f57 <free_etharp_q>
    arp_table[i].q = NULL;
  8091b7:	c7 87 00 4b b3 00 00 	movl   $0x0,0xb34b00(%edi)
  8091be:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8091c1:	89 f0                	mov    %esi,%eax
  8091c3:	3c 09                	cmp    $0x9,%al
  8091c5:	76 17                	jbe    8091de <find_entry+0x204>
  8091c7:	83 ec 04             	sub    $0x4,%esp
  8091ca:	68 bb 21 81 00       	push   $0x8121bb
  8091cf:	68 8b 01 00 00       	push   $0x18b
  8091d4:	68 72 21 81 00       	push   $0x812172
  8091d9:	e8 03 52 00 00       	call   80e3e1 <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8091de:	89 f0                	mov    %esi,%eax
  8091e0:	0f b6 c0             	movzbl %al,%eax
  8091e3:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8091e6:	c7 82 10 4b b3 00 00 	movl   $0x0,0xb34b10(%edx)
  8091ed:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  8091f0:	85 db                	test   %ebx,%ebx
  8091f2:	74 08                	je     8091fc <find_entry+0x222>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  8091f4:	8b 0b                	mov    (%ebx),%ecx
  8091f6:	89 8a 04 4b b3 00    	mov    %ecx,0xb34b04(%edx)
  }
  arp_table[i].ctime = 0;
  8091fc:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8091ff:	c6 80 14 4b b3 00 00 	movb   $0x0,0xb34b14(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809206:	89 f0                	mov    %esi,%eax
  809208:	a2 c0 4a b3 00       	mov    %al,0xb34ac0
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80920d:	eb 27                	jmp    809236 <find_entry+0x25c>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  80920f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809214:	eb 20                	jmp    809236 <find_entry+0x25c>
  809216:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80921b:	eb 19                	jmp    809236 <find_entry+0x25c>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  80921d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809222:	eb 12                	jmp    809236 <find_entry+0x25c>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809224:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809229:	eb 0b                	jmp    809236 <find_entry+0x25c>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80922b:	f6 c2 02             	test   $0x2,%dl
  80922e:	0f 84 2a ff ff ff    	je     80915e <find_entry+0x184>
  809234:	eb ee                	jmp    809224 <find_entry+0x24a>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809236:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809239:	5b                   	pop    %ebx
  80923a:	5e                   	pop    %esi
  80923b:	5f                   	pop    %edi
  80923c:	5d                   	pop    %ebp
  80923d:	c3                   	ret    

0080923e <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80923e:	55                   	push   %ebp
  80923f:	89 e5                	mov    %esp,%ebp
  809241:	57                   	push   %edi
  809242:	56                   	push   %esi
  809243:	53                   	push   %ebx
  809244:	83 ec 1c             	sub    $0x1c,%esp
  809247:	89 c6                	mov    %eax,%esi
  809249:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80924c:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  80924f:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809252:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809256:	74 17                	je     80926f <etharp_send_ip+0x31>
  809258:	83 ec 04             	sub    $0x4,%esp
  80925b:	68 e8 21 81 00       	push   $0x8121e8
  809260:	68 b3 01 00 00       	push   $0x1b3
  809265:	68 72 21 81 00       	push   $0x812172
  80926a:	e8 72 51 00 00       	call   80e3e1 <_panic>
  80926f:	b8 06 00 00 00       	mov    $0x6,%eax
  809274:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  809277:	83 e8 01             	sub    $0x1,%eax
    ethhdr->dest.addr[k] = dst->addr[k];
  80927a:	0f b6 d0             	movzbl %al,%edx
  80927d:	0f b6 0c 17          	movzbl (%edi,%edx,1),%ecx
  809281:	88 0c 13             	mov    %cl,(%ebx,%edx,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809284:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809287:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  80928b:	88 4c 13 06          	mov    %cl,0x6(%ebx,%edx,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80928f:	84 c0                	test   %al,%al
  809291:	75 e4                	jne    809277 <etharp_send_ip+0x39>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809293:	83 ec 0c             	sub    $0xc,%esp
  809296:	68 00 08 00 00       	push   $0x800
  80929b:	e8 ad e3 ff ff       	call   80764d <htons>
  8092a0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8092a4:	83 c4 08             	add    $0x8,%esp
  8092a7:	ff 75 e0             	pushl  -0x20(%ebp)
  8092aa:	56                   	push   %esi
  8092ab:	ff 56 18             	call   *0x18(%esi)
}
  8092ae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8092b1:	5b                   	pop    %ebx
  8092b2:	5e                   	pop    %esi
  8092b3:	5f                   	pop    %edi
  8092b4:	5d                   	pop    %ebp
  8092b5:	c3                   	ret    

008092b6 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  8092b6:	55                   	push   %ebp
  8092b7:	89 e5                	mov    %esp,%ebp
  8092b9:	57                   	push   %edi
  8092ba:	56                   	push   %esi
  8092bb:	53                   	push   %ebx
  8092bc:	83 ec 1c             	sub    $0x1c,%esp
  8092bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8092c2:	89 cb                	mov    %ecx,%ebx
  8092c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8092c7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  8092ca:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8092ce:	74 17                	je     8092e7 <update_arp_entry+0x31>
  8092d0:	83 ec 04             	sub    $0x4,%esp
  8092d3:	68 2c 22 81 00       	push   $0x81222c
  8092d8:	68 d9 01 00 00       	push   $0x1d9
  8092dd:	68 72 21 81 00       	push   $0x812172
  8092e2:	e8 fa 50 00 00       	call   80e3e1 <_panic>
  8092e7:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  8092e9:	85 d2                	test   %edx,%edx
  8092eb:	0f 84 eb 00 00 00    	je     8093dc <update_arp_entry+0x126>
  8092f1:	83 3a 00             	cmpl   $0x0,(%edx)
  8092f4:	0f 84 e9 00 00 00    	je     8093e3 <update_arp_entry+0x12d>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8092fa:	83 ec 08             	sub    $0x8,%esp
  8092fd:	ff 75 e4             	pushl  -0x1c(%ebp)
  809300:	52                   	push   %edx
  809301:	e8 26 d1 ff ff       	call   80642c <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809306:	83 c4 10             	add    $0x10,%esp
  809309:	84 c0                	test   %al,%al
  80930b:	0f 85 d9 00 00 00    	jne    8093ea <update_arp_entry+0x134>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809311:	8b 3e                	mov    (%esi),%edi
  809313:	83 ec 0c             	sub    $0xc,%esp
  809316:	68 00 00 00 f0       	push   $0xf0000000
  80931b:	e8 7e e5 ff ff       	call   80789e <ntohl>
  809320:	21 c7                	and    %eax,%edi
  809322:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809329:	e8 70 e5 ff ff       	call   80789e <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  80932e:	83 c4 10             	add    $0x10,%esp
  809331:	39 c7                	cmp    %eax,%edi
  809333:	0f 84 b8 00 00 00    	je     8093f1 <update_arp_entry+0x13b>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809339:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  80933d:	89 f0                	mov    %esi,%eax
  80933f:	e8 96 fc ff ff       	call   808fda <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809344:	84 c0                	test   %al,%al
  809346:	0f 88 aa 00 00 00    	js     8093f6 <update_arp_entry+0x140>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80934c:	0f be f0             	movsbl %al,%esi
  80934f:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809352:	c7 80 10 4b b3 00 02 	movl   $0x2,0xb34b10(%eax)
  809359:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80935c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80935f:	89 88 18 4b b3 00    	mov    %ecx,0xb34b18(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  809365:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80936a:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80936d:	89 d7                	mov    %edx,%edi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  80936f:	83 ef 01             	sub    $0x1,%edi
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809372:	89 f9                	mov    %edi,%ecx
  809374:	0f b6 c9             	movzbl %cl,%ecx
  809377:	0f b6 14 0b          	movzbl (%ebx,%ecx,1),%edx
  80937b:	88 94 01 08 4b b3 00 	mov    %dl,0xb34b08(%ecx,%eax,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  809382:	89 f9                	mov    %edi,%ecx
  809384:	84 c9                	test   %cl,%cl
  809386:	75 e7                	jne    80936f <update_arp_entry+0xb9>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809388:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80938b:	c6 80 14 4b b3 00 00 	movb   $0x0,0xb34b14(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809392:	89 c6                	mov    %eax,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809394:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809397:	83 c0 25             	add    $0x25,%eax
  80939a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80939d:	eb 31                	jmp    8093d0 <update_arp_entry+0x11a>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80939f:	8b 10                	mov    (%eax),%edx
  8093a1:	89 96 00 4b b3 00    	mov    %edx,0xb34b00(%esi)
    /* get the packet pointer */
    p = q->p;
  8093a7:	8b 78 04             	mov    0x4(%eax),%edi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8093aa:	83 ec 08             	sub    $0x8,%esp
  8093ad:	50                   	push   %eax
  8093ae:	6a 0a                	push   $0xa
  8093b0:	e8 c7 b0 ff ff       	call   80447c <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8093b5:	89 1c 24             	mov    %ebx,(%esp)
  8093b8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8093bb:	89 fa                	mov    %edi,%edx
  8093bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8093c0:	e8 79 fe ff ff       	call   80923e <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  8093c5:	89 3c 24             	mov    %edi,(%esp)
  8093c8:	e8 22 b4 ff ff       	call   8047ef <pbuf_free>
  8093cd:	83 c4 10             	add    $0x10,%esp
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8093d0:	8b 86 00 4b b3 00    	mov    0xb34b00(%esi),%eax
  8093d6:	85 c0                	test   %eax,%eax
  8093d8:	75 c5                	jne    80939f <update_arp_entry+0xe9>
  8093da:	eb 1a                	jmp    8093f6 <update_arp_entry+0x140>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  8093dc:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8093e1:	eb 13                	jmp    8093f6 <update_arp_entry+0x140>
  8093e3:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8093e8:	eb 0c                	jmp    8093f6 <update_arp_entry+0x140>
  8093ea:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8093ef:	eb 05                	jmp    8093f6 <update_arp_entry+0x140>
  8093f1:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  8093f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8093f9:	5b                   	pop    %ebx
  8093fa:	5e                   	pop    %esi
  8093fb:	5f                   	pop    %edi
  8093fc:	5d                   	pop    %ebp
  8093fd:	c3                   	ret    

008093fe <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  8093fe:	55                   	push   %ebp
  8093ff:	89 e5                	mov    %esp,%ebp
  809401:	57                   	push   %edi
  809402:	56                   	push   %esi
  809403:	53                   	push   %ebx
  809404:	83 ec 0c             	sub    $0xc,%esp
  809407:	bb 14 4b b3 00       	mov    $0xb34b14,%ebx
  80940c:	bf 2c 4c b3 00       	mov    $0xb34c2c,%edi
  809411:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  809413:	0f b6 03             	movzbl (%ebx),%eax
  809416:	83 c0 01             	add    $0x1,%eax
  809419:	88 03                	mov    %al,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80941b:	8b 53 fc             	mov    -0x4(%ebx),%edx
  80941e:	3c ef                	cmp    $0xef,%al
  809420:	76 05                	jbe    809427 <etharp_tmr+0x29>
  809422:	83 fa 02             	cmp    $0x2,%edx
  809425:	74 09                	je     809430 <etharp_tmr+0x32>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809427:	3c 01                	cmp    $0x1,%al
  809429:	76 1f                	jbe    80944a <etharp_tmr+0x4c>
  80942b:	83 fa 01             	cmp    $0x1,%edx
  80942e:	75 1a                	jne    80944a <etharp_tmr+0x4c>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809430:	8b 46 ec             	mov    -0x14(%esi),%eax
  809433:	85 c0                	test   %eax,%eax
  809435:	74 0c                	je     809443 <etharp_tmr+0x45>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  809437:	e8 1b fb ff ff       	call   808f57 <free_etharp_q>
        arp_table[i].q = NULL;
  80943c:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809443:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  80944a:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80944d:	39 fb                	cmp    %edi,%ebx
  80944f:	75 c0                	jne    809411 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809451:	83 c4 0c             	add    $0xc,%esp
  809454:	5b                   	pop    %ebx
  809455:	5e                   	pop    %esi
  809456:	5f                   	pop    %edi
  809457:	5d                   	pop    %ebp
  809458:	c3                   	ret    

00809459 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809459:	55                   	push   %ebp
  80945a:	89 e5                	mov    %esp,%ebp
  80945c:	53                   	push   %ebx
  80945d:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809460:	ba 02 00 00 00       	mov    $0x2,%edx
  809465:	8b 45 0c             	mov    0xc(%ebp),%eax
  809468:	e8 6d fb ff ff       	call   808fda <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80946d:	84 c0                	test   %al,%al
  80946f:	78 29                	js     80949a <etharp_find_addr+0x41>
  809471:	0f be d0             	movsbl %al,%edx
  809474:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809477:	83 b9 10 4b b3 00 02 	cmpl   $0x2,0xb34b10(%ecx)
  80947e:	75 21                	jne    8094a1 <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  809480:	89 ca                	mov    %ecx,%edx
  809482:	8d 99 08 4b b3 00    	lea    0xb34b08(%ecx),%ebx
  809488:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80948b:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80948d:	81 c2 04 4b b3 00    	add    $0xb34b04,%edx
  809493:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809496:	89 11                	mov    %edx,(%ecx)
      return i;
  809498:	eb 0c                	jmp    8094a6 <etharp_find_addr+0x4d>
  }
  return -1;
  80949a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80949f:	eb 05                	jmp    8094a6 <etharp_find_addr+0x4d>
  8094a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8094a6:	83 c4 04             	add    $0x4,%esp
  8094a9:	5b                   	pop    %ebx
  8094aa:	5d                   	pop    %ebp
  8094ab:	c3                   	ret    

008094ac <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  8094ac:	55                   	push   %ebp
  8094ad:	89 e5                	mov    %esp,%ebp
  8094af:	83 ec 08             	sub    $0x8,%esp
  8094b2:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8094b5:	85 c0                	test   %eax,%eax
  8094b7:	75 17                	jne    8094d0 <etharp_ip_input+0x24>
  8094b9:	83 ec 04             	sub    $0x4,%esp
  8094bc:	68 e2 14 81 00       	push   $0x8114e2
  8094c1:	68 48 02 00 00       	push   $0x248
  8094c6:	68 72 21 81 00       	push   $0x812172
  8094cb:	e8 11 4f 00 00       	call   80e3e1 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  8094d0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8094d3:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  8094d6:	8b 48 04             	mov    0x4(%eax),%ecx
  8094d9:	33 4a 1c             	xor    0x1c(%edx),%ecx
  8094dc:	85 48 08             	test   %ecx,0x8(%eax)
  8094df:	75 13                	jne    8094f4 <etharp_ip_input+0x48>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8094e1:	83 ec 0c             	sub    $0xc,%esp
  8094e4:	8d 4a 06             	lea    0x6(%edx),%ecx
  8094e7:	83 c2 1c             	add    $0x1c,%edx
  8094ea:	6a 00                	push   $0x0
  8094ec:	e8 c5 fd ff ff       	call   8092b6 <update_arp_entry>
  8094f1:	83 c4 10             	add    $0x10,%esp
}
  8094f4:	c9                   	leave  
  8094f5:	c3                   	ret    

008094f6 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8094f6:	55                   	push   %ebp
  8094f7:	89 e5                	mov    %esp,%ebp
  8094f9:	57                   	push   %edi
  8094fa:	56                   	push   %esi
  8094fb:	53                   	push   %ebx
  8094fc:	83 ec 1c             	sub    $0x1c,%esp
  8094ff:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809502:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809506:	75 17                	jne    80951f <etharp_arp_input+0x29>
  809508:	83 ec 04             	sub    $0x4,%esp
  80950b:	68 e2 14 81 00       	push   $0x8114e2
  809510:	68 75 02 00 00       	push   $0x275
  809515:	68 72 21 81 00       	push   $0x812172
  80951a:	e8 c2 4e 00 00       	call   80e3e1 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80951f:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  809524:	77 11                	ja     809537 <etharp_arp_input+0x41>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809526:	83 ec 0c             	sub    $0xc,%esp
  809529:	53                   	push   %ebx
  80952a:	e8 c0 b2 ff ff       	call   8047ef <pbuf_free>
    return;
  80952f:	83 c4 10             	add    $0x10,%esp
  809532:	e9 b4 01 00 00       	jmp    8096eb <etharp_arp_input+0x1f5>
  }

  hdr = p->payload;
  809537:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80953a:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80953e:	83 ec 0c             	sub    $0xc,%esp
  809541:	6a 01                	push   $0x1
  809543:	e8 05 e1 ff ff       	call   80764d <htons>
  809548:	83 c4 10             	add    $0x10,%esp
  80954b:	66 39 c7             	cmp    %ax,%di
  80954e:	75 4b                	jne    80959b <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809550:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  809554:	83 ec 0c             	sub    $0xc,%esp
  809557:	68 04 06 00 00       	push   $0x604
  80955c:	e8 ec e0 ff ff       	call   80764d <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809561:	83 c4 10             	add    $0x10,%esp
  809564:	66 39 c7             	cmp    %ax,%di
  809567:	75 32                	jne    80959b <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809569:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80956d:	83 ec 0c             	sub    $0xc,%esp
  809570:	68 00 08 00 00       	push   $0x800
  809575:	e8 d3 e0 ff ff       	call   80764d <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80957a:	83 c4 10             	add    $0x10,%esp
  80957d:	66 39 c7             	cmp    %ax,%di
  809580:	75 19                	jne    80959b <etharp_arp_input+0xa5>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809582:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809586:	83 ec 0c             	sub    $0xc,%esp
  809589:	68 06 08 00 00       	push   $0x806
  80958e:	e8 ba e0 ff ff       	call   80764d <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809593:	83 c4 10             	add    $0x10,%esp
  809596:	66 39 c7             	cmp    %ax,%di
  809599:	74 11                	je     8095ac <etharp_arp_input+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80959b:	83 ec 0c             	sub    $0xc,%esp
  80959e:	53                   	push   %ebx
  80959f:	e8 4b b2 ff ff       	call   8047ef <pbuf_free>
    return;
  8095a4:	83 c4 10             	add    $0x10,%esp
  8095a7:	e9 3f 01 00 00       	jmp    8096eb <etharp_arp_input+0x1f5>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8095ac:	83 ec 04             	sub    $0x4,%esp
  8095af:	6a 04                	push   $0x4
  8095b1:	8d 46 1c             	lea    0x1c(%esi),%eax
  8095b4:	50                   	push   %eax
  8095b5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8095b8:	50                   	push   %eax
  8095b9:	e8 7d 56 00 00       	call   80ec3b <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  8095be:	83 c4 0c             	add    $0xc,%esp
  8095c1:	6a 04                	push   $0x4
  8095c3:	8d 46 26             	lea    0x26(%esi),%eax
  8095c6:	50                   	push   %eax
  8095c7:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8095ca:	50                   	push   %eax
  8095cb:	e8 6b 56 00 00       	call   80ec3b <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  8095d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8095d3:	8b 40 04             	mov    0x4(%eax),%eax
  8095d6:	83 c4 10             	add    $0x10,%esp
  8095d9:	85 c0                	test   %eax,%eax
  8095db:	74 3c                	je     809619 <etharp_arp_input+0x123>
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  }

  /* ARP message directed to us? */
  if (for_us) {
  8095dd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  8095e0:	75 37                	jne    809619 <etharp_arp_input+0x123>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8095e2:	83 ec 0c             	sub    $0xc,%esp
  8095e5:	8d 4e 16             	lea    0x16(%esi),%ecx
  8095e8:	6a 01                	push   $0x1
  8095ea:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8095ed:	8b 45 08             	mov    0x8(%ebp),%eax
  8095f0:	e8 c1 fc ff ff       	call   8092b6 <update_arp_entry>
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  8095f5:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8095f9:	89 04 24             	mov    %eax,(%esp)
  8095fc:	e8 4c e0 ff ff       	call   80764d <htons>
  809601:	83 c4 10             	add    $0x10,%esp
  809604:	66 83 f8 01          	cmp    $0x1,%ax
  809608:	74 40                	je     80964a <etharp_arp_input+0x154>
  80960a:	66 83 f8 02          	cmp    $0x2,%ax
  80960e:	0f 84 b9 00 00 00    	je     8096cd <etharp_arp_input+0x1d7>
  809614:	e9 c6 00 00 00       	jmp    8096df <etharp_arp_input+0x1e9>
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809619:	83 ec 0c             	sub    $0xc,%esp
  80961c:	8d 4e 16             	lea    0x16(%esi),%ecx
  80961f:	6a 00                	push   $0x0
  809621:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809624:	8b 45 08             	mov    0x8(%ebp),%eax
  809627:	e8 8a fc ff ff       	call   8092b6 <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80962c:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809630:	89 04 24             	mov    %eax,(%esp)
  809633:	e8 15 e0 ff ff       	call   80764d <htons>
  809638:	83 c4 10             	add    $0x10,%esp
  80963b:	66 83 f8 02          	cmp    $0x2,%ax
  80963f:	0f 85 9a 00 00 00    	jne    8096df <etharp_arp_input+0x1e9>
  809645:	e9 83 00 00 00       	jmp    8096cd <etharp_arp_input+0x1d7>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80964a:	83 ec 0c             	sub    $0xc,%esp
  80964d:	6a 02                	push   $0x2
  80964f:	e8 f9 df ff ff       	call   80764d <htons>
  809654:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  809658:	8b 46 1c             	mov    0x1c(%esi),%eax
  80965b:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80965e:	8b 45 08             	mov    0x8(%ebp),%eax
  809661:	8b 40 04             	mov    0x4(%eax),%eax
  809664:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809667:	83 c4 10             	add    $0x10,%esp
  80966a:	ba 06 00 00 00       	mov    $0x6,%edx
  80966f:	8b 45 08             	mov    0x8(%ebp),%eax
  809672:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809676:	74 17                	je     80968f <etharp_arp_input+0x199>
  809678:	83 ec 04             	sub    $0x4,%esp
  80967b:	68 e8 21 81 00       	push   $0x8121e8
  809680:	68 c7 02 00 00       	push   $0x2c7
  809685:	68 72 21 81 00       	push   $0x812172
  80968a:	e8 52 4d 00 00       	call   80e3e1 <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80968f:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809692:	0f b6 c2             	movzbl %dl,%eax
  809695:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  80969a:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80969e:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  8096a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8096a4:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8096a8:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8096ac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8096af:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8096b3:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  8096b7:	84 d2                	test   %dl,%dl
  8096b9:	75 d4                	jne    80968f <etharp_arp_input+0x199>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  8096bb:	83 ec 08             	sub    $0x8,%esp
  8096be:	53                   	push   %ebx
  8096bf:	ff 75 08             	pushl  0x8(%ebp)
  8096c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8096c5:	ff 50 18             	call   *0x18(%eax)
  8096c8:	83 c4 10             	add    $0x10,%esp
  8096cb:	eb 12                	jmp    8096df <etharp_arp_input+0x1e9>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  8096cd:	83 ec 08             	sub    $0x8,%esp
  8096d0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8096d3:	50                   	push   %eax
  8096d4:	ff 75 08             	pushl  0x8(%ebp)
  8096d7:	e8 f7 a1 ff ff       	call   8038d3 <dhcp_arp_reply>
#endif
    break;
  8096dc:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  8096df:	83 ec 0c             	sub    $0xc,%esp
  8096e2:	53                   	push   %ebx
  8096e3:	e8 07 b1 ff ff       	call   8047ef <pbuf_free>
  8096e8:	83 c4 10             	add    $0x10,%esp
}
  8096eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8096ee:	5b                   	pop    %ebx
  8096ef:	5e                   	pop    %esi
  8096f0:	5f                   	pop    %edi
  8096f1:	5d                   	pop    %ebp
  8096f2:	c3                   	ret    

008096f3 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8096f3:	55                   	push   %ebp
  8096f4:	89 e5                	mov    %esp,%ebp
  8096f6:	57                   	push   %edi
  8096f7:	56                   	push   %esi
  8096f8:	53                   	push   %ebx
  8096f9:	83 ec 10             	sub    $0x10,%esp
  8096fc:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8096ff:	6a 00                	push   $0x0
  809701:	6a 2a                	push   $0x2a
  809703:	6a 02                	push   $0x2
  809705:	e8 ab b1 ff ff       	call   8048b5 <pbuf_alloc>
  80970a:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80970c:	83 c4 10             	add    $0x10,%esp
  80970f:	85 c0                	test   %eax,%eax
  809711:	0f 84 ea 00 00 00    	je     809801 <etharp_request+0x10e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809717:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80971c:	77 17                	ja     809735 <etharp_request+0x42>
  80971e:	83 ec 04             	sub    $0x4,%esp
  809721:	68 54 22 81 00       	push   $0x812254
  809726:	68 1c 04 00 00       	push   $0x41c
  80972b:	68 72 21 81 00       	push   $0x812172
  809730:	e8 ac 4c 00 00       	call   80e3e1 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  809735:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  809738:	83 ec 0c             	sub    $0xc,%esp
  80973b:	6a 01                	push   $0x1
  80973d:	e8 0b df ff ff       	call   80764d <htons>
  809742:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809746:	83 c4 10             	add    $0x10,%esp
  809749:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80974d:	74 17                	je     809766 <etharp_request+0x73>
  80974f:	83 ec 04             	sub    $0x4,%esp
  809752:	68 e8 21 81 00       	push   $0x8121e8
  809757:	68 23 04 00 00       	push   $0x423
  80975c:	68 72 21 81 00       	push   $0x812172
  809761:	e8 7b 4c 00 00       	call   80e3e1 <_panic>
  809766:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80976b:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80976e:	0f b6 c2             	movzbl %dl,%eax
  809771:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  809776:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80977a:	0f b6 88 d1 22 81 00 	movzbl 0x8122d1(%eax),%ecx
  809781:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809785:	0f b6 88 d7 22 81 00 	movzbl 0x8122d7(%eax),%ecx
  80978c:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80978f:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  809794:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  809798:	84 d2                	test   %dl,%dl
  80979a:	75 cf                	jne    80976b <etharp_request+0x78>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80979c:	8b 46 04             	mov    0x4(%esi),%eax
  80979f:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8097a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8097a5:	8b 00                	mov    (%eax),%eax
  8097a7:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8097aa:	83 ec 0c             	sub    $0xc,%esp
  8097ad:	6a 01                	push   $0x1
  8097af:	e8 99 de ff ff       	call   80764d <htons>
  8097b4:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  8097b8:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  8097bf:	e8 89 de ff ff       	call   80764d <htons>
  8097c4:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  8097c8:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  8097cf:	e8 79 de ff ff       	call   80764d <htons>
  8097d4:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  8097d8:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  8097df:	e8 69 de ff ff       	call   80764d <htons>
  8097e4:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  8097e8:	83 c4 08             	add    $0x8,%esp
  8097eb:	57                   	push   %edi
  8097ec:	56                   	push   %esi
  8097ed:	ff 56 18             	call   *0x18(%esi)
  8097f0:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  8097f2:	89 3c 24             	mov    %edi,(%esp)
  8097f5:	e8 f5 af ff ff       	call   8047ef <pbuf_free>
  8097fa:	83 c4 10             	add    $0x10,%esp
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  8097fd:	89 d8                	mov    %ebx,%eax
  8097ff:	eb 05                	jmp    809806 <etharp_request+0x113>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  809801:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809806:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809809:	5b                   	pop    %ebx
  80980a:	5e                   	pop    %esi
  80980b:	5f                   	pop    %edi
  80980c:	5d                   	pop    %ebp
  80980d:	c3                   	ret    

0080980e <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80980e:	55                   	push   %ebp
  80980f:	89 e5                	mov    %esp,%ebp
  809811:	57                   	push   %edi
  809812:	56                   	push   %esi
  809813:	53                   	push   %ebx
  809814:	83 ec 14             	sub    $0x14,%esp
  809817:	8b 7d 08             	mov    0x8(%ebp),%edi
  80981a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80981d:	57                   	push   %edi
  80981e:	53                   	push   %ebx
  80981f:	e8 08 cc ff ff       	call   80642c <ip_addr_isbroadcast>
  809824:	83 c4 10             	add    $0x10,%esp
  809827:	84 c0                	test   %al,%al
  809829:	0f 85 ae 01 00 00    	jne    8099dd <etharp_query+0x1cf>
      ip_addr_ismulticast(ipaddr) ||
  80982f:	8b 33                	mov    (%ebx),%esi
  809831:	83 ec 0c             	sub    $0xc,%esp
  809834:	68 00 00 00 f0       	push   $0xf0000000
  809839:	e8 60 e0 ff ff       	call   80789e <ntohl>
  80983e:	21 c6                	and    %eax,%esi
  809840:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809847:	e8 52 e0 ff ff       	call   80789e <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80984c:	83 c4 10             	add    $0x10,%esp
      ip_addr_ismulticast(ipaddr) ||
  80984f:	39 c6                	cmp    %eax,%esi
  809851:	0f 84 8d 01 00 00    	je     8099e4 <etharp_query+0x1d6>
  809857:	85 db                	test   %ebx,%ebx
  809859:	0f 84 85 01 00 00    	je     8099e4 <etharp_query+0x1d6>
      ip_addr_isany(ipaddr)) {
  80985f:	83 3b 00             	cmpl   $0x0,(%ebx)
  809862:	0f 84 83 01 00 00    	je     8099eb <etharp_query+0x1dd>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809868:	ba 01 00 00 00       	mov    $0x1,%edx
  80986d:	89 d8                	mov    %ebx,%eax
  80986f:	e8 66 f7 ff ff       	call   808fda <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  809874:	84 c0                	test   %al,%al
  809876:	0f 88 cb 01 00 00    	js     809a47 <etharp_query+0x239>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80987c:	0f be f0             	movsbl %al,%esi
  80987f:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809882:	8b 80 10 4b b3 00    	mov    0xb34b10(%eax),%eax
  809888:	85 c0                	test   %eax,%eax
  80988a:	75 0f                	jne    80989b <etharp_query+0x8d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80988c:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80988f:	c7 80 10 4b b3 00 01 	movl   $0x1,0xb34b10(%eax)
  809896:	00 00 00 
  809899:	eb 2a                	jmp    8098c5 <etharp_query+0xb7>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80989b:	8d 50 ff             	lea    -0x1(%eax),%edx
  80989e:	83 fa 01             	cmp    $0x1,%edx
  8098a1:	76 17                	jbe    8098ba <etharp_query+0xac>
  8098a3:	83 ec 04             	sub    $0x4,%esp
  8098a6:	68 88 22 81 00       	push   $0x812288
  8098ab:	68 92 03 00 00       	push   $0x392
  8098b0:	68 72 21 81 00       	push   $0x812172
  8098b5:	e8 27 4b 00 00       	call   80e3e1 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  8098ba:	83 f8 01             	cmp    $0x1,%eax
  8098bd:	74 06                	je     8098c5 <etharp_query+0xb7>
  8098bf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8098c3:	75 11                	jne    8098d6 <etharp_query+0xc8>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  8098c5:	83 ec 08             	sub    $0x8,%esp
  8098c8:	53                   	push   %ebx
  8098c9:	57                   	push   %edi
  8098ca:	e8 24 fe ff ff       	call   8096f3 <etharp_request>
  8098cf:	89 c3                	mov    %eax,%ebx
  8098d1:	83 c4 10             	add    $0x10,%esp
  8098d4:	eb 05                	jmp    8098db <etharp_query+0xcd>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  8098d6:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  8098db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8098df:	0f 84 0d 01 00 00    	je     8099f2 <etharp_query+0x1e4>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8098e5:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8098e8:	8b 90 10 4b b3 00    	mov    0xb34b10(%eax),%edx
  8098ee:	83 fa 02             	cmp    $0x2,%edx
  8098f1:	75 21                	jne    809914 <etharp_query+0x106>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  8098f3:	83 ec 0c             	sub    $0xc,%esp
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  8098f6:	8d 4f 25             	lea    0x25(%edi),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  8098f9:	89 c6                	mov    %eax,%esi
  8098fb:	81 c6 08 4b b3 00    	add    $0xb34b08,%esi
  809901:	56                   	push   %esi
  809902:	8b 55 10             	mov    0x10(%ebp),%edx
  809905:	89 f8                	mov    %edi,%eax
  809907:	e8 32 f9 ff ff       	call   80923e <etharp_send_ip>
  80990c:	83 c4 10             	add    $0x10,%esp
  80990f:	e9 33 01 00 00       	jmp    809a47 <etharp_query+0x239>
  809914:	89 d8                	mov    %ebx,%eax
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809916:	83 fa 01             	cmp    $0x1,%edx
  809919:	0f 85 28 01 00 00    	jne    809a47 <etharp_query+0x239>
  80991f:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809922:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
  809926:	66 39 48 0a          	cmp    %cx,0xa(%eax)
  80992a:	75 20                	jne    80994c <etharp_query+0x13e>
  80992c:	83 38 00             	cmpl   $0x0,(%eax)
  80992f:	0f 84 0a 01 00 00    	je     809a3f <etharp_query+0x231>
  809935:	83 ec 04             	sub    $0x4,%esp
  809938:	68 ce 21 81 00       	push   $0x8121ce
  80993d:	68 b1 03 00 00       	push   $0x3b1
  809942:	68 72 21 81 00       	push   $0x812172
  809947:	e8 95 4a 00 00       	call   80e3e1 <_panic>
        if(p->type != PBUF_ROM) {
  80994c:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809950:	0f 85 a0 00 00 00    	jne    8099f6 <etharp_query+0x1e8>
          copy_needed = 1;
          break;
        }
        p = p->next;
  809956:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  809958:	85 c0                	test   %eax,%eax
  80995a:	75 c6                	jne    809922 <etharp_query+0x114>
  80995c:	e9 b5 00 00 00       	jmp    809a16 <etharp_query+0x208>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  809961:	83 ec 08             	sub    $0x8,%esp
  809964:	ff 75 10             	pushl  0x10(%ebp)
  809967:	57                   	push   %edi
  809968:	e8 39 b4 ff ff       	call   804da6 <pbuf_copy>
  80996d:	83 c4 10             	add    $0x10,%esp
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809970:	89 7d 10             	mov    %edi,0x10(%ebp)
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  809973:	84 c0                	test   %al,%al
  809975:	0f 84 a9 00 00 00    	je     809a24 <etharp_query+0x216>
            pbuf_free(p);
  80997b:	83 ec 0c             	sub    $0xc,%esp
  80997e:	57                   	push   %edi
  80997f:	e8 6b ae ff ff       	call   8047ef <pbuf_free>
  809984:	83 c4 10             	add    $0x10,%esp
  809987:	e9 af 00 00 00       	jmp    809a3b <etharp_query+0x22d>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  80998c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809992:	8b 7d 10             	mov    0x10(%ebp),%edi
  809995:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809998:	6b d6 1c             	imul   $0x1c,%esi,%edx
  80999b:	8b 8a 00 4b b3 00    	mov    0xb34b00(%edx),%ecx
  8099a1:	85 c9                	test   %ecx,%ecx
  8099a3:	75 04                	jne    8099a9 <etharp_query+0x19b>
  8099a5:	eb 14                	jmp    8099bb <etharp_query+0x1ad>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  8099a7:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  8099a9:	8b 11                	mov    (%ecx),%edx
  8099ab:	85 d2                	test   %edx,%edx
  8099ad:	75 f8                	jne    8099a7 <etharp_query+0x199>
              r = r->next;
            }
            r->next = new_entry;
  8099af:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  8099b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8099b6:	e9 8c 00 00 00       	jmp    809a47 <etharp_query+0x239>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  8099bb:	6b f6 1c             	imul   $0x1c,%esi,%esi
  8099be:	89 86 00 4b b3 00    	mov    %eax,0xb34b00(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  8099c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8099c9:	eb 7c                	jmp    809a47 <etharp_query+0x239>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  8099cb:	83 ec 0c             	sub    $0xc,%esp
  8099ce:	ff 75 10             	pushl  0x10(%ebp)
  8099d1:	e8 19 ae ff ff       	call   8047ef <pbuf_free>
  8099d6:	83 c4 10             	add    $0x10,%esp
  8099d9:	89 d8                	mov    %ebx,%eax
  8099db:	eb 6a                	jmp    809a47 <etharp_query+0x239>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  8099dd:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8099e2:	eb 63                	jmp    809a47 <etharp_query+0x239>
  8099e4:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8099e9:	eb 5c                	jmp    809a47 <etharp_query+0x239>
  8099eb:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8099f0:	eb 55                	jmp    809a47 <etharp_query+0x239>
  8099f2:	89 d8                	mov    %ebx,%eax
  8099f4:	eb 51                	jmp    809a47 <etharp_query+0x239>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  8099f6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8099fa:	83 ec 04             	sub    $0x4,%esp
  8099fd:	6a 00                	push   $0x0
  8099ff:	50                   	push   %eax
  809a00:	6a 03                	push   $0x3
  809a02:	e8 ae ae ff ff       	call   8048b5 <pbuf_alloc>
  809a07:	89 c7                	mov    %eax,%edi
        if(p != NULL) {
  809a09:	83 c4 10             	add    $0x10,%esp
  809a0c:	85 c0                	test   %eax,%eax
  809a0e:	0f 85 4d ff ff ff    	jne    809961 <etharp_query+0x153>
  809a14:	eb 25                	jmp    809a3b <etharp_query+0x22d>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  809a16:	83 ec 0c             	sub    $0xc,%esp
  809a19:	ff 75 10             	pushl  0x10(%ebp)
  809a1c:	e8 38 b2 ff ff       	call   804c59 <pbuf_ref>
  809a21:	83 c4 10             	add    $0x10,%esp
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809a24:	83 ec 0c             	sub    $0xc,%esp
  809a27:	6a 0a                	push   $0xa
  809a29:	e8 f8 a9 ff ff       	call   804426 <memp_malloc>
        if (new_entry != NULL) {
  809a2e:	83 c4 10             	add    $0x10,%esp
  809a31:	85 c0                	test   %eax,%eax
  809a33:	0f 85 53 ff ff ff    	jne    80998c <etharp_query+0x17e>
  809a39:	eb 90                	jmp    8099cb <etharp_query+0x1bd>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  809a3b:	89 d8                	mov    %ebx,%eax
  809a3d:	eb 08                	jmp    809a47 <etharp_query+0x239>
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
  809a3f:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809a43:	74 d1                	je     809a16 <etharp_query+0x208>
  809a45:	eb af                	jmp    8099f6 <etharp_query+0x1e8>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  809a47:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809a4a:	5b                   	pop    %ebx
  809a4b:	5e                   	pop    %esi
  809a4c:	5f                   	pop    %edi
  809a4d:	5d                   	pop    %ebp
  809a4e:	c3                   	ret    

00809a4f <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  809a4f:	55                   	push   %ebp
  809a50:	89 e5                	mov    %esp,%ebp
  809a52:	57                   	push   %edi
  809a53:	56                   	push   %esi
  809a54:	53                   	push   %ebx
  809a55:	83 ec 24             	sub    $0x24,%esp
  809a58:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809a5b:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809a5e:	6a 0e                	push   $0xe
  809a60:	ff 75 0c             	pushl  0xc(%ebp)
  809a63:	e8 b5 ac ff ff       	call   80471d <pbuf_header>
  809a68:	83 c4 10             	add    $0x10,%esp
  809a6b:	84 c0                	test   %al,%al
  809a6d:	0f 85 bd 00 00 00    	jne    809b30 <etharp_output+0xe1>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809a73:	83 ec 08             	sub    $0x8,%esp
  809a76:	53                   	push   %ebx
  809a77:	56                   	push   %esi
  809a78:	e8 af c9 ff ff       	call   80642c <ip_addr_isbroadcast>
  809a7d:	83 c4 10             	add    $0x10,%esp
  809a80:	84 c0                	test   %al,%al
  809a82:	0f 85 8d 00 00 00    	jne    809b15 <etharp_output+0xc6>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  809a88:	8b 3e                	mov    (%esi),%edi
  809a8a:	83 ec 0c             	sub    $0xc,%esp
  809a8d:	68 00 00 00 f0       	push   $0xf0000000
  809a92:	e8 07 de ff ff       	call   80789e <ntohl>
  809a97:	21 c7                	and    %eax,%edi
  809a99:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809aa0:	e8 f9 dd ff ff       	call   80789e <ntohl>
  809aa5:	83 c4 10             	add    $0x10,%esp
  809aa8:	39 c7                	cmp    %eax,%edi
  809aaa:	75 44                	jne    809af0 <etharp_output+0xa1>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  809aac:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809ab0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809ab4:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809ab8:	83 ec 0c             	sub    $0xc,%esp
  809abb:	ff 36                	pushl  (%esi)
  809abd:	e8 dc dd ff ff       	call   80789e <ntohl>
  809ac2:	c1 e8 10             	shr    $0x10,%eax
  809ac5:	83 e0 7f             	and    $0x7f,%eax
  809ac8:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809acb:	83 c4 04             	add    $0x4,%esp
  809ace:	ff 36                	pushl  (%esi)
  809ad0:	e8 c9 dd ff ff       	call   80789e <ntohl>
  809ad5:	c1 e8 08             	shr    $0x8,%eax
  809ad8:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809adb:	83 c4 04             	add    $0x4,%esp
  809ade:	ff 36                	pushl  (%esi)
  809ae0:	e8 b9 dd ff ff       	call   80789e <ntohl>
  809ae5:	88 45 e7             	mov    %al,-0x19(%ebp)
  809ae8:	83 c4 10             	add    $0x10,%esp
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  809aeb:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809aee:	eb 2a                	jmp    809b1a <etharp_output+0xcb>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809af0:	8b 43 04             	mov    0x4(%ebx),%eax
  809af3:	33 06                	xor    (%esi),%eax
  809af5:	85 43 08             	test   %eax,0x8(%ebx)
  809af8:	74 09                	je     809b03 <etharp_output+0xb4>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  809afa:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809afe:	74 37                	je     809b37 <etharp_output+0xe8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  809b00:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  809b03:	83 ec 04             	sub    $0x4,%esp
  809b06:	ff 75 0c             	pushl  0xc(%ebp)
  809b09:	56                   	push   %esi
  809b0a:	53                   	push   %ebx
  809b0b:	e8 fe fc ff ff       	call   80980e <etharp_query>
  809b10:	83 c4 10             	add    $0x10,%esp
  809b13:	eb 27                	jmp    809b3c <etharp_output+0xed>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  809b15:	b8 d7 22 81 00       	mov    $0x8122d7,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809b1a:	83 ec 0c             	sub    $0xc,%esp
  809b1d:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809b20:	50                   	push   %eax
  809b21:	8b 55 0c             	mov    0xc(%ebp),%edx
  809b24:	89 d8                	mov    %ebx,%eax
  809b26:	e8 13 f7 ff ff       	call   80923e <etharp_send_ip>
  809b2b:	83 c4 10             	add    $0x10,%esp
  809b2e:	eb 0c                	jmp    809b3c <etharp_output+0xed>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  809b30:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809b35:	eb 05                	jmp    809b3c <etharp_output+0xed>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  809b37:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  809b3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b3f:	5b                   	pop    %ebx
  809b40:	5e                   	pop    %esi
  809b41:	5f                   	pop    %edi
  809b42:	5d                   	pop    %ebp
  809b43:	c3                   	ret    

00809b44 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809b44:	55                   	push   %ebp
  809b45:	89 e5                	mov    %esp,%ebp
  809b47:	56                   	push   %esi
  809b48:	53                   	push   %ebx
  809b49:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809b4c:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809b4f:	83 ec 0c             	sub    $0xc,%esp
  809b52:	8b 43 04             	mov    0x4(%ebx),%eax
  809b55:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809b59:	50                   	push   %eax
  809b5a:	e8 ee da ff ff       	call   80764d <htons>
  809b5f:	83 c4 10             	add    $0x10,%esp
  809b62:	66 3d 00 08          	cmp    $0x800,%ax
  809b66:	74 08                	je     809b70 <ethernet_input+0x2c>
  809b68:	66 3d 06 08          	cmp    $0x806,%ax
  809b6c:	74 44                	je     809bb2 <ethernet_input+0x6e>
  809b6e:	eb 55                	jmp    809bc5 <ethernet_input+0x81>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  809b70:	83 ec 08             	sub    $0x8,%esp
  809b73:	53                   	push   %ebx
  809b74:	56                   	push   %esi
  809b75:	e8 32 f9 ff ff       	call   8094ac <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809b7a:	83 c4 08             	add    $0x8,%esp
  809b7d:	6a f2                	push   $0xfffffff2
  809b7f:	53                   	push   %ebx
  809b80:	e8 98 ab ff ff       	call   80471d <pbuf_header>
  809b85:	83 c4 10             	add    $0x10,%esp
  809b88:	84 c0                	test   %al,%al
  809b8a:	74 17                	je     809ba3 <ethernet_input+0x5f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809b8c:	83 ec 04             	sub    $0x4,%esp
  809b8f:	68 b0 22 81 00       	push   $0x8122b0
  809b94:	68 7e 04 00 00       	push   $0x47e
  809b99:	68 72 21 81 00       	push   $0x812172
  809b9e:	e8 3e 48 00 00       	call   80e3e1 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  809ba3:	83 ec 08             	sub    $0x8,%esp
  809ba6:	56                   	push   %esi
  809ba7:	53                   	push   %ebx
  809ba8:	e8 29 c9 ff ff       	call   8064d6 <ip_input>
      }
      break;
  809bad:	83 c4 10             	add    $0x10,%esp
  809bb0:	eb 1f                	jmp    809bd1 <ethernet_input+0x8d>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809bb2:	83 ec 04             	sub    $0x4,%esp
  809bb5:	53                   	push   %ebx
  809bb6:	8d 46 25             	lea    0x25(%esi),%eax
  809bb9:	50                   	push   %eax
  809bba:	56                   	push   %esi
  809bbb:	e8 36 f9 ff ff       	call   8094f6 <etharp_arp_input>
      break;
  809bc0:	83 c4 10             	add    $0x10,%esp
  809bc3:	eb 0c                	jmp    809bd1 <ethernet_input+0x8d>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809bc5:	83 ec 0c             	sub    $0xc,%esp
  809bc8:	53                   	push   %ebx
  809bc9:	e8 21 ac ff ff       	call   8047ef <pbuf_free>
      p = NULL;
      break;
  809bce:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809bd1:	b8 00 00 00 00       	mov    $0x0,%eax
  809bd6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809bd9:	5b                   	pop    %ebx
  809bda:	5e                   	pop    %esi
  809bdb:	5d                   	pop    %ebp
  809bdc:	c3                   	ret    

00809bdd <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809bdd:	55                   	push   %ebp
  809bde:	89 e5                	mov    %esp,%ebp
  809be0:	53                   	push   %ebx
  809be1:	83 ec 10             	sub    $0x10,%esp
  809be4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809be7:	ff 73 04             	pushl  0x4(%ebx)
  809bea:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809bec:	89 1c 24             	mov    %ebx,(%esp)
  809bef:	e8 88 65 00 00       	call   81017c <free>
  809bf4:	83 c4 10             	add    $0x10,%esp
}
  809bf7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809bfa:	c9                   	leave  
  809bfb:	c3                   	ret    

00809bfc <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809bfc:	55                   	push   %ebp
  809bfd:	89 e5                	mov    %esp,%ebp
  809bff:	83 ec 08             	sub    $0x8,%esp
  809c02:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809c05:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809c0a:	89 c8                	mov    %ecx,%eax
  809c0c:	f7 e2                	mul    %edx
  809c0e:	c1 ea 08             	shr    $0x8,%edx
  809c11:	89 d0                	mov    %edx,%eax
  809c13:	c1 e0 08             	shl    $0x8,%eax
  809c16:	01 c2                	add    %eax,%edx
  809c18:	89 c8                	mov    %ecx,%eax
  809c1a:	29 d0                	sub    %edx,%eax
  809c1c:	8b 14 85 40 4c b3 00 	mov    0xb34c40(,%eax,4),%edx
  809c23:	eb 2a                	jmp    809c4f <timeout_cleanup+0x53>
	if (t->tid == tid) {
  809c25:	39 0a                	cmp    %ecx,(%edx)
  809c27:	75 23                	jne    809c4c <timeout_cleanup+0x50>
	    LIST_REMOVE(t, link);
  809c29:	8b 42 08             	mov    0x8(%edx),%eax
  809c2c:	85 c0                	test   %eax,%eax
  809c2e:	74 06                	je     809c36 <timeout_cleanup+0x3a>
  809c30:	8b 4a 0c             	mov    0xc(%edx),%ecx
  809c33:	89 48 0c             	mov    %ecx,0xc(%eax)
  809c36:	8b 42 0c             	mov    0xc(%edx),%eax
  809c39:	8b 4a 08             	mov    0x8(%edx),%ecx
  809c3c:	89 08                	mov    %ecx,(%eax)
	    free(t);
  809c3e:	83 ec 0c             	sub    $0xc,%esp
  809c41:	52                   	push   %edx
  809c42:	e8 35 65 00 00       	call   81017c <free>
	    goto done;
  809c47:	83 c4 10             	add    $0x10,%esp
  809c4a:	eb 07                	jmp    809c53 <timeout_cleanup+0x57>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809c4c:	8b 52 08             	mov    0x8(%edx),%edx
  809c4f:	85 d2                	test   %edx,%edx
  809c51:	75 d2                	jne    809c25 <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809c53:	c9                   	leave  
  809c54:	c3                   	ret    

00809c55 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  809c55:	55                   	push   %ebp
  809c56:	89 e5                	mov    %esp,%ebp
  809c58:	56                   	push   %esi
  809c59:	53                   	push   %ebx
  809c5a:	8b 15 80 9e b3 00    	mov    0xb39e80,%edx
  809c60:	b8 c0 9e b3 00       	mov    $0xb39ec0,%eax
  809c65:	be c0 b2 b3 00       	mov    $0xb3b2c0,%esi
  809c6a:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  809c6c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809c72:	89 50 0c             	mov    %edx,0xc(%eax)
  809c75:	85 d2                	test   %edx,%edx
  809c77:	74 06                	je     809c7f <sys_init+0x2a>
  809c79:	8d 58 0c             	lea    0xc(%eax),%ebx
  809c7c:	89 5a 10             	mov    %ebx,0x10(%edx)
  809c7f:	c7 41 10 80 9e b3 00 	movl   $0xb39e80,0x10(%ecx)
  809c86:	83 c0 14             	add    $0x14,%eax
  809c89:	89 ca                	mov    %ecx,%edx

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  809c8b:	39 f0                	cmp    %esi,%eax
  809c8d:	75 db                	jne    809c6a <sys_init+0x15>
  809c8f:	c7 05 80 9e b3 00 ac 	movl   $0xb3b2ac,0xb39e80
  809c96:	b2 b3 00 
  809c99:	8b 15 44 50 b3 00    	mov    0xb35044,%edx
  809c9f:	b8 80 50 b3 00       	mov    $0xb35080,%eax
  809ca4:	be 80 9e b3 00       	mov    $0xb39e80,%esi
  809ca9:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  809cab:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809cb1:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809cb7:	85 d2                	test   %edx,%edx
  809cb9:	74 0c                	je     809cc7 <sys_init+0x72>
  809cbb:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809cc1:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809cc7:	c7 81 98 00 00 00 44 	movl   $0xb35044,0x98(%ecx)
  809cce:	50 b3 00 
  809cd1:	05 9c 00 00 00       	add    $0x9c,%eax
  809cd6:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  809cd8:	39 f0                	cmp    %esi,%eax
  809cda:	75 cd                	jne    809ca9 <sys_init+0x54>
  809cdc:	c7 05 44 50 b3 00 e4 	movl   $0xb39de4,0xb35044
  809ce3:	9d b3 00 
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  809ce6:	5b                   	pop    %ebx
  809ce7:	5e                   	pop    %esi
  809ce8:	5d                   	pop    %ebp
  809ce9:	c3                   	ret    

00809cea <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  809cea:	55                   	push   %ebp
  809ceb:	89 e5                	mov    %esp,%ebp
  809ced:	53                   	push   %ebx
  809cee:	83 ec 04             	sub    $0x4,%esp
  809cf1:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809cf4:	a1 80 9e b3 00       	mov    0xb39e80,%eax
    if (!se) {
  809cf9:	85 c0                	test   %eax,%eax
  809cfb:	75 17                	jne    809d14 <sys_sem_new+0x2a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809cfd:	83 ec 0c             	sub    $0xc,%esp
  809d00:	68 e0 22 81 00       	push   $0x8122e0
  809d05:	e8 b0 47 00 00       	call   80e4ba <cprintf>
	return SYS_SEM_NULL;
  809d0a:	83 c4 10             	add    $0x10,%esp
  809d0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809d12:	eb 52                	jmp    809d66 <sys_sem_new+0x7c>
    }
    LIST_REMOVE(se, link);
  809d14:	8b 48 0c             	mov    0xc(%eax),%ecx
  809d17:	85 c9                	test   %ecx,%ecx
  809d19:	74 06                	je     809d21 <sys_sem_new+0x37>
  809d1b:	8b 58 10             	mov    0x10(%eax),%ebx
  809d1e:	89 59 10             	mov    %ebx,0x10(%ecx)
  809d21:	8b 48 10             	mov    0x10(%eax),%ecx
  809d24:	8b 58 0c             	mov    0xc(%eax),%ebx
  809d27:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809d29:	83 38 00             	cmpl   $0x0,(%eax)
  809d2c:	75 19                	jne    809d47 <sys_sem_new+0x5d>
  809d2e:	68 55 24 81 00       	push   $0x812455
  809d33:	68 5f 24 81 00       	push   $0x81245f
  809d38:	68 8d 00 00 00       	push   $0x8d
  809d3d:	68 74 24 81 00       	push   $0x812474
  809d42:	e8 9a 46 00 00       	call   80e3e1 <_panic>
    se->freed = 0;
  809d47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  809d4d:	0f b6 d2             	movzbl %dl,%edx
  809d50:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809d54:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809d58:	2d c0 9e b3 00       	sub    $0xb39ec0,%eax
  809d5d:	c1 f8 02             	sar    $0x2,%eax
  809d60:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809d66:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809d69:	c9                   	leave  
  809d6a:	c3                   	ret    

00809d6b <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  809d6b:	55                   	push   %ebp
  809d6c:	89 e5                	mov    %esp,%ebp
  809d6e:	83 ec 08             	sub    $0x8,%esp
  809d71:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809d74:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809d77:	83 3c 95 c0 9e b3 00 	cmpl   $0x0,0xb39ec0(,%edx,4)
  809d7e:	00 
  809d7f:	74 19                	je     809d9a <sys_sem_free+0x2f>
  809d81:	68 91 24 81 00       	push   $0x812491
  809d86:	68 5f 24 81 00       	push   $0x81245f
  809d8b:	68 98 00 00 00       	push   $0x98
  809d90:	68 74 24 81 00       	push   $0x812474
  809d95:	e8 47 46 00 00       	call   80e3e1 <_panic>
    sems[sem].freed = 1;
  809d9a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809d9d:	c1 e2 02             	shl    $0x2,%edx
  809da0:	8d 8a c0 9e b3 00    	lea    0xb39ec0(%edx),%ecx
  809da6:	c7 82 c0 9e b3 00 01 	movl   $0x1,0xb39ec0(%edx)
  809dad:	00 00 00 
    sems[sem].gen++;
  809db0:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809db4:	8b 15 80 9e b3 00    	mov    0xb39e80,%edx
  809dba:	89 51 0c             	mov    %edx,0xc(%ecx)
  809dbd:	85 d2                	test   %edx,%edx
  809dbf:	74 0d                	je     809dce <sys_sem_free+0x63>
  809dc1:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809dc4:	8d 0c 8d cc 9e b3 00 	lea    0xb39ecc(,%ecx,4),%ecx
  809dcb:	89 4a 10             	mov    %ecx,0x10(%edx)
  809dce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809dd5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809dd8:	8d 0c 8d c0 9e b3 00 	lea    0xb39ec0(,%ecx,4),%ecx
  809ddf:	89 0d 80 9e b3 00    	mov    %ecx,0xb39e80
  809de5:	01 d0                	add    %edx,%eax
  809de7:	c7 04 85 d0 9e b3 00 	movl   $0xb39e80,0xb39ed0(,%eax,4)
  809dee:	80 9e b3 00 
}
  809df2:	c9                   	leave  
  809df3:	c3                   	ret    

00809df4 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  809df4:	55                   	push   %ebp
  809df5:	89 e5                	mov    %esp,%ebp
  809df7:	57                   	push   %edi
  809df8:	56                   	push   %esi
  809df9:	53                   	push   %ebx
  809dfa:	83 ec 0c             	sub    $0xc,%esp
  809dfd:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809e00:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809e06:	83 b8 80 50 b3 00 00 	cmpl   $0x0,0xb35080(%eax)
  809e0d:	74 16                	je     809e25 <sys_mbox_free+0x31>
  809e0f:	68 a2 24 81 00       	push   $0x8124a2
  809e14:	68 5f 24 81 00       	push   $0x81245f
  809e19:	6a 62                	push   $0x62
  809e1b:	68 74 24 81 00       	push   $0x812474
  809e20:	e8 bc 45 00 00       	call   80e3e1 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  809e25:	83 ec 0c             	sub    $0xc,%esp
  809e28:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809e2e:	ff b6 0c 51 b3 00    	pushl  0xb3510c(%esi)
  809e34:	e8 32 ff ff ff       	call   809d6b <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809e39:	83 c4 04             	add    $0x4,%esp
  809e3c:	ff b6 10 51 b3 00    	pushl  0xb35110(%esi)
  809e42:	e8 24 ff ff ff       	call   809d6b <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809e47:	a1 44 50 b3 00       	mov    0xb35044,%eax
  809e4c:	89 86 14 51 b3 00    	mov    %eax,0xb35114(%esi)
  809e52:	83 c4 10             	add    $0x10,%esp
  809e55:	85 c0                	test   %eax,%eax
  809e57:	74 12                	je     809e6b <sys_mbox_free+0x77>
  809e59:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809e5f:	81 c2 14 51 b3 00    	add    $0xb35114,%edx
  809e65:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809e6b:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809e71:	8d 83 80 50 b3 00    	lea    0xb35080(%ebx),%eax
  809e77:	a3 44 50 b3 00       	mov    %eax,0xb35044
  809e7c:	c7 83 18 51 b3 00 44 	movl   $0xb35044,0xb35118(%ebx)
  809e83:	50 b3 00 
    mboxes[mbox].freed = 1;
  809e86:	c7 83 80 50 b3 00 01 	movl   $0x1,0xb35080(%ebx)
  809e8d:	00 00 00 
}
  809e90:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809e93:	5b                   	pop    %ebx
  809e94:	5e                   	pop    %esi
  809e95:	5f                   	pop    %edi
  809e96:	5d                   	pop    %ebp
  809e97:	c3                   	ret    

00809e98 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  809e98:	55                   	push   %ebp
  809e99:	89 e5                	mov    %esp,%ebp
  809e9b:	56                   	push   %esi
  809e9c:	53                   	push   %ebx
    assert(size < MBOXSLOTS);
  809e9d:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809ea1:	7e 16                	jle    809eb9 <sys_mbox_new+0x21>
  809ea3:	68 b6 24 81 00       	push   $0x8124b6
  809ea8:	68 5f 24 81 00       	push   $0x81245f
  809ead:	6a 45                	push   $0x45
  809eaf:	68 74 24 81 00       	push   $0x812474
  809eb4:	e8 28 45 00 00       	call   80e3e1 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809eb9:	8b 1d 44 50 b3 00    	mov    0xb35044,%ebx
    if (!mbe) {
  809ebf:	85 db                	test   %ebx,%ebx
  809ec1:	75 1a                	jne    809edd <sys_mbox_new+0x45>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  809ec3:	83 ec 0c             	sub    $0xc,%esp
  809ec6:	68 08 23 81 00       	push   $0x812308
  809ecb:	e8 ea 45 00 00       	call   80e4ba <cprintf>
	return SYS_MBOX_NULL;
  809ed0:	83 c4 10             	add    $0x10,%esp
  809ed3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ed8:	e9 b7 00 00 00       	jmp    809f94 <sys_mbox_new+0xfc>
    }
    LIST_REMOVE(mbe, link);
  809edd:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809ee3:	85 c0                	test   %eax,%eax
  809ee5:	74 0c                	je     809ef3 <sys_mbox_new+0x5b>
  809ee7:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809eed:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809ef3:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809ef9:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809eff:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809f01:	83 3b 00             	cmpl   $0x0,(%ebx)
  809f04:	75 16                	jne    809f1c <sys_mbox_new+0x84>
  809f06:	68 c7 24 81 00       	push   $0x8124c7
  809f0b:	68 5f 24 81 00       	push   $0x81245f
  809f10:	6a 4c                	push   $0x4c
  809f12:	68 74 24 81 00       	push   $0x812474
  809f17:	e8 c5 44 00 00       	call   80e3e1 <_panic>
    mbe->freed = 0;
  809f1c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  809f22:	89 d8                	mov    %ebx,%eax
  809f24:	2d 80 50 b3 00       	sub    $0xb35080,%eax
  809f29:	c1 f8 02             	sar    $0x2,%eax
  809f2c:	69 f0 97 6f f9 96    	imul   $0x96f96f97,%eax,%esi
    mbe->head = -1;
  809f32:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809f39:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809f40:	83 ec 0c             	sub    $0xc,%esp
  809f43:	6a 00                	push   $0x0
  809f45:	e8 a0 fd ff ff       	call   809cea <sys_sem_new>
  809f4a:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809f50:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809f57:	e8 8e fd ff ff       	call   809cea <sys_sem_new>
  809f5c:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  809f62:	83 c4 10             	add    $0x10,%esp
  809f65:	83 f8 ff             	cmp    $0xffffffff,%eax
  809f68:	74 09                	je     809f73 <sys_mbox_new+0xdb>
  809f6a:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809f71:	75 1f                	jne    809f92 <sys_mbox_new+0xfa>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  809f73:	83 ec 0c             	sub    $0xc,%esp
  809f76:	56                   	push   %esi
  809f77:	e8 78 fe ff ff       	call   809df4 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  809f7c:	c7 04 24 30 23 81 00 	movl   $0x812330,(%esp)
  809f83:	e8 32 45 00 00       	call   80e4ba <cprintf>
	return SYS_MBOX_NULL;
  809f88:	83 c4 10             	add    $0x10,%esp
  809f8b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f90:	eb 02                	jmp    809f94 <sys_mbox_new+0xfc>
    }
    return i;
  809f92:	89 f0                	mov    %esi,%eax
}
  809f94:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809f97:	5b                   	pop    %ebx
  809f98:	5e                   	pop    %esi
  809f99:	5d                   	pop    %ebp
  809f9a:	c3                   	ret    

00809f9b <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  809f9b:	55                   	push   %ebp
  809f9c:	89 e5                	mov    %esp,%ebp
  809f9e:	83 ec 08             	sub    $0x8,%esp
  809fa1:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809fa4:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809fa7:	83 3c 95 c0 9e b3 00 	cmpl   $0x0,0xb39ec0(,%edx,4)
  809fae:	00 
  809faf:	74 19                	je     809fca <sys_sem_signal+0x2f>
  809fb1:	68 91 24 81 00       	push   $0x812491
  809fb6:	68 5f 24 81 00       	push   $0x81245f
  809fbb:	68 a1 00 00 00       	push   $0xa1
  809fc0:	68 74 24 81 00       	push   $0x812474
  809fc5:	e8 17 44 00 00       	call   80e3e1 <_panic>
    sems[sem].counter++;
  809fca:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809fcd:	8d 14 95 c0 9e b3 00 	lea    0xb39ec0(,%edx,4),%edx
  809fd4:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  809fd9:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  809fde:	74 27                	je     80a007 <sys_sem_signal+0x6c>
	sems[sem].waiters = 0;
  809fe0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809fe7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809fea:	66 c7 04 8d ca 9e b3 	movw   $0x0,0xb39eca(,%ecx,4)
  809ff1:	00 00 00 
	thread_wakeup(&sems[sem].v);
  809ff4:	83 ec 0c             	sub    $0xc,%esp
  809ff7:	8d 04 8d c8 9e b3 00 	lea    0xb39ec8(,%ecx,4),%eax
  809ffe:	50                   	push   %eax
  809fff:	e8 b8 04 00 00       	call   80a4bc <thread_wakeup>
  80a004:	83 c4 10             	add    $0x10,%esp
    }
}
  80a007:	c9                   	leave  
  80a008:	c3                   	ret    

0080a009 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a009:	55                   	push   %ebp
  80a00a:	89 e5                	mov    %esp,%ebp
  80a00c:	57                   	push   %edi
  80a00d:	56                   	push   %esi
  80a00e:	53                   	push   %ebx
  80a00f:	83 ec 1c             	sub    $0x1c,%esp
  80a012:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a015:	8b 45 08             	mov    0x8(%ebp),%eax
  80a018:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a01b:	83 3c 85 c0 9e b3 00 	cmpl   $0x0,0xb39ec0(,%eax,4)
  80a022:	00 
  80a023:	74 19                	je     80a03e <sys_arch_sem_wait+0x35>
  80a025:	68 91 24 81 00       	push   $0x812491
  80a02a:	68 5f 24 81 00       	push   $0x81245f
  80a02f:	68 ac 00 00 00       	push   $0xac
  80a034:	68 74 24 81 00       	push   $0x812474
  80a039:	e8 a3 43 00 00       	call   80e3e1 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a03e:	8b 45 08             	mov    0x8(%ebp),%eax
  80a041:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a044:	8b 04 85 c4 9e b3 00 	mov    0xb39ec4(,%eax,4),%eax
  80a04b:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a04e:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a053:	8b 45 08             	mov    0x8(%ebp),%eax
  80a056:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a059:	89 45 e0             	mov    %eax,-0x20(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a05c:	e9 91 00 00 00       	jmp    80a0f2 <sys_arch_sem_wait+0xe9>
	if (sems[sem].counter > 0) {
  80a061:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a064:	0f b7 04 85 c8 9e b3 	movzwl 0xb39ec8(,%eax,4),%eax
  80a06b:	00 
  80a06c:	66 85 c0             	test   %ax,%ax
  80a06f:	74 18                	je     80a089 <sys_arch_sem_wait+0x80>
	    sems[sem].counter--;
  80a071:	8b 55 08             	mov    0x8(%ebp),%edx
  80a074:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a077:	83 e8 01             	sub    $0x1,%eax
  80a07a:	66 89 04 95 c8 9e b3 	mov    %ax,0xb39ec8(,%edx,4)
  80a081:	00 
	    return waited;
  80a082:	89 f8                	mov    %edi,%eax
  80a084:	e9 85 00 00 00       	jmp    80a10e <sys_arch_sem_wait+0x105>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a089:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a08c:	74 7b                	je     80a109 <sys_arch_sem_wait+0x100>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80a08e:	e8 a8 4f 00 00       	call   80f03b <sys_time_msec>
  80a093:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a096:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a09b:	85 f6                	test   %esi,%esi
  80a09d:	74 07                	je     80a0a6 <sys_arch_sem_wait+0x9d>
  80a09f:	89 f0                	mov    %esi,%eax
  80a0a1:	29 f8                	sub    %edi,%eax
  80a0a3:	03 45 e4             	add    -0x1c(%ebp),%eax
	    sems[sem].waiters = 1;
  80a0a6:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80a0a9:	8d 1c 8d c0 9e b3 00 	lea    0xb39ec0(,%ecx,4),%ebx
  80a0b0:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a0b6:	83 ec 04             	sub    $0x4,%esp
  80a0b9:	50                   	push   %eax
  80a0ba:	ff 73 08             	pushl  0x8(%ebx)
  80a0bd:	8d 43 08             	lea    0x8(%ebx),%eax
  80a0c0:	50                   	push   %eax
  80a0c1:	e8 0d 06 00 00       	call   80a6d3 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80a0c6:	83 c4 10             	add    $0x10,%esp
  80a0c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a0cc:	39 43 04             	cmp    %eax,0x4(%ebx)
  80a0cf:	74 17                	je     80a0e8 <sys_arch_sem_wait+0xdf>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a0d1:	83 ec 0c             	sub    $0xc,%esp
  80a0d4:	68 5c 23 81 00       	push   $0x81235c
  80a0d9:	e8 dc 43 00 00       	call   80e4ba <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a0de:	83 c4 10             	add    $0x10,%esp
  80a0e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a0e6:	eb 26                	jmp    80a10e <sys_arch_sem_wait+0x105>
	    }
	    uint32_t b = sys_time_msec();
  80a0e8:	e8 4e 4f 00 00       	call   80f03b <sys_time_msec>
	    waited += (b - a);
  80a0ed:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80a0f0:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a0f2:	39 f7                	cmp    %esi,%edi
  80a0f4:	0f 82 67 ff ff ff    	jb     80a061 <sys_arch_sem_wait+0x58>
  80a0fa:	85 f6                	test   %esi,%esi
  80a0fc:	0f 84 5f ff ff ff    	je     80a061 <sys_arch_sem_wait+0x58>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80a102:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a107:	eb 05                	jmp    80a10e <sys_arch_sem_wait+0x105>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80a109:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80a10e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a111:	5b                   	pop    %ebx
  80a112:	5e                   	pop    %esi
  80a113:	5f                   	pop    %edi
  80a114:	5d                   	pop    %ebp
  80a115:	c3                   	ret    

0080a116 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80a116:	55                   	push   %ebp
  80a117:	89 e5                	mov    %esp,%ebp
  80a119:	57                   	push   %edi
  80a11a:	56                   	push   %esi
  80a11b:	53                   	push   %ebx
  80a11c:	83 ec 0c             	sub    $0xc,%esp
  80a11f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a122:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a128:	83 b8 80 50 b3 00 00 	cmpl   $0x0,0xb35080(%eax)
  80a12f:	74 16                	je     80a147 <sys_mbox_trypost+0x31>
  80a131:	68 a2 24 81 00       	push   $0x8124a2
  80a136:	68 5f 24 81 00       	push   $0x81245f
  80a13b:	6a 72                	push   $0x72
  80a13d:	68 74 24 81 00       	push   $0x812474
  80a142:	e8 9a 42 00 00       	call   80e3e1 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a147:	83 ec 08             	sub    $0x8,%esp
  80a14a:	6a 00                	push   $0x0
  80a14c:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a152:	ff b6 10 51 b3 00    	pushl  0xb35110(%esi)
  80a158:	e8 ac fe ff ff       	call   80a009 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a15d:	8b 96 88 50 b3 00    	mov    0xb35088(%esi),%edx
  80a163:	8b 8e 84 50 b3 00    	mov    0xb35084(%esi),%ecx
  80a169:	83 c4 10             	add    $0x10,%esp
  80a16c:	39 ca                	cmp    %ecx,%edx
  80a16e:	74 5c                	je     80a1cc <sys_mbox_trypost+0xb6>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a170:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a176:	8d 42 01             	lea    0x1(%edx),%eax
  80a179:	89 c7                	mov    %eax,%edi
  80a17b:	c1 ff 1f             	sar    $0x1f,%edi
  80a17e:	c1 ef 1b             	shr    $0x1b,%edi
  80a181:	01 f8                	add    %edi,%eax
  80a183:	83 e0 1f             	and    $0x1f,%eax
  80a186:	29 f8                	sub    %edi,%eax
  80a188:	89 86 88 50 b3 00    	mov    %eax,0xb35088(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a18e:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a191:	01 d0                	add    %edx,%eax
  80a193:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a196:	89 34 85 8c 50 b3 00 	mov    %esi,0xb3508c(,%eax,4)

    if (mboxes[mbox].head == -1)
  80a19d:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a1a0:	75 0c                	jne    80a1ae <sys_mbox_trypost+0x98>
	mboxes[mbox].head = slot;
  80a1a2:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1a8:	89 90 84 50 b3 00    	mov    %edx,0xb35084(%eax)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80a1ae:	83 ec 0c             	sub    $0xc,%esp
  80a1b1:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a1b7:	ff b3 0c 51 b3 00    	pushl  0xb3510c(%ebx)
  80a1bd:	e8 d9 fd ff ff       	call   809f9b <sys_sem_signal>

    return ERR_OK;
  80a1c2:	83 c4 10             	add    $0x10,%esp
  80a1c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a1ca:	eb 05                	jmp    80a1d1 <sys_mbox_trypost+0xbb>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80a1cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80a1d1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a1d4:	5b                   	pop    %ebx
  80a1d5:	5e                   	pop    %esi
  80a1d6:	5f                   	pop    %edi
  80a1d7:	5d                   	pop    %ebp
  80a1d8:	c3                   	ret    

0080a1d9 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80a1d9:	55                   	push   %ebp
  80a1da:	89 e5                	mov    %esp,%ebp
  80a1dc:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a1df:	ff 75 0c             	pushl  0xc(%ebp)
  80a1e2:	ff 75 08             	pushl  0x8(%ebp)
  80a1e5:	e8 2c ff ff ff       	call   80a116 <sys_mbox_trypost>
  80a1ea:	83 c4 10             	add    $0x10,%esp
  80a1ed:	84 c0                	test   %al,%al
  80a1ef:	74 16                	je     80a207 <sys_mbox_post+0x2e>
  80a1f1:	68 88 23 81 00       	push   $0x812388
  80a1f6:	68 5f 24 81 00       	push   $0x81245f
  80a1fb:	6a 6c                	push   $0x6c
  80a1fd:	68 74 24 81 00       	push   $0x812474
  80a202:	e8 da 41 00 00       	call   80e3e1 <_panic>
}
  80a207:	c9                   	leave  
  80a208:	c3                   	ret    

0080a209 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80a209:	55                   	push   %ebp
  80a20a:	89 e5                	mov    %esp,%ebp
  80a20c:	57                   	push   %edi
  80a20d:	56                   	push   %esi
  80a20e:	53                   	push   %ebx
  80a20f:	83 ec 0c             	sub    $0xc,%esp
  80a212:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a215:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a218:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a21e:	83 b8 80 50 b3 00 00 	cmpl   $0x0,0xb35080(%eax)
  80a225:	74 19                	je     80a240 <sys_arch_mbox_fetch+0x37>
  80a227:	68 a2 24 81 00       	push   $0x8124a2
  80a22c:	68 5f 24 81 00       	push   $0x81245f
  80a231:	68 ce 00 00 00       	push   $0xce
  80a236:	68 74 24 81 00       	push   $0x812474
  80a23b:	e8 a1 41 00 00       	call   80e3e1 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a240:	83 ec 08             	sub    $0x8,%esp
  80a243:	ff 75 10             	pushl  0x10(%ebp)
  80a246:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a24c:	ff b0 0c 51 b3 00    	pushl  0xb3510c(%eax)
  80a252:	e8 b2 fd ff ff       	call   80a009 <sys_arch_sem_wait>
  80a257:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a259:	83 c4 10             	add    $0x10,%esp
  80a25c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a25f:	0f 84 86 00 00 00    	je     80a2eb <sys_arch_mbox_fetch+0xe2>
	return waited;

    int slot = mboxes[mbox].head;
  80a265:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a26b:	8b 80 84 50 b3 00    	mov    0xb35084(%eax),%eax
    if (slot == -1)
  80a271:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a274:	75 17                	jne    80a28d <sys_arch_mbox_fetch+0x84>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a276:	83 ec 04             	sub    $0x4,%esp
  80a279:	68 b0 23 81 00       	push   $0x8123b0
  80a27e:	68 d6 00 00 00       	push   $0xd6
  80a283:	68 74 24 81 00       	push   $0x812474
  80a288:	e8 54 41 00 00       	call   80e3e1 <_panic>
    if (msg)
  80a28d:	85 ff                	test   %edi,%edi
  80a28f:	74 0e                	je     80a29f <sys_arch_mbox_fetch+0x96>
	*msg = mboxes[mbox].msg[slot];
  80a291:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a294:	01 c2                	add    %eax,%edx
  80a296:	8b 14 95 8c 50 b3 00 	mov    0xb3508c(,%edx,4),%edx
  80a29d:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a29f:	83 c0 01             	add    $0x1,%eax
  80a2a2:	99                   	cltd   
  80a2a3:	c1 ea 1b             	shr    $0x1b,%edx
  80a2a6:	01 d0                	add    %edx,%eax
  80a2a8:	83 e0 1f             	and    $0x1f,%eax
  80a2ab:	29 d0                	sub    %edx,%eax
  80a2ad:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a2b3:	89 82 84 50 b3 00    	mov    %eax,0xb35084(%edx)
  80a2b9:	81 c2 80 50 b3 00    	add    $0xb35080,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a2bf:	3b 42 08             	cmp    0x8(%edx),%eax
  80a2c2:	75 10                	jne    80a2d4 <sys_arch_mbox_fetch+0xcb>
	mboxes[mbox].head = -1;
  80a2c4:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2ca:	c7 80 84 50 b3 00 ff 	movl   $0xffffffff,0xb35084(%eax)
  80a2d1:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80a2d4:	83 ec 0c             	sub    $0xc,%esp
  80a2d7:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a2dd:	ff b3 10 51 b3 00    	pushl  0xb35110(%ebx)
  80a2e3:	e8 b3 fc ff ff       	call   809f9b <sys_sem_signal>
    return waited;
  80a2e8:	83 c4 10             	add    $0x10,%esp
}
  80a2eb:	89 f0                	mov    %esi,%eax
  80a2ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a2f0:	5b                   	pop    %ebx
  80a2f1:	5e                   	pop    %esi
  80a2f2:	5f                   	pop    %edi
  80a2f3:	5d                   	pop    %ebp
  80a2f4:	c3                   	ret    

0080a2f5 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80a2f5:	55                   	push   %ebp
  80a2f6:	89 e5                	mov    %esp,%ebp
  80a2f8:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a2fb:	6a fe                	push   $0xfffffffe
  80a2fd:	ff 75 0c             	pushl  0xc(%ebp)
  80a300:	ff 75 08             	pushl  0x8(%ebp)
  80a303:	e8 01 ff ff ff       	call   80a209 <sys_arch_mbox_fetch>
}
  80a308:	c9                   	leave  
  80a309:	c3                   	ret    

0080a30a <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80a30a:	55                   	push   %ebp
  80a30b:	89 e5                	mov    %esp,%ebp
  80a30d:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a310:	6a 08                	push   $0x8
  80a312:	e8 13 5f 00 00       	call   81022a <malloc>
    if (lt == 0)
  80a317:	83 c4 10             	add    $0x10,%esp
  80a31a:	85 c0                	test   %eax,%eax
  80a31c:	75 17                	jne    80a335 <sys_thread_new+0x2b>
	panic("sys_thread_new: cannot allocate thread struct");
  80a31e:	83 ec 04             	sub    $0x4,%esp
  80a321:	68 d8 23 81 00       	push   $0x8123d8
  80a326:	68 fd 00 00 00       	push   $0xfd
  80a32b:	68 74 24 81 00       	push   $0x812474
  80a330:	e8 ac 40 00 00       	call   80e3e1 <_panic>

    if (stacksize > PGSIZE)
  80a335:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a33c:	7e 17                	jle    80a355 <sys_thread_new+0x4b>
	panic("large stack %d", stacksize);
  80a33e:	ff 75 14             	pushl  0x14(%ebp)
  80a341:	68 d2 24 81 00       	push   $0x8124d2
  80a346:	68 00 01 00 00       	push   $0x100
  80a34b:	68 74 24 81 00       	push   $0x812474
  80a350:	e8 8c 40 00 00       	call   80e3e1 <_panic>

    lt->func = thread;
  80a355:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a358:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a35a:	8b 55 10             	mov    0x10(%ebp),%edx
  80a35d:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a360:	50                   	push   %eax
  80a361:	68 dd 9b 80 00       	push   $0x809bdd
  80a366:	ff 75 08             	pushl  0x8(%ebp)
  80a369:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a36c:	50                   	push   %eax
  80a36d:	e8 b8 01 00 00       	call   80a52a <thread_create>

    if (r < 0)
  80a372:	83 c4 10             	add    $0x10,%esp
  80a375:	85 c0                	test   %eax,%eax
  80a377:	79 1e                	jns    80a397 <sys_thread_new+0x8d>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a379:	83 ec 0c             	sub    $0xc,%esp
  80a37c:	50                   	push   %eax
  80a37d:	e8 d7 04 00 00       	call   80a859 <e2s>
  80a382:	50                   	push   %eax
  80a383:	68 08 24 81 00       	push   $0x812408
  80a388:	68 09 01 00 00       	push   $0x109
  80a38d:	68 74 24 81 00       	push   $0x812474
  80a392:	e8 4a 40 00 00       	call   80e3e1 <_panic>

    return tid;
}
  80a397:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a39a:	c9                   	leave  
  80a39b:	c3                   	ret    

0080a39c <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a39c:	55                   	push   %ebp
  80a39d:	89 e5                	mov    %esp,%ebp
  80a39f:	57                   	push   %edi
  80a3a0:	56                   	push   %esi
  80a3a1:	53                   	push   %ebx
  80a3a2:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a3a5:	e8 06 01 00 00       	call   80a4b0 <thread_id>
  80a3aa:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a3ac:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a3b1:	f7 e2                	mul    %edx
  80a3b3:	c1 ea 08             	shr    $0x8,%edx
  80a3b6:	89 d7                	mov    %edx,%edi
  80a3b8:	c1 e2 08             	shl    $0x8,%edx
  80a3bb:	01 d7                	add    %edx,%edi
  80a3bd:	89 f0                	mov    %esi,%eax
  80a3bf:	29 f8                	sub    %edi,%eax
  80a3c1:	89 c7                	mov    %eax,%edi
  80a3c3:	8b 1c 85 40 4c b3 00 	mov    0xb34c40(,%eax,4),%ebx
  80a3ca:	eb 0b                	jmp    80a3d7 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a3cc:	39 33                	cmp    %esi,(%ebx)
  80a3ce:	0f 84 a4 00 00 00    	je     80a478 <sys_arch_timeouts+0xdc>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a3d4:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a3d7:	85 db                	test   %ebx,%ebx
  80a3d9:	75 f1                	jne    80a3cc <sys_arch_timeouts+0x30>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80a3db:	83 ec 0c             	sub    $0xc,%esp
  80a3de:	6a 10                	push   $0x10
  80a3e0:	e8 45 5e 00 00       	call   81022a <malloc>
  80a3e5:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a3e7:	83 c4 10             	add    $0x10,%esp
  80a3ea:	85 c0                	test   %eax,%eax
  80a3ec:	75 17                	jne    80a405 <sys_arch_timeouts+0x69>
	panic("sys_arch_timeouts: cannot malloc");
  80a3ee:	83 ec 04             	sub    $0x4,%esp
  80a3f1:	68 34 24 81 00       	push   $0x812434
  80a3f6:	68 2c 01 00 00       	push   $0x12c
  80a3fb:	68 74 24 81 00       	push   $0x812474
  80a400:	e8 dc 3f 00 00       	call   80e3e1 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80a405:	83 ec 0c             	sub    $0xc,%esp
  80a408:	68 fc 9b 80 00       	push   $0x809bfc
  80a40d:	e8 ec 00 00 00       	call   80a4fe <thread_onhalt>
    if (r < 0)
  80a412:	83 c4 10             	add    $0x10,%esp
  80a415:	85 c0                	test   %eax,%eax
  80a417:	79 1e                	jns    80a437 <sys_arch_timeouts+0x9b>
	panic("thread_onhalt failed: %s", e2s(r));
  80a419:	83 ec 0c             	sub    $0xc,%esp
  80a41c:	50                   	push   %eax
  80a41d:	e8 37 04 00 00       	call   80a859 <e2s>
  80a422:	50                   	push   %eax
  80a423:	68 e1 24 81 00       	push   $0x8124e1
  80a428:	68 30 01 00 00       	push   $0x130
  80a42d:	68 74 24 81 00       	push   $0x812474
  80a432:	e8 aa 3f 00 00       	call   80e3e1 <_panic>

    t->tid = tid;
  80a437:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a439:	83 ec 04             	sub    $0x4,%esp
  80a43c:	6a 04                	push   $0x4
  80a43e:	6a 00                	push   $0x0
  80a440:	8d 43 04             	lea    0x4(%ebx),%eax
  80a443:	50                   	push   %eax
  80a444:	e8 3d 47 00 00       	call   80eb86 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a449:	8b 04 bd 40 4c b3 00 	mov    0xb34c40(,%edi,4),%eax
  80a450:	89 43 08             	mov    %eax,0x8(%ebx)
  80a453:	83 c4 10             	add    $0x10,%esp
  80a456:	85 c0                	test   %eax,%eax
  80a458:	74 0d                	je     80a467 <sys_arch_timeouts+0xcb>
  80a45a:	8b 04 bd 40 4c b3 00 	mov    0xb34c40(,%edi,4),%eax
  80a461:	8d 53 08             	lea    0x8(%ebx),%edx
  80a464:	89 50 0c             	mov    %edx,0xc(%eax)
  80a467:	89 1c bd 40 4c b3 00 	mov    %ebx,0xb34c40(,%edi,4)
  80a46e:	8d 04 bd 40 4c b3 00 	lea    0xb34c40(,%edi,4),%eax
  80a475:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a478:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a47b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a47e:	5b                   	pop    %ebx
  80a47f:	5e                   	pop    %esi
  80a480:	5f                   	pop    %edi
  80a481:	5d                   	pop    %ebp
  80a482:	c3                   	ret    

0080a483 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a483:	55                   	push   %ebp
  80a484:	89 e5                	mov    %esp,%ebp
}
  80a486:	5d                   	pop    %ebp
  80a487:	c3                   	ret    

0080a488 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a488:	55                   	push   %ebp
  80a489:	89 e5                	mov    %esp,%ebp
}
  80a48b:	5d                   	pop    %ebp
  80a48c:	c3                   	ret    

0080a48d <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a48d:	55                   	push   %ebp
  80a48e:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a490:	c7 05 c8 b2 b3 00 00 	movl   $0x0,0xb3b2c8
  80a497:	00 00 00 
    tq->tq_last = 0;
  80a49a:	c7 05 cc b2 b3 00 00 	movl   $0x0,0xb3b2cc
  80a4a1:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a4a4:	c7 05 d4 b2 b3 00 00 	movl   $0x0,0xb3b2d4
  80a4ab:	00 00 00 
}
  80a4ae:	5d                   	pop    %ebp
  80a4af:	c3                   	ret    

0080a4b0 <thread_id>:

uint32_t
thread_id(void) {
  80a4b0:	55                   	push   %ebp
  80a4b1:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80a4b3:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
  80a4b8:	8b 00                	mov    (%eax),%eax
}
  80a4ba:	5d                   	pop    %ebp
  80a4bb:	c3                   	ret    

0080a4bc <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a4bc:	55                   	push   %ebp
  80a4bd:	89 e5                	mov    %esp,%ebp
  80a4bf:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a4c2:	a1 c8 b2 b3 00       	mov    0xb3b2c8,%eax
    while (tc) {
  80a4c7:	eb 0c                	jmp    80a4d5 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80a4c9:	39 50 48             	cmp    %edx,0x48(%eax)
  80a4cc:	75 04                	jne    80a4d2 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80a4ce:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a4d2:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80a4d5:	85 c0                	test   %eax,%eax
  80a4d7:	75 f0                	jne    80a4c9 <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80a4d9:	5d                   	pop    %ebp
  80a4da:	c3                   	ret    

0080a4db <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a4db:	55                   	push   %ebp
  80a4dc:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80a4de:	8b 15 c8 b2 b3 00    	mov    0xb3b2c8,%edx
    int n = 0;
  80a4e4:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a4e9:	eb 0d                	jmp    80a4f8 <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80a4eb:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a4ef:	80 f9 01             	cmp    $0x1,%cl
  80a4f2:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a4f5:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80a4f8:	85 d2                	test   %edx,%edx
  80a4fa:	75 ef                	jne    80a4eb <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80a4fc:	5d                   	pop    %ebp
  80a4fd:	c3                   	ret    

0080a4fe <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a4fe:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
  80a503:	8b 50 60             	mov    0x60(%eax),%edx
  80a506:	83 fa 03             	cmp    $0x3,%edx
  80a509:	7f 17                	jg     80a522 <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a50b:	55                   	push   %ebp
  80a50c:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a50e:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a511:	89 48 60             	mov    %ecx,0x60(%eax)
  80a514:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a517:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a51b:	b8 00 00 00 00       	mov    $0x0,%eax
  80a520:	eb 06                	jmp    80a528 <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80a522:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a527:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80a528:	5d                   	pop    %ebp
  80a529:	c3                   	ret    

0080a52a <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a52a:	55                   	push   %ebp
  80a52b:	89 e5                	mov    %esp,%ebp
  80a52d:	57                   	push   %edi
  80a52e:	56                   	push   %esi
  80a52f:	53                   	push   %ebx
  80a530:	83 ec 18             	sub    $0x18,%esp
  80a533:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a536:	6a 68                	push   $0x68
  80a538:	e8 ed 5c 00 00       	call   81022a <malloc>
  80a53d:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80a53f:	83 c4 10             	add    $0x10,%esp
  80a542:	85 c0                	test   %eax,%eax
  80a544:	0f 84 f2 00 00 00    	je     80a63c <thread_create+0x112>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a54a:	83 ec 04             	sub    $0x4,%esp
  80a54d:	6a 68                	push   $0x68
  80a54f:	6a 00                	push   $0x0
  80a551:	50                   	push   %eax
  80a552:	e8 2f 46 00 00       	call   80eb86 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80a557:	83 c4 0c             	add    $0xc,%esp
  80a55a:	6a 1f                	push   $0x1f
  80a55c:	ff 75 0c             	pushl  0xc(%ebp)
  80a55f:	8d 43 08             	lea    0x8(%ebx),%eax
  80a562:	50                   	push   %eax
  80a563:	e8 1b 45 00 00       	call   80ea83 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a568:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80a56c:	8b 15 d4 b2 b3 00    	mov    0xb3b2d4,%edx
  80a572:	8d 42 01             	lea    0x1(%edx),%eax
  80a575:	a3 d4 b2 b3 00       	mov    %eax,0xb3b2d4
    if (max_tid == (uint32_t)~0)
  80a57a:	83 c4 10             	add    $0x10,%esp
  80a57d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a580:	75 14                	jne    80a596 <thread_create+0x6c>
	panic("alloc_tid: no more thread ids");
  80a582:	83 ec 04             	sub    $0x4,%esp
  80a585:	68 fa 24 81 00       	push   $0x8124fa
  80a58a:	6a 54                	push   $0x54
  80a58c:	68 18 25 81 00       	push   $0x812518
  80a591:	e8 4b 3e 00 00       	call   80e3e1 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a596:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a598:	83 ec 0c             	sub    $0xc,%esp
  80a59b:	68 00 10 00 00       	push   $0x1000
  80a5a0:	e8 85 5c 00 00       	call   81022a <malloc>
  80a5a5:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a5a8:	83 c4 10             	add    $0x10,%esp
  80a5ab:	85 c0                	test   %eax,%eax
  80a5ad:	75 16                	jne    80a5c5 <thread_create+0x9b>
	free(tc);
  80a5af:	83 ec 0c             	sub    $0xc,%esp
  80a5b2:	53                   	push   %ebx
  80a5b3:	e8 c4 5b 00 00       	call   81017c <free>
	return -E_NO_MEM;
  80a5b8:	83 c4 10             	add    $0x10,%esp
  80a5bb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a5c0:	e9 83 00 00 00       	jmp    80a648 <thread_create+0x11e>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a5c5:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a5cb:	83 ec 04             	sub    $0x4,%esp
  80a5ce:	6a 04                	push   $0x4
  80a5d0:	6a 00                	push   $0x0
  80a5d2:	57                   	push   %edi
  80a5d3:	e8 ae 45 00 00       	call   80eb86 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a5d8:	83 c4 0c             	add    $0xc,%esp
  80a5db:	6a 18                	push   $0x18
  80a5dd:	6a 00                	push   $0x0
  80a5df:	8d 43 30             	lea    0x30(%ebx),%eax
  80a5e2:	50                   	push   %eax
  80a5e3:	e8 9e 45 00 00       	call   80eb86 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a5e8:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a5eb:	c7 43 30 d4 a7 80 00 	movl   $0x80a7d4,0x30(%ebx)
    tc->tc_entry = entry;
  80a5f2:	8b 45 10             	mov    0x10(%ebp),%eax
  80a5f5:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a5f8:	8b 45 14             	mov    0x14(%ebp),%eax
  80a5fb:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a5fe:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a605:	83 c4 10             	add    $0x10,%esp
  80a608:	83 3d c8 b2 b3 00 00 	cmpl   $0x0,0xb3b2c8
  80a60f:	75 0e                	jne    80a61f <thread_create+0xf5>
	tq->tq_first = tc;
  80a611:	89 1d c8 b2 b3 00    	mov    %ebx,0xb3b2c8
	tq->tq_last = tc;
  80a617:	89 1d cc b2 b3 00    	mov    %ebx,0xb3b2cc
  80a61d:	eb 0e                	jmp    80a62d <thread_create+0x103>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a61f:	a1 cc b2 b3 00       	mov    0xb3b2cc,%eax
  80a624:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a627:	89 1d cc b2 b3 00    	mov    %ebx,0xb3b2cc

    threadq_push(&thread_queue, tc);

    if (tid)
  80a62d:	85 f6                	test   %esi,%esi
  80a62f:	74 12                	je     80a643 <thread_create+0x119>
	*tid = tc->tc_tid;
  80a631:	8b 03                	mov    (%ebx),%eax
  80a633:	89 06                	mov    %eax,(%esi)
    return 0;
  80a635:	b8 00 00 00 00       	mov    $0x0,%eax
  80a63a:	eb 0c                	jmp    80a648 <thread_create+0x11e>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80a63c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a641:	eb 05                	jmp    80a648 <thread_create+0x11e>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a643:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a648:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a64b:	5b                   	pop    %ebx
  80a64c:	5e                   	pop    %esi
  80a64d:	5f                   	pop    %edi
  80a64e:	5d                   	pop    %ebp
  80a64f:	c3                   	ret    

0080a650 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a650:	55                   	push   %ebp
  80a651:	89 e5                	mov    %esp,%ebp
  80a653:	53                   	push   %ebx
  80a654:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a657:	8b 1d c8 b2 b3 00    	mov    0xb3b2c8,%ebx
  80a65d:	85 db                	test   %ebx,%ebx
  80a65f:	74 6d                	je     80a6ce <thread_yield+0x7e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a661:	8b 43 64             	mov    0x64(%ebx),%eax
  80a664:	a3 c8 b2 b3 00       	mov    %eax,0xb3b2c8
    tc->tc_queue_link = 0;
  80a669:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a670:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
  80a675:	85 c0                	test   %eax,%eax
  80a677:	74 42                	je     80a6bb <thread_yield+0x6b>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a679:	83 ec 0c             	sub    $0xc,%esp
  80a67c:	83 c0 30             	add    $0x30,%eax
  80a67f:	50                   	push   %eax
  80a680:	e8 6b 01 00 00       	call   80a7f0 <jos_setjmp>
  80a685:	83 c4 10             	add    $0x10,%esp
  80a688:	85 c0                	test   %eax,%eax
  80a68a:	75 42                	jne    80a6ce <thread_yield+0x7e>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80a68c:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a691:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a698:	83 3d c8 b2 b3 00 00 	cmpl   $0x0,0xb3b2c8
  80a69f:	75 0c                	jne    80a6ad <thread_yield+0x5d>
	tq->tq_first = tc;
  80a6a1:	a3 c8 b2 b3 00       	mov    %eax,0xb3b2c8
	tq->tq_last = tc;
  80a6a6:	a3 cc b2 b3 00       	mov    %eax,0xb3b2cc
  80a6ab:	eb 0e                	jmp    80a6bb <thread_yield+0x6b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a6ad:	8b 15 cc b2 b3 00    	mov    0xb3b2cc,%edx
  80a6b3:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a6b6:	a3 cc b2 b3 00       	mov    %eax,0xb3b2cc
    }

    cur_tc = next_tc;
  80a6bb:	89 1d d0 b2 b3 00    	mov    %ebx,0xb3b2d0
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a6c1:	8d 43 30             	lea    0x30(%ebx),%eax
  80a6c4:	ba 01 00 00 00       	mov    $0x1,%edx
  80a6c9:	e8 52 01 00 00       	call   80a820 <jos_longjmp>
}
  80a6ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a6d1:	c9                   	leave  
  80a6d2:	c3                   	ret    

0080a6d3 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a6d3:	55                   	push   %ebp
  80a6d4:	89 e5                	mov    %esp,%ebp
  80a6d6:	57                   	push   %edi
  80a6d7:	56                   	push   %esi
  80a6d8:	53                   	push   %ebx
  80a6d9:	83 ec 0c             	sub    $0xc,%esp
  80a6dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a6df:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a6e2:	e8 54 49 00 00       	call   80f03b <sys_time_msec>
  80a6e7:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80a6e9:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
  80a6ee:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a6f1:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80a6f5:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80a6f7:	eb 22                	jmp    80a71b <thread_wait+0x48>
	if (p < s)
	    break;
	if (addr && *addr != val)
  80a6f9:	85 db                	test   %ebx,%ebx
  80a6fb:	74 07                	je     80a704 <thread_wait+0x31>
  80a6fd:	8b 03                	mov    (%ebx),%eax
  80a6ff:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a702:	75 1f                	jne    80a723 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80a704:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
  80a709:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a70d:	84 c0                	test   %al,%al
  80a70f:	75 12                	jne    80a723 <thread_wait+0x50>
	    break;

	thread_yield();
  80a711:	e8 3a ff ff ff       	call   80a650 <thread_yield>
	p = sys_time_msec();
  80a716:	e8 20 49 00 00       	call   80f03b <sys_time_msec>

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
	if (p < s)
  80a71b:	39 f8                	cmp    %edi,%eax
  80a71d:	73 04                	jae    80a723 <thread_wait+0x50>
  80a71f:	39 f0                	cmp    %esi,%eax
  80a721:	73 d6                	jae    80a6f9 <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80a723:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
  80a728:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a72f:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a733:	83 c4 0c             	add    $0xc,%esp
  80a736:	5b                   	pop    %ebx
  80a737:	5e                   	pop    %esi
  80a738:	5f                   	pop    %edi
  80a739:	5d                   	pop    %ebp
  80a73a:	c3                   	ret    

0080a73b <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80a73b:	55                   	push   %ebp
  80a73c:	89 e5                	mov    %esp,%ebp
  80a73e:	56                   	push   %esi
  80a73f:	53                   	push   %ebx
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a740:	8b 1d c0 b2 b3 00    	mov    0xb3b2c0,%ebx
  80a746:	85 db                	test   %ebx,%ebx
  80a748:	74 40                	je     80a78a <thread_halt+0x4f>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a74a:	8b 43 64             	mov    0x64(%ebx),%eax
  80a74d:	a3 c0 b2 b3 00       	mov    %eax,0xb3b2c0
    tc->tc_queue_link = 0;
  80a752:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80a759:	be 00 00 00 00       	mov    $0x0,%esi
  80a75e:	eb 0f                	jmp    80a76f <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80a760:	83 ec 0c             	sub    $0xc,%esp
  80a763:	ff 33                	pushl  (%ebx)
  80a765:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a769:	83 c6 01             	add    $0x1,%esi
  80a76c:	83 c4 10             	add    $0x10,%esp
  80a76f:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a772:	7c ec                	jl     80a760 <thread_halt+0x25>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80a774:	83 ec 0c             	sub    $0xc,%esp
  80a777:	ff 73 04             	pushl  0x4(%ebx)
  80a77a:	e8 fd 59 00 00       	call   81017c <free>
    free(tc);
  80a77f:	89 1c 24             	mov    %ebx,(%esp)
  80a782:	e8 f5 59 00 00       	call   81017c <free>
  80a787:	83 c4 10             	add    $0x10,%esp
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80a78a:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a78f:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a796:	83 3d c0 b2 b3 00 00 	cmpl   $0x0,0xb3b2c0
  80a79d:	75 0c                	jne    80a7ab <thread_halt+0x70>
	tq->tq_first = tc;
  80a79f:	a3 c0 b2 b3 00       	mov    %eax,0xb3b2c0
	tq->tq_last = tc;
  80a7a4:	a3 c4 b2 b3 00       	mov    %eax,0xb3b2c4
  80a7a9:	eb 0e                	jmp    80a7b9 <thread_halt+0x7e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a7ab:	8b 15 c4 b2 b3 00    	mov    0xb3b2c4,%edx
  80a7b1:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a7b4:	a3 c4 b2 b3 00       	mov    %eax,0xb3b2c4
    cur_tc = NULL;
  80a7b9:	c7 05 d0 b2 b3 00 00 	movl   $0x0,0xb3b2d0
  80a7c0:	00 00 00 
    thread_yield();
  80a7c3:	e8 88 fe ff ff       	call   80a650 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80a7c8:	e8 fa 3b 00 00       	call   80e3c7 <exit>
}
  80a7cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a7d0:	5b                   	pop    %ebx
  80a7d1:	5e                   	pop    %esi
  80a7d2:	5d                   	pop    %ebp
  80a7d3:	c3                   	ret    

0080a7d4 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80a7d4:	55                   	push   %ebp
  80a7d5:	89 e5                	mov    %esp,%ebp
  80a7d7:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a7da:	a1 d0 b2 b3 00       	mov    0xb3b2d0,%eax
  80a7df:	ff 70 2c             	pushl  0x2c(%eax)
  80a7e2:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a7e5:	e8 51 ff ff ff       	call   80a73b <thread_halt>
  80a7ea:	83 c4 10             	add    $0x10,%esp
}
  80a7ed:	c9                   	leave  
  80a7ee:	c3                   	ret    
  80a7ef:	90                   	nop

0080a7f0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a7f0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a7f4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a7f7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a7f9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a7fd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a800:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a803:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a806:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a809:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a80c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a811:	c3                   	ret    
  80a812:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a819:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080a820 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a820:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a822:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a825:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a828:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a82b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a82e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a831:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a833:	ff e1                	jmp    *%ecx

0080a835 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a835:	55                   	push   %ebp
  80a836:	89 e5                	mov    %esp,%ebp
  80a838:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a83b:	a1 20 b3 b3 00       	mov    0xb3b320,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80a840:	ff 34 85 40 40 81 00 	pushl  0x814040(,%eax,4)
  80a847:	ff 75 08             	pushl  0x8(%ebp)
  80a84a:	68 33 25 81 00       	push   $0x812533
  80a84f:	e8 66 3c 00 00       	call   80e4ba <cprintf>
  80a854:	83 c4 10             	add    $0x10,%esp
}
  80a857:	c9                   	leave  
  80a858:	c3                   	ret    

0080a859 <e2s>:

const char *
e2s(int err) {
  80a859:	55                   	push   %ebp
  80a85a:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a85c:	8b 45 08             	mov    0x8(%ebp),%eax
  80a85f:	8b 04 85 40 40 81 00 	mov    0x814040(,%eax,4),%eax
}
  80a866:	5d                   	pop    %ebp
  80a867:	c3                   	ret    

0080a868 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a868:	55                   	push   %ebp
  80a869:	89 e5                	mov    %esp,%ebp
  80a86b:	57                   	push   %edi
  80a86c:	56                   	push   %esi
  80a86d:	53                   	push   %ebx
  80a86e:	83 ec 20             	sub    $0x20,%esp
  80a871:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a874:	6a 07                	push   $0x7
  80a876:	68 00 00 00 10       	push   $0x10000000
  80a87b:	6a 00                	push   $0x0
  80a87d:	e8 c8 45 00 00       	call   80ee4a <sys_page_alloc>
    if (r < 0)
  80a882:	83 c4 10             	add    $0x10,%esp
  80a885:	85 c0                	test   %eax,%eax
  80a887:	79 14                	jns    80a89d <low_level_output+0x35>
	panic("jif: could not allocate page of memory");
  80a889:	83 ec 04             	sub    $0x4,%esp
  80a88c:	68 18 2a 81 00       	push   $0x812a18
  80a891:	6a 55                	push   $0x55
  80a893:	68 69 2a 81 00       	push   $0x812a69
  80a898:	e8 44 3b 00 00       	call   80e3e1 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a89d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a8a0:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a8a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a8a6:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a8ab:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a8b0:	eb 46                	jmp    80a8f8 <low_level_output+0x90>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a8b2:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a8b6:	0f b7 d0             	movzwl %ax,%edx
  80a8b9:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80a8bc:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a8c2:	7e 16                	jle    80a8da <low_level_output+0x72>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a8c4:	83 ec 0c             	sub    $0xc,%esp
  80a8c7:	56                   	push   %esi
  80a8c8:	52                   	push   %edx
  80a8c9:	68 40 2a 81 00       	push   $0x812a40
  80a8ce:	6a 64                	push   $0x64
  80a8d0:	68 69 2a 81 00       	push   $0x812a69
  80a8d5:	e8 07 3b 00 00       	call   80e3e1 <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a8da:	83 ec 04             	sub    $0x4,%esp
  80a8dd:	0f b7 c0             	movzwl %ax,%eax
  80a8e0:	50                   	push   %eax
  80a8e1:	ff 73 04             	pushl  0x4(%ebx)
  80a8e4:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80a8e7:	50                   	push   %eax
  80a8e8:	e8 4e 43 00 00       	call   80ec3b <memcpy>
	txsize += q->len;
  80a8ed:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a8f1:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a8f3:	8b 1b                	mov    (%ebx),%ebx
  80a8f5:	83 c4 10             	add    $0x10,%esp
  80a8f8:	85 db                	test   %ebx,%ebx
  80a8fa:	75 b6                	jne    80a8b2 <low_level_output+0x4a>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80a8fc:	89 35 00 00 00 10    	mov    %esi,0x10000000
    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a902:	6a 07                	push   $0x7
  80a904:	68 00 00 00 10       	push   $0x10000000
  80a909:	6a 0b                	push   $0xb
  80a90b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a90e:	ff 70 04             	pushl  0x4(%eax)
  80a911:	e8 33 4b 00 00       	call   80f449 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a916:	83 c4 08             	add    $0x8,%esp
  80a919:	68 00 00 00 10       	push   $0x10000000
  80a91e:	6a 00                	push   $0x0
  80a920:	e8 aa 45 00 00       	call   80eecf <sys_page_unmap>

    return ERR_OK;
}
  80a925:	b8 00 00 00 00       	mov    $0x0,%eax
  80a92a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a92d:	5b                   	pop    %ebx
  80a92e:	5e                   	pop    %esi
  80a92f:	5f                   	pop    %edi
  80a930:	5d                   	pop    %ebp
  80a931:	c3                   	ret    

0080a932 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a932:	55                   	push   %ebp
  80a933:	89 e5                	mov    %esp,%ebp
  80a935:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a938:	ff 75 10             	pushl  0x10(%ebp)
  80a93b:	ff 75 0c             	pushl  0xc(%ebp)
  80a93e:	ff 75 08             	pushl  0x8(%ebp)
  80a941:	e8 09 f1 ff ff       	call   809a4f <etharp_output>
}
  80a946:	c9                   	leave  
  80a947:	c3                   	ret    

0080a948 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a948:	55                   	push   %ebp
  80a949:	89 e5                	mov    %esp,%ebp
  80a94b:	57                   	push   %edi
  80a94c:	56                   	push   %esi
  80a94d:	53                   	push   %ebx
  80a94e:	83 ec 20             	sub    $0x20,%esp
  80a951:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80a954:	8b 45 08             	mov    0x8(%ebp),%eax
  80a957:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a95a:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80a95d:	8b 06                	mov    (%esi),%eax
  80a95f:	89 c3                	mov    %eax,%ebx

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80a961:	6a 03                	push   $0x3
  80a963:	0f b7 c0             	movzwl %ax,%eax
  80a966:	50                   	push   %eax
  80a967:	6a 03                	push   $0x3
  80a969:	e8 47 9f ff ff       	call   8048b5 <pbuf_alloc>
  80a96e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80a971:	83 c4 10             	add    $0x10,%esp
  80a974:	85 c0                	test   %eax,%eax
  80a976:	0f 84 b8 00 00 00    	je     80aa34 <jif_input+0xec>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80a97c:	8d 56 04             	lea    0x4(%esi),%edx
  80a97f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a982:	89 c6                	mov    %eax,%esi
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80a984:	bf 00 00 00 00       	mov    $0x0,%edi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80a989:	0f bf c3             	movswl %bx,%eax
  80a98c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80a98f:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (bytes > (len - copied))
  80a993:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a996:	29 fb                	sub    %edi,%ebx
  80a998:	39 c3                	cmp    %eax,%ebx
  80a99a:	0f 4f d8             	cmovg  %eax,%ebx
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80a99d:	83 ec 04             	sub    $0x4,%esp
  80a9a0:	53                   	push   %ebx
  80a9a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a9a4:	01 f8                	add    %edi,%eax
  80a9a6:	50                   	push   %eax
  80a9a7:	ff 76 04             	pushl  0x4(%esi)
  80a9aa:	e8 8c 42 00 00       	call   80ec3b <memcpy>
	copied += bytes;
  80a9af:	01 df                	add    %ebx,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a9b1:	8b 36                	mov    (%esi),%esi
  80a9b3:	83 c4 10             	add    $0x10,%esp
  80a9b6:	85 f6                	test   %esi,%esi
  80a9b8:	75 d5                	jne    80a98f <jif_input+0x47>
  80a9ba:	eb 54                	jmp    80aa10 <jif_input+0xc8>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80a9bc:	83 ec 08             	sub    $0x8,%esp
  80a9bf:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80a9c2:	57                   	push   %edi
  80a9c3:	ff 75 08             	pushl  0x8(%ebp)
  80a9c6:	e8 e1 ea ff ff       	call   8094ac <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80a9cb:	83 c4 08             	add    $0x8,%esp
  80a9ce:	6a f2                	push   $0xfffffff2
  80a9d0:	57                   	push   %edi
  80a9d1:	e8 47 9d ff ff       	call   80471d <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80a9d6:	83 c4 08             	add    $0x8,%esp
  80a9d9:	ff 75 08             	pushl  0x8(%ebp)
  80a9dc:	57                   	push   %edi
  80a9dd:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9e0:	ff 50 10             	call   *0x10(%eax)
	break;
  80a9e3:	83 c4 10             	add    $0x10,%esp
  80a9e6:	eb 4c                	jmp    80aa34 <jif_input+0xec>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80a9e8:	83 ec 04             	sub    $0x4,%esp
  80a9eb:	ff 75 dc             	pushl  -0x24(%ebp)
  80a9ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a9f1:	ff 30                	pushl  (%eax)
  80a9f3:	ff 75 08             	pushl  0x8(%ebp)
  80a9f6:	e8 fb ea ff ff       	call   8094f6 <etharp_arp_input>
	break;
  80a9fb:	83 c4 10             	add    $0x10,%esp
  80a9fe:	eb 34                	jmp    80aa34 <jif_input+0xec>

    default:
	pbuf_free(p);
  80aa00:	83 ec 0c             	sub    $0xc,%esp
  80aa03:	ff 75 dc             	pushl  -0x24(%ebp)
  80aa06:	e8 e4 9d ff ff       	call   8047ef <pbuf_free>
  80aa0b:	83 c4 10             	add    $0x10,%esp
  80aa0e:	eb 24                	jmp    80aa34 <jif_input+0xec>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80aa10:	83 ec 0c             	sub    $0xc,%esp
  80aa13:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aa16:	8b 40 04             	mov    0x4(%eax),%eax
  80aa19:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80aa1d:	50                   	push   %eax
  80aa1e:	e8 2a cc ff ff       	call   80764d <htons>
  80aa23:	83 c4 10             	add    $0x10,%esp
  80aa26:	66 3d 00 08          	cmp    $0x800,%ax
  80aa2a:	74 90                	je     80a9bc <jif_input+0x74>
  80aa2c:	66 3d 06 08          	cmp    $0x806,%ax
  80aa30:	74 b6                	je     80a9e8 <jif_input+0xa0>
  80aa32:	eb cc                	jmp    80aa00 <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80aa34:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa37:	5b                   	pop    %ebx
  80aa38:	5e                   	pop    %esi
  80aa39:	5f                   	pop    %edi
  80aa3a:	5d                   	pop    %ebp
  80aa3b:	c3                   	ret    

0080aa3c <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80aa3c:	55                   	push   %ebp
  80aa3d:	89 e5                	mov    %esp,%ebp
  80aa3f:	57                   	push   %edi
  80aa40:	56                   	push   %esi
  80aa41:	53                   	push   %ebx
  80aa42:	83 ec 28             	sub    $0x28,%esp
  80aa45:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80aa48:	6a 08                	push   $0x8
  80aa4a:	e8 c0 97 ff ff       	call   80420f <mem_malloc>
  80aa4f:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80aa51:	83 c4 10             	add    $0x10,%esp
  80aa54:	85 c0                	test   %eax,%eax
  80aa56:	74 7f                	je     80aad7 <jif_init+0x9b>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80aa58:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80aa5b:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80aa5e:	c7 43 14 32 a9 80 00 	movl   $0x80a932,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80aa65:	c7 43 18 68 a8 80 00 	movl   $0x80a868,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80aa6c:	83 ec 04             	sub    $0x4,%esp
  80aa6f:	6a 02                	push   $0x2
  80aa71:	68 fc 37 81 00       	push   $0x8137fc
  80aa76:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80aa79:	50                   	push   %eax
  80aa7a:	e8 bc 41 00 00       	call   80ec3b <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80aa7f:	8d 43 25             	lea    0x25(%ebx),%eax
  80aa82:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80aa84:	8b 07                	mov    (%edi),%eax
  80aa86:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80aa89:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80aa8d:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80aa93:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80aa97:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80aa9b:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80aa9f:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80aaa3:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80aaa7:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80aaab:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80aaaf:	c7 04 24 2b 0e 81 00 	movl   $0x810e2b,(%esp)
  80aab6:	e8 c1 cd ff ff       	call   80787c <inet_addr>
  80aabb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80aabe:	83 c4 0c             	add    $0xc,%esp
  80aac1:	6a 00                	push   $0x0
  80aac3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aac6:	50                   	push   %eax
  80aac7:	53                   	push   %ebx
  80aac8:	e8 41 ed ff ff       	call   80980e <etharp_query>

    return ERR_OK;
  80aacd:	83 c4 10             	add    $0x10,%esp
  80aad0:	b8 00 00 00 00       	mov    $0x0,%eax
  80aad5:	eb 05                	jmp    80aadc <jif_init+0xa0>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80aad7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80aadc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aadf:	5b                   	pop    %ebx
  80aae0:	5e                   	pop    %esi
  80aae1:	5f                   	pop    %edi
  80aae2:	5d                   	pop    %ebp
  80aae3:	c3                   	ret    

0080aae4 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80aae4:	55                   	push   %ebp
  80aae5:	89 e5                	mov    %esp,%ebp
  80aae7:	56                   	push   %esi
  80aae8:	53                   	push   %ebx
  80aae9:	83 ec 28             	sub    $0x28,%esp
  80aaec:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80aaef:	ff 75 10             	pushl  0x10(%ebp)
  80aaf2:	ff 75 08             	pushl  0x8(%ebp)
  80aaf5:	e8 00 0f 00 00       	call   80b9fa <netconn_alloc>
  80aafa:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80aafc:	83 c4 10             	add    $0x10,%esp
  80aaff:	85 c0                	test   %eax,%eax
  80ab01:	0f 84 bb 00 00 00    	je     80abc2 <netconn_new_with_proto_and_callback+0xde>
    msg.function = do_newconn;
  80ab07:	c7 45 e4 01 b9 80 00 	movl   $0x80b901,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ab0e:	89 f0                	mov    %esi,%eax
  80ab10:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ab13:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80ab16:	83 ec 0c             	sub    $0xc,%esp
  80ab19:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab1c:	50                   	push   %eax
  80ab1d:	e8 b6 78 ff ff       	call   8023d8 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80ab22:	83 c4 10             	add    $0x10,%esp
  80ab25:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ab29:	0f 84 9a 00 00 00    	je     80abc9 <netconn_new_with_proto_and_callback+0xe5>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ab2f:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ab33:	74 14                	je     80ab49 <netconn_new_with_proto_and_callback+0x65>
  80ab35:	83 ec 04             	sub    $0x4,%esp
  80ab38:	68 80 2a 81 00       	push   $0x812a80
  80ab3d:	6a 52                	push   $0x52
  80ab3f:	68 32 2b 81 00       	push   $0x812b32
  80ab44:	e8 98 38 00 00       	call   80e3e1 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ab49:	8b 43 10             	mov    0x10(%ebx),%eax
  80ab4c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ab4f:	75 14                	jne    80ab65 <netconn_new_with_proto_and_callback+0x81>
  80ab51:	83 ec 04             	sub    $0x4,%esp
  80ab54:	68 49 2b 81 00       	push   $0x812b49
  80ab59:	6a 53                	push   $0x53
  80ab5b:	68 32 2b 81 00       	push   $0x812b32
  80ab60:	e8 7c 38 00 00       	call   80e3e1 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ab65:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ab69:	75 14                	jne    80ab7f <netconn_new_with_proto_and_callback+0x9b>
  80ab6b:	83 ec 04             	sub    $0x4,%esp
  80ab6e:	68 62 2b 81 00       	push   $0x812b62
  80ab73:	6a 54                	push   $0x54
  80ab75:	68 32 2b 81 00       	push   $0x812b32
  80ab7a:	e8 62 38 00 00       	call   80e3e1 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ab7f:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ab83:	74 14                	je     80ab99 <netconn_new_with_proto_and_callback+0xb5>
  80ab85:	83 ec 04             	sub    $0x4,%esp
  80ab88:	68 a4 2a 81 00       	push   $0x812aa4
  80ab8d:	6a 55                	push   $0x55
  80ab8f:	68 32 2b 81 00       	push   $0x812b32
  80ab94:	e8 48 38 00 00       	call   80e3e1 <_panic>
      sys_sem_free(conn->op_completed);
  80ab99:	83 ec 0c             	sub    $0xc,%esp
  80ab9c:	50                   	push   %eax
  80ab9d:	e8 c9 f1 ff ff       	call   809d6b <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80aba2:	83 c4 04             	add    $0x4,%esp
  80aba5:	ff 73 14             	pushl  0x14(%ebx)
  80aba8:	e8 47 f2 ff ff       	call   809df4 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80abad:	83 c4 08             	add    $0x8,%esp
  80abb0:	53                   	push   %ebx
  80abb1:	6a 07                	push   $0x7
  80abb3:	e8 c4 98 ff ff       	call   80447c <memp_free>
      return NULL;
  80abb8:	83 c4 10             	add    $0x10,%esp
  80abbb:	b8 00 00 00 00       	mov    $0x0,%eax
  80abc0:	eb 09                	jmp    80abcb <netconn_new_with_proto_and_callback+0xe7>
    }
  }
  return conn;
  80abc2:	b8 00 00 00 00       	mov    $0x0,%eax
  80abc7:	eb 02                	jmp    80abcb <netconn_new_with_proto_and_callback+0xe7>
  80abc9:	89 d8                	mov    %ebx,%eax
}
  80abcb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80abce:	5b                   	pop    %ebx
  80abcf:	5e                   	pop    %esi
  80abd0:	5d                   	pop    %ebp
  80abd1:	c3                   	ret    

0080abd2 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80abd2:	55                   	push   %ebp
  80abd3:	89 e5                	mov    %esp,%ebp
  80abd5:	53                   	push   %ebx
  80abd6:	83 ec 24             	sub    $0x24,%esp
  80abd9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80abdc:	85 db                	test   %ebx,%ebx
  80abde:	74 28                	je     80ac08 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80abe0:	c7 45 e4 42 bc 80 00 	movl   $0x80bc42,-0x1c(%ebp)
  msg.msg.conn = conn;
  80abe7:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80abea:	83 ec 0c             	sub    $0xc,%esp
  80abed:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80abf0:	50                   	push   %eax
  80abf1:	e8 e2 77 ff ff       	call   8023d8 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80abf6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80abfd:	89 1c 24             	mov    %ebx,(%esp)
  80ac00:	e8 ae 0e 00 00       	call   80bab3 <netconn_free>

  return ERR_OK;
  80ac05:	83 c4 10             	add    $0x10,%esp
}
  80ac08:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac0d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac10:	c9                   	leave  
  80ac11:	c3                   	ret    

0080ac12 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ac12:	55                   	push   %ebp
  80ac13:	89 e5                	mov    %esp,%ebp
  80ac15:	83 ec 08             	sub    $0x8,%esp
  80ac18:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ac1b:	85 c0                	test   %eax,%eax
  80ac1d:	75 17                	jne    80ac36 <netconn_type+0x24>
  80ac1f:	83 ec 04             	sub    $0x4,%esp
  80ac22:	68 77 2b 81 00       	push   $0x812b77
  80ac27:	68 84 00 00 00       	push   $0x84
  80ac2c:	68 32 2b 81 00       	push   $0x812b32
  80ac31:	e8 ab 37 00 00       	call   80e3e1 <_panic>
  80ac36:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80ac38:	c9                   	leave  
  80ac39:	c3                   	ret    

0080ac3a <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80ac3a:	55                   	push   %ebp
  80ac3b:	89 e5                	mov    %esp,%ebp
  80ac3d:	53                   	push   %ebx
  80ac3e:	83 ec 24             	sub    $0x24,%esp
  80ac41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ac44:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ac47:	8b 45 10             	mov    0x10(%ebp),%eax
  80ac4a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ac4d:	85 db                	test   %ebx,%ebx
  80ac4f:	75 17                	jne    80ac68 <netconn_getaddr+0x2e>
  80ac51:	83 ec 04             	sub    $0x4,%esp
  80ac54:	68 92 2b 81 00       	push   $0x812b92
  80ac59:	68 98 00 00 00       	push   $0x98
  80ac5e:	68 32 2b 81 00       	push   $0x812b32
  80ac63:	e8 79 37 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ac68:	85 d2                	test   %edx,%edx
  80ac6a:	75 17                	jne    80ac83 <netconn_getaddr+0x49>
  80ac6c:	83 ec 04             	sub    $0x4,%esp
  80ac6f:	68 b0 2b 81 00       	push   $0x812bb0
  80ac74:	68 99 00 00 00       	push   $0x99
  80ac79:	68 32 2b 81 00       	push   $0x812b32
  80ac7e:	e8 5e 37 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ac83:	85 c0                	test   %eax,%eax
  80ac85:	75 17                	jne    80ac9e <netconn_getaddr+0x64>
  80ac87:	83 ec 04             	sub    $0x4,%esp
  80ac8a:	68 ce 2b 81 00       	push   $0x812bce
  80ac8f:	68 9a 00 00 00       	push   $0x9a
  80ac94:	68 32 2b 81 00       	push   $0x812b32
  80ac99:	e8 43 37 00 00       	call   80e3e1 <_panic>

  msg.function = do_getaddr;
  80ac9e:	c7 45 e4 91 c0 80 00 	movl   $0x80c091,-0x1c(%ebp)
  msg.msg.conn = conn;
  80aca5:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80aca8:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80acab:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80acae:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80acb1:	83 ec 0c             	sub    $0xc,%esp
  80acb4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80acb7:	50                   	push   %eax
  80acb8:	e8 1b 77 ff ff       	call   8023d8 <tcpip_apimsg>

  return conn->err;
  80acbd:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80acc1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80acc4:	c9                   	leave  
  80acc5:	c3                   	ret    

0080acc6 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80acc6:	55                   	push   %ebp
  80acc7:	89 e5                	mov    %esp,%ebp
  80acc9:	53                   	push   %ebx
  80acca:	83 ec 24             	sub    $0x24,%esp
  80accd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80acd0:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80acd3:	85 db                	test   %ebx,%ebx
  80acd5:	75 17                	jne    80acee <netconn_bind+0x28>
  80acd7:	83 ec 04             	sub    $0x4,%esp
  80acda:	68 ec 2b 81 00       	push   $0x812bec
  80acdf:	68 b5 00 00 00       	push   $0xb5
  80ace4:	68 32 2b 81 00       	push   $0x812b32
  80ace9:	e8 f3 36 00 00       	call   80e3e1 <_panic>

  msg.function = do_bind;
  80acee:	c7 45 e4 eb bc 80 00 	movl   $0x80bceb,-0x1c(%ebp)
  msg.msg.conn = conn;
  80acf5:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80acf8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80acfb:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80acfe:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ad02:	83 ec 0c             	sub    $0xc,%esp
  80ad05:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad08:	50                   	push   %eax
  80ad09:	e8 ca 76 ff ff       	call   8023d8 <tcpip_apimsg>
  return conn->err;
  80ad0e:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad12:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad15:	c9                   	leave  
  80ad16:	c3                   	ret    

0080ad17 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad17:	55                   	push   %ebp
  80ad18:	89 e5                	mov    %esp,%ebp
  80ad1a:	53                   	push   %ebx
  80ad1b:	83 ec 24             	sub    $0x24,%esp
  80ad1e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad21:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad24:	85 db                	test   %ebx,%ebx
  80ad26:	75 17                	jne    80ad3f <netconn_connect+0x28>
  80ad28:	83 ec 04             	sub    $0x4,%esp
  80ad2b:	68 07 2c 81 00       	push   $0x812c07
  80ad30:	68 cc 00 00 00       	push   $0xcc
  80ad35:	68 32 2b 81 00       	push   $0x812b32
  80ad3a:	e8 a2 36 00 00       	call   80e3e1 <_panic>

  msg.function = do_connect;
  80ad3f:	c7 45 e4 7b bd 80 00 	movl   $0x80bd7b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad46:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad49:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad4c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad4f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80ad53:	83 ec 0c             	sub    $0xc,%esp
  80ad56:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad59:	50                   	push   %eax
  80ad5a:	e8 79 76 ff ff       	call   8023d8 <tcpip_apimsg>
  return conn->err;
  80ad5f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad63:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad66:	c9                   	leave  
  80ad67:	c3                   	ret    

0080ad68 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80ad68:	55                   	push   %ebp
  80ad69:	89 e5                	mov    %esp,%ebp
  80ad6b:	53                   	push   %ebx
  80ad6c:	83 ec 24             	sub    $0x24,%esp
  80ad6f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad72:	85 db                	test   %ebx,%ebx
  80ad74:	75 17                	jne    80ad8d <netconn_disconnect+0x25>
  80ad76:	83 ec 04             	sub    $0x4,%esp
  80ad79:	68 c8 2a 81 00       	push   $0x812ac8
  80ad7e:	68 e2 00 00 00       	push   $0xe2
  80ad83:	68 32 2b 81 00       	push   $0x812b32
  80ad88:	e8 54 36 00 00       	call   80e3e1 <_panic>

  msg.function = do_disconnect;
  80ad8d:	c7 45 e4 30 be 80 00 	movl   $0x80be30,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad94:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80ad97:	83 ec 0c             	sub    $0xc,%esp
  80ad9a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad9d:	50                   	push   %eax
  80ad9e:	e8 35 76 ff ff       	call   8023d8 <tcpip_apimsg>
  return conn->err;
  80ada3:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ada7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80adaa:	c9                   	leave  
  80adab:	c3                   	ret    

0080adac <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80adac:	55                   	push   %ebp
  80adad:	89 e5                	mov    %esp,%ebp
  80adaf:	53                   	push   %ebx
  80adb0:	83 ec 24             	sub    $0x24,%esp
  80adb3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80adb6:	85 db                	test   %ebx,%ebx
  80adb8:	75 17                	jne    80add1 <netconn_listen_with_backlog+0x25>
  80adba:	83 ec 04             	sub    $0x4,%esp
  80adbd:	68 25 2c 81 00       	push   $0x812c25
  80adc2:	68 fa 00 00 00       	push   $0xfa
  80adc7:	68 32 2b 81 00       	push   $0x812b32
  80adcc:	e8 10 36 00 00       	call   80e3e1 <_panic>

  msg.function = do_listen;
  80add1:	c7 45 e4 6b be 80 00 	movl   $0x80be6b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80add8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80addb:	83 ec 0c             	sub    $0xc,%esp
  80adde:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ade1:	50                   	push   %eax
  80ade2:	e8 f1 75 ff ff       	call   8023d8 <tcpip_apimsg>
  return conn->err;
  80ade7:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80adeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80adee:	c9                   	leave  
  80adef:	c3                   	ret    

0080adf0 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80adf0:	55                   	push   %ebp
  80adf1:	89 e5                	mov    %esp,%ebp
  80adf3:	53                   	push   %ebx
  80adf4:	83 ec 14             	sub    $0x14,%esp
  80adf7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80adfa:	85 db                	test   %ebx,%ebx
  80adfc:	75 17                	jne    80ae15 <netconn_accept+0x25>
  80adfe:	83 ec 04             	sub    $0x4,%esp
  80ae01:	68 42 2c 81 00       	push   $0x812c42
  80ae06:	68 10 01 00 00       	push   $0x110
  80ae0b:	68 32 2b 81 00       	push   $0x812b32
  80ae10:	e8 cc 35 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ae15:	8b 43 18             	mov    0x18(%ebx),%eax
  80ae18:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae1b:	75 17                	jne    80ae34 <netconn_accept+0x44>
  80ae1d:	83 ec 04             	sub    $0x4,%esp
  80ae20:	68 ec 2a 81 00       	push   $0x812aec
  80ae25:	68 11 01 00 00       	push   $0x111
  80ae2a:	68 32 2b 81 00       	push   $0x812b32
  80ae2f:	e8 ad 35 00 00       	call   80e3e1 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80ae34:	83 ec 04             	sub    $0x4,%esp
  80ae37:	6a 00                	push   $0x0
  80ae39:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80ae3c:	52                   	push   %edx
  80ae3d:	50                   	push   %eax
  80ae3e:	e8 c6 f3 ff ff       	call   80a209 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80ae43:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ae46:	83 c4 10             	add    $0x10,%esp
  80ae49:	85 c0                	test   %eax,%eax
  80ae4b:	74 0d                	je     80ae5a <netconn_accept+0x6a>
  80ae4d:	83 ec 04             	sub    $0x4,%esp
  80ae50:	6a 00                	push   $0x0
  80ae52:	6a 01                	push   $0x1
  80ae54:	53                   	push   %ebx
  80ae55:	ff d0                	call   *%eax
  80ae57:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80ae5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ae5d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae60:	c9                   	leave  
  80ae61:	c3                   	ret    

0080ae62 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80ae62:	55                   	push   %ebp
  80ae63:	89 e5                	mov    %esp,%ebp
  80ae65:	53                   	push   %ebx
  80ae66:	83 ec 24             	sub    $0x24,%esp
  80ae69:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80ae6c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80ae73:	85 db                	test   %ebx,%ebx
  80ae75:	75 17                	jne    80ae8e <netconn_recv+0x2c>
  80ae77:	83 ec 04             	sub    $0x4,%esp
  80ae7a:	68 5f 2c 81 00       	push   $0x812c5f
  80ae7f:	68 3a 01 00 00       	push   $0x13a
  80ae84:	68 32 2b 81 00       	push   $0x812b32
  80ae89:	e8 53 35 00 00       	call   80e3e1 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80ae8e:	8b 43 14             	mov    0x14(%ebx),%eax
  80ae91:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae94:	75 0e                	jne    80aea4 <netconn_recv+0x42>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80ae96:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80ae9a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae9f:	e9 59 01 00 00       	jmp    80affd <netconn_recv+0x19b>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80aea4:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80aea8:	0f 8c 33 01 00 00    	jl     80afe1 <netconn_recv+0x17f>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80aeae:	83 3b 10             	cmpl   $0x10,(%ebx)
  80aeb1:	0f 85 e9 00 00 00    	jne    80afa0 <netconn_recv+0x13e>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80aeb7:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80aebb:	75 0e                	jne    80aecb <netconn_recv+0x69>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80aebd:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80aec1:	b8 00 00 00 00       	mov    $0x0,%eax
  80aec6:	e9 32 01 00 00       	jmp    80affd <netconn_recv+0x19b>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80aecb:	83 ec 0c             	sub    $0xc,%esp
  80aece:	6a 06                	push   $0x6
  80aed0:	e8 51 95 ff ff       	call   804426 <memp_malloc>
  80aed5:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80aed8:	83 c4 10             	add    $0x10,%esp
  80aedb:	85 c0                	test   %eax,%eax
  80aedd:	75 09                	jne    80aee8 <netconn_recv+0x86>
      conn->err = ERR_MEM;
  80aedf:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80aee3:	e9 15 01 00 00       	jmp    80affd <netconn_recv+0x19b>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80aee8:	83 ec 04             	sub    $0x4,%esp
  80aeeb:	6a 00                	push   $0x0
  80aeed:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80aef0:	50                   	push   %eax
  80aef1:	ff 73 14             	pushl  0x14(%ebx)
  80aef4:	e8 10 f3 ff ff       	call   80a209 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80aef9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aefc:	83 c4 10             	add    $0x10,%esp
  80aeff:	85 c0                	test   %eax,%eax
  80af01:	0f 84 e1 00 00 00    	je     80afe8 <netconn_recv+0x186>
      len = p->tot_len;
  80af07:	0f b7 40 08          	movzwl 0x8(%eax),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80af0b:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af0f:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80af12:	85 d2                	test   %edx,%edx
  80af14:	74 0f                	je     80af25 <netconn_recv+0xc3>
  80af16:	83 ec 04             	sub    $0x4,%esp
  80af19:	0f b7 c0             	movzwl %ax,%eax
  80af1c:	50                   	push   %eax
  80af1d:	6a 01                	push   $0x1
  80af1f:	53                   	push   %ebx
  80af20:	ff d2                	call   *%edx
  80af22:	83 c4 10             	add    $0x10,%esp

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80af25:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af28:	85 c0                	test   %eax,%eax
  80af2a:	75 28                	jne    80af54 <netconn_recv+0xf2>
      memp_free(MEMP_NETBUF, buf);
  80af2c:	83 ec 08             	sub    $0x8,%esp
  80af2f:	ff 75 e0             	pushl  -0x20(%ebp)
  80af32:	6a 06                	push   $0x6
  80af34:	e8 43 95 ff ff       	call   80447c <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80af39:	83 c4 10             	add    $0x10,%esp
        conn->err = ERR_CLSD;
      }
      return NULL;
  80af3c:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80af41:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80af45:	0f 85 b2 00 00 00    	jne    80affd <netconn_recv+0x19b>
        conn->err = ERR_CLSD;
  80af4b:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80af4f:	e9 a9 00 00 00       	jmp    80affd <netconn_recv+0x19b>
      }
      return NULL;
    }

    buf->p = p;
  80af54:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80af57:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80af59:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80af5c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80af5f:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80af62:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80af68:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80af6f:	c7 45 e4 fd bf 80 00 	movl   $0x80bffd,-0x1c(%ebp)
    msg.msg.conn = conn;
  80af76:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80af79:	85 c0                	test   %eax,%eax
  80af7b:	74 0c                	je     80af89 <netconn_recv+0x127>
      msg.msg.msg.r.len = buf->p->tot_len;
  80af7d:	8b 00                	mov    (%eax),%eax
  80af7f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80af83:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80af87:	eb 06                	jmp    80af8f <netconn_recv+0x12d>
    } else {
      msg.msg.msg.r.len = 1;
  80af89:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80af8f:	83 ec 0c             	sub    $0xc,%esp
  80af92:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af95:	50                   	push   %eax
  80af96:	e8 3d 74 ff ff       	call   8023d8 <tcpip_apimsg>
  80af9b:	83 c4 10             	add    $0x10,%esp
  80af9e:	eb 3c                	jmp    80afdc <netconn_recv+0x17a>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80afa0:	83 ec 04             	sub    $0x4,%esp
  80afa3:	6a 00                	push   $0x0
  80afa5:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80afa8:	52                   	push   %edx
  80afa9:	50                   	push   %eax
  80afaa:	e8 5a f2 ff ff       	call   80a209 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80afaf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80afb2:	83 c4 10             	add    $0x10,%esp
  80afb5:	85 c0                	test   %eax,%eax
  80afb7:	74 23                	je     80afdc <netconn_recv+0x17a>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80afb9:	8b 10                	mov    (%eax),%edx
  80afbb:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80afbf:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80afc3:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80afc6:	85 d2                	test   %edx,%edx
  80afc8:	74 12                	je     80afdc <netconn_recv+0x17a>
  80afca:	83 ec 04             	sub    $0x4,%esp
  80afcd:	8b 00                	mov    (%eax),%eax
  80afcf:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80afd3:	50                   	push   %eax
  80afd4:	6a 01                	push   $0x1
  80afd6:	53                   	push   %ebx
  80afd7:	ff d2                	call   *%edx
  80afd9:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80afdc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80afdf:	eb 1c                	jmp    80affd <netconn_recv+0x19b>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80afe1:	b8 00 00 00 00       	mov    $0x0,%eax
  80afe6:	eb 15                	jmp    80affd <netconn_recv+0x19b>
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80afe8:	8b 53 2c             	mov    0x2c(%ebx),%edx

    if (p != NULL) {
      len = p->tot_len;
      SYS_ARCH_DEC(conn->recv_avail, len);
    } else {
      len = 0;
  80afeb:	b8 00 00 00 00       	mov    $0x0,%eax
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80aff0:	85 d2                	test   %edx,%edx
  80aff2:	0f 85 1e ff ff ff    	jne    80af16 <netconn_recv+0xb4>
  80aff8:	e9 2f ff ff ff       	jmp    80af2c <netconn_recv+0xca>
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80affd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b000:	c9                   	leave  
  80b001:	c3                   	ret    

0080b002 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b002:	55                   	push   %ebp
  80b003:	89 e5                	mov    %esp,%ebp
  80b005:	53                   	push   %ebx
  80b006:	83 ec 24             	sub    $0x24,%esp
  80b009:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b00c:	85 db                	test   %ebx,%ebx
  80b00e:	75 17                	jne    80b027 <netconn_send+0x25>
  80b010:	83 ec 04             	sub    $0x4,%esp
  80b013:	68 7a 2c 81 00       	push   $0x812c7a
  80b018:	68 b9 01 00 00       	push   $0x1b9
  80b01d:	68 32 2b 81 00       	push   $0x812b32
  80b022:	e8 ba 33 00 00       	call   80e3e1 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b027:	c7 45 e4 57 bf 80 00 	movl   $0x80bf57,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b02e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b031:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b034:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b037:	83 ec 0c             	sub    $0xc,%esp
  80b03a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b03d:	50                   	push   %eax
  80b03e:	e8 95 73 ff ff       	call   8023d8 <tcpip_apimsg>
  return conn->err;
  80b043:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b047:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b04a:	c9                   	leave  
  80b04b:	c3                   	ret    

0080b04c <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80b04c:	55                   	push   %ebp
  80b04d:	89 e5                	mov    %esp,%ebp
  80b04f:	83 ec 08             	sub    $0x8,%esp
  80b052:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b055:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b058:	85 c0                	test   %eax,%eax
  80b05a:	74 1b                	je     80b077 <netconn_sendto+0x2b>
    buf->addr = addr;
  80b05c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b05f:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b062:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b066:	83 ec 08             	sub    $0x8,%esp
  80b069:	50                   	push   %eax
  80b06a:	ff 75 08             	pushl  0x8(%ebp)
  80b06d:	e8 90 ff ff ff       	call   80b002 <netconn_send>
  80b072:	83 c4 10             	add    $0x10,%esp
  80b075:	eb 05                	jmp    80b07c <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80b077:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80b07c:	c9                   	leave  
  80b07d:	c3                   	ret    

0080b07e <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b07e:	55                   	push   %ebp
  80b07f:	89 e5                	mov    %esp,%ebp
  80b081:	53                   	push   %ebx
  80b082:	83 ec 24             	sub    $0x24,%esp
  80b085:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b088:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b08b:	85 db                	test   %ebx,%ebx
  80b08d:	75 17                	jne    80b0a6 <netconn_write+0x28>
  80b08f:	83 ec 04             	sub    $0x4,%esp
  80b092:	68 95 2c 81 00       	push   $0x812c95
  80b097:	68 d3 01 00 00       	push   $0x1d3
  80b09c:	68 32 2b 81 00       	push   $0x812b32
  80b0a1:	e8 3b 33 00 00       	call   80e3e1 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b0a6:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b0a9:	74 17                	je     80b0c2 <netconn_write+0x44>
  80b0ab:	83 ec 04             	sub    $0x4,%esp
  80b0ae:	68 10 2b 81 00       	push   $0x812b10
  80b0b3:	68 d4 01 00 00       	push   $0x1d4
  80b0b8:	68 32 2b 81 00       	push   $0x812b32
  80b0bd:	e8 1f 33 00 00       	call   80e3e1 <_panic>

  msg.function = do_write;
  80b0c2:	c7 45 e4 41 c0 80 00 	movl   $0x80c041,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b0c9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b0cc:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b0cf:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b0d2:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b0d5:	8b 45 10             	mov    0x10(%ebp),%eax
  80b0d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b0db:	83 ec 0c             	sub    $0xc,%esp
  80b0de:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b0e1:	50                   	push   %eax
  80b0e2:	e8 f1 72 ff ff       	call   8023d8 <tcpip_apimsg>
  return conn->err;
  80b0e7:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b0eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0ee:	c9                   	leave  
  80b0ef:	c3                   	ret    

0080b0f0 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b0f0:	55                   	push   %ebp
  80b0f1:	89 e5                	mov    %esp,%ebp
  80b0f3:	53                   	push   %ebx
  80b0f4:	83 ec 24             	sub    $0x24,%esp
  80b0f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b0fa:	85 db                	test   %ebx,%ebx
  80b0fc:	75 17                	jne    80b115 <netconn_close+0x25>
  80b0fe:	83 ec 04             	sub    $0x4,%esp
  80b101:	68 b1 2c 81 00       	push   $0x812cb1
  80b106:	68 ed 01 00 00       	push   $0x1ed
  80b10b:	68 32 2b 81 00       	push   $0x812b32
  80b110:	e8 cc 32 00 00       	call   80e3e1 <_panic>

  msg.function = do_close;
  80b115:	c7 45 e4 55 c1 80 00 	movl   $0x80c155,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b11c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b11f:	83 ec 0c             	sub    $0xc,%esp
  80b122:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b125:	50                   	push   %eax
  80b126:	e8 ad 72 ff ff       	call   8023d8 <tcpip_apimsg>
  return conn->err;
  80b12b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b12f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b132:	c9                   	leave  
  80b133:	c3                   	ret    

0080b134 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b134:	55                   	push   %ebp
  80b135:	89 e5                	mov    %esp,%ebp
  80b137:	56                   	push   %esi
  80b138:	53                   	push   %ebx
  80b139:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b13c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b13f:	8b 75 10             	mov    0x10(%ebp),%esi
  80b142:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b145:	85 c0                	test   %eax,%eax
  80b147:	75 17                	jne    80b160 <recv_tcp+0x2c>
  80b149:	83 ec 04             	sub    $0x4,%esp
  80b14c:	68 d0 2c 81 00       	push   $0x812cd0
  80b151:	68 c1 00 00 00       	push   $0xc1
  80b156:	68 1a 2e 81 00       	push   $0x812e1a
  80b15b:	e8 81 32 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b160:	85 db                	test   %ebx,%ebx
  80b162:	75 17                	jne    80b17b <recv_tcp+0x47>
  80b164:	83 ec 04             	sub    $0x4,%esp
  80b167:	68 f4 2c 81 00       	push   $0x812cf4
  80b16c:	68 c2 00 00 00       	push   $0xc2
  80b171:	68 1a 2e 81 00       	push   $0x812e1a
  80b176:	e8 66 32 00 00       	call   80e3e1 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b17b:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b17e:	74 17                	je     80b197 <recv_tcp+0x63>
  80b180:	83 ec 04             	sub    $0x4,%esp
  80b183:	68 31 2e 81 00       	push   $0x812e31
  80b188:	68 c4 00 00 00       	push   $0xc4
  80b18d:	68 1a 2e 81 00       	push   $0x812e1a
  80b192:	e8 4a 32 00 00       	call   80e3e1 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b197:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b19b:	74 44                	je     80b1e1 <recv_tcp+0xad>
    return ERR_VAL;
  }

  conn->err = err;
  80b19d:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80b1a0:	85 f6                	test   %esi,%esi
  80b1a2:	74 0a                	je     80b1ae <recv_tcp+0x7a>
    len = p->tot_len;
  80b1a4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b1a8:	66 01 43 20          	add    %ax,0x20(%ebx)
  80b1ac:	eb 05                	jmp    80b1b3 <recv_tcp+0x7f>
  } else {
    len = 0;
  80b1ae:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b1b3:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b1b6:	85 d2                	test   %edx,%edx
  80b1b8:	74 0f                	je     80b1c9 <recv_tcp+0x95>
  80b1ba:	83 ec 04             	sub    $0x4,%esp
  80b1bd:	0f b7 c0             	movzwl %ax,%eax
  80b1c0:	50                   	push   %eax
  80b1c1:	6a 00                	push   $0x0
  80b1c3:	53                   	push   %ebx
  80b1c4:	ff d2                	call   *%edx
  80b1c6:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b1c9:	83 ec 08             	sub    $0x8,%esp
  80b1cc:	56                   	push   %esi
  80b1cd:	ff 73 14             	pushl  0x14(%ebx)
  80b1d0:	e8 41 ef ff ff       	call   80a116 <sys_mbox_trypost>
  80b1d5:	83 c4 10             	add    $0x10,%esp
  80b1d8:	84 c0                	test   %al,%al
  80b1da:	0f 95 c0             	setne  %al
  80b1dd:	f7 d8                	neg    %eax
  80b1df:	eb 05                	jmp    80b1e6 <recv_tcp+0xb2>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80b1e1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b1e6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b1e9:	5b                   	pop    %ebx
  80b1ea:	5e                   	pop    %esi
  80b1eb:	5d                   	pop    %ebp
  80b1ec:	c3                   	ret    

0080b1ed <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80b1ed:	55                   	push   %ebp
  80b1ee:	89 e5                	mov    %esp,%ebp
  80b1f0:	57                   	push   %edi
  80b1f1:	56                   	push   %esi
  80b1f2:	53                   	push   %ebx
  80b1f3:	83 ec 1c             	sub    $0x1c,%esp
  80b1f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b1f9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b1fc:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b1ff:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b202:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b205:	85 c0                	test   %eax,%eax
  80b207:	75 17                	jne    80b220 <recv_udp+0x33>
  80b209:	83 ec 04             	sub    $0x4,%esp
  80b20c:	68 14 2d 81 00       	push   $0x812d14
  80b211:	68 8e 00 00 00       	push   $0x8e
  80b216:	68 1a 2e 81 00       	push   $0x812e1a
  80b21b:	e8 c1 31 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b220:	85 db                	test   %ebx,%ebx
  80b222:	75 17                	jne    80b23b <recv_udp+0x4e>
  80b224:	83 ec 04             	sub    $0x4,%esp
  80b227:	68 38 2d 81 00       	push   $0x812d38
  80b22c:	68 8f 00 00 00       	push   $0x8f
  80b231:	68 1a 2e 81 00       	push   $0x812e1a
  80b236:	e8 a6 31 00 00       	call   80e3e1 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b23b:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b23e:	74 17                	je     80b257 <recv_udp+0x6a>
  80b240:	83 ec 04             	sub    $0x4,%esp
  80b243:	68 4f 2e 81 00       	push   $0x812e4f
  80b248:	68 91 00 00 00       	push   $0x91
  80b24d:	68 1a 2e 81 00       	push   $0x812e1a
  80b252:	e8 8a 31 00 00       	call   80e3e1 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b257:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b25b:	75 0e                	jne    80b26b <recv_udp+0x7e>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80b25d:	83 ec 0c             	sub    $0xc,%esp
  80b260:	57                   	push   %edi
  80b261:	e8 89 95 ff ff       	call   8047ef <pbuf_free>
    return;
  80b266:	83 c4 10             	add    $0x10,%esp
  80b269:	eb 72                	jmp    80b2dd <recv_udp+0xf0>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80b26b:	83 ec 0c             	sub    $0xc,%esp
  80b26e:	6a 06                	push   $0x6
  80b270:	e8 b1 91 ff ff       	call   804426 <memp_malloc>
  80b275:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b277:	83 c4 10             	add    $0x10,%esp
  80b27a:	85 c0                	test   %eax,%eax
  80b27c:	75 0e                	jne    80b28c <recv_udp+0x9f>
    pbuf_free(p);
  80b27e:	83 ec 0c             	sub    $0xc,%esp
  80b281:	57                   	push   %edi
  80b282:	e8 68 95 ff ff       	call   8047ef <pbuf_free>
    return;
  80b287:	83 c4 10             	add    $0x10,%esp
  80b28a:	eb 51                	jmp    80b2dd <recv_udp+0xf0>
  } else {
    buf->p = p;
  80b28c:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b28e:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b291:	8b 45 14             	mov    0x14(%ebp),%eax
  80b294:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b297:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b29b:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b29f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b2a3:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b2a7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2aa:	85 c0                	test   %eax,%eax
  80b2ac:	74 10                	je     80b2be <recv_udp+0xd1>
  80b2ae:	83 ec 04             	sub    $0x4,%esp
  80b2b1:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b2b5:	52                   	push   %edx
  80b2b6:	6a 00                	push   $0x0
  80b2b8:	53                   	push   %ebx
  80b2b9:	ff d0                	call   *%eax
  80b2bb:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b2be:	83 ec 08             	sub    $0x8,%esp
  80b2c1:	56                   	push   %esi
  80b2c2:	ff 73 14             	pushl  0x14(%ebx)
  80b2c5:	e8 4c ee ff ff       	call   80a116 <sys_mbox_trypost>
  80b2ca:	83 c4 10             	add    $0x10,%esp
  80b2cd:	84 c0                	test   %al,%al
  80b2cf:	74 0c                	je     80b2dd <recv_udp+0xf0>
    netbuf_delete(buf);
  80b2d1:	83 ec 0c             	sub    $0xc,%esp
  80b2d4:	56                   	push   %esi
  80b2d5:	e8 ee 71 ff ff       	call   8024c8 <netbuf_delete>
    return;
  80b2da:	83 c4 10             	add    $0x10,%esp
  }
}
  80b2dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b2e0:	5b                   	pop    %ebx
  80b2e1:	5e                   	pop    %esi
  80b2e2:	5f                   	pop    %edi
  80b2e3:	5d                   	pop    %ebp
  80b2e4:	c3                   	ret    

0080b2e5 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80b2e5:	55                   	push   %ebp
  80b2e6:	89 e5                	mov    %esp,%ebp
  80b2e8:	57                   	push   %edi
  80b2e9:	56                   	push   %esi
  80b2ea:	53                   	push   %ebx
  80b2eb:	83 ec 0c             	sub    $0xc,%esp
  80b2ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b2f1:	85 db                	test   %ebx,%ebx
  80b2f3:	0f 84 c8 00 00 00    	je     80b3c1 <recv_raw+0xdc>
  80b2f9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b2fd:	0f 84 be 00 00 00    	je     80b3c1 <recv_raw+0xdc>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b303:	83 ec 04             	sub    $0x4,%esp
  80b306:	6a 00                	push   $0x0
  80b308:	8b 45 10             	mov    0x10(%ebp),%eax
  80b30b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b30f:	50                   	push   %eax
  80b310:	6a 03                	push   $0x3
  80b312:	e8 9e 95 ff ff       	call   8048b5 <pbuf_alloc>
  80b317:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b319:	83 c4 10             	add    $0x10,%esp
  80b31c:	85 c0                	test   %eax,%eax
  80b31e:	0f 84 9d 00 00 00    	je     80b3c1 <recv_raw+0xdc>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b324:	83 ec 08             	sub    $0x8,%esp
  80b327:	ff 75 10             	pushl  0x10(%ebp)
  80b32a:	50                   	push   %eax
  80b32b:	e8 76 9a ff ff       	call   804da6 <pbuf_copy>
  80b330:	83 c4 10             	add    $0x10,%esp
  80b333:	84 c0                	test   %al,%al
  80b335:	74 75                	je     80b3ac <recv_raw+0xc7>
        pbuf_free(q);
  80b337:	83 ec 0c             	sub    $0xc,%esp
  80b33a:	56                   	push   %esi
  80b33b:	e8 af 94 ff ff       	call   8047ef <pbuf_free>
  80b340:	83 c4 10             	add    $0x10,%esp
  80b343:	eb 7c                	jmp    80b3c1 <recv_raw+0xdc>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80b345:	83 ec 0c             	sub    $0xc,%esp
  80b348:	56                   	push   %esi
  80b349:	e8 a1 94 ff ff       	call   8047ef <pbuf_free>
        return 0;
  80b34e:	83 c4 10             	add    $0x10,%esp
  80b351:	eb 6e                	jmp    80b3c1 <recv_raw+0xdc>
      }

      buf->p = q;
  80b353:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b355:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b358:	8b 46 04             	mov    0x4(%esi),%eax
  80b35b:	83 c0 0c             	add    $0xc,%eax
  80b35e:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b361:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b364:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b368:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b36c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b370:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b374:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b377:	85 c0                	test   %eax,%eax
  80b379:	74 10                	je     80b38b <recv_raw+0xa6>
  80b37b:	83 ec 04             	sub    $0x4,%esp
  80b37e:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b382:	52                   	push   %edx
  80b383:	6a 00                	push   $0x0
  80b385:	53                   	push   %ebx
  80b386:	ff d0                	call   *%eax
  80b388:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b38b:	83 ec 08             	sub    $0x8,%esp
  80b38e:	57                   	push   %edi
  80b38f:	ff 73 14             	pushl  0x14(%ebx)
  80b392:	e8 7f ed ff ff       	call   80a116 <sys_mbox_trypost>
  80b397:	83 c4 10             	add    $0x10,%esp
  80b39a:	84 c0                	test   %al,%al
  80b39c:	74 23                	je     80b3c1 <recv_raw+0xdc>
        netbuf_delete(buf);
  80b39e:	83 ec 0c             	sub    $0xc,%esp
  80b3a1:	57                   	push   %edi
  80b3a2:	e8 21 71 ff ff       	call   8024c8 <netbuf_delete>
  80b3a7:	83 c4 10             	add    $0x10,%esp
  80b3aa:	eb 15                	jmp    80b3c1 <recv_raw+0xdc>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80b3ac:	83 ec 0c             	sub    $0xc,%esp
  80b3af:	6a 06                	push   $0x6
  80b3b1:	e8 70 90 ff ff       	call   804426 <memp_malloc>
  80b3b6:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b3b8:	83 c4 10             	add    $0x10,%esp
  80b3bb:	85 c0                	test   %eax,%eax
  80b3bd:	75 94                	jne    80b353 <recv_raw+0x6e>
  80b3bf:	eb 84                	jmp    80b345 <recv_raw+0x60>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80b3c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3c6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b3c9:	5b                   	pop    %ebx
  80b3ca:	5e                   	pop    %esi
  80b3cb:	5f                   	pop    %edi
  80b3cc:	5d                   	pop    %ebp
  80b3cd:	c3                   	ret    

0080b3ce <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b3ce:	55                   	push   %ebp
  80b3cf:	89 e5                	mov    %esp,%ebp
  80b3d1:	53                   	push   %ebx
  80b3d2:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b3d5:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b3d8:	50                   	push   %eax
  80b3d9:	53                   	push   %ebx
  80b3da:	e8 1e a4 ff ff       	call   8057fd <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b3df:	83 c4 08             	add    $0x8,%esp
  80b3e2:	68 34 b1 80 00       	push   $0x80b134
  80b3e7:	53                   	push   %ebx
  80b3e8:	e8 1e a4 ff ff       	call   80580b <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b3ed:	83 c4 08             	add    $0x8,%esp
  80b3f0:	68 6c b8 80 00       	push   $0x80b86c
  80b3f5:	53                   	push   %ebx
  80b3f6:	e8 21 a4 ff ff       	call   80581c <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b3fb:	83 c4 0c             	add    $0xc,%esp
  80b3fe:	6a 04                	push   $0x4
  80b400:	68 28 b8 80 00       	push   $0x80b828
  80b405:	53                   	push   %ebx
  80b406:	e8 41 a4 ff ff       	call   80584c <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b40b:	83 c4 08             	add    $0x8,%esp
  80b40e:	68 6b b4 80 00       	push   $0x80b46b
  80b413:	53                   	push   %ebx
  80b414:	e8 14 a4 ff ff       	call   80582d <tcp_err>
  80b419:	83 c4 10             	add    $0x10,%esp
}
  80b41c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b41f:	c9                   	leave  
  80b420:	c3                   	ret    

0080b421 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b421:	55                   	push   %ebp
  80b422:	89 e5                	mov    %esp,%ebp
  80b424:	53                   	push   %ebx
  80b425:	83 ec 04             	sub    $0x4,%esp
  80b428:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b42b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b42e:	85 db                	test   %ebx,%ebx
  80b430:	74 2f                	je     80b461 <do_connected+0x40>
    return ERR_VAL;
  }

  conn->err = err;
  80b432:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b435:	84 c0                	test   %al,%al
  80b437:	75 0c                	jne    80b445 <do_connected+0x24>
  80b439:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b43c:	75 07                	jne    80b445 <do_connected+0x24>
    setup_tcp(conn);
  80b43e:	89 d8                	mov    %ebx,%eax
  80b440:	e8 89 ff ff ff       	call   80b3ce <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80b445:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b44c:	83 ec 0c             	sub    $0xc,%esp
  80b44f:	ff 73 10             	pushl  0x10(%ebx)
  80b452:	e8 44 eb ff ff       	call   809f9b <sys_sem_signal>
  return ERR_OK;
  80b457:	83 c4 10             	add    $0x10,%esp
  80b45a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b45f:	eb 05                	jmp    80b466 <do_connected+0x45>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80b461:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80b466:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b469:	c9                   	leave  
  80b46a:	c3                   	ret    

0080b46b <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80b46b:	55                   	push   %ebp
  80b46c:	89 e5                	mov    %esp,%ebp
  80b46e:	53                   	push   %ebx
  80b46f:	83 ec 04             	sub    $0x4,%esp
  80b472:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b475:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b478:	85 db                	test   %ebx,%ebx
  80b47a:	75 17                	jne    80b493 <err_tcp+0x28>
  80b47c:	83 ec 04             	sub    $0x4,%esp
  80b47f:	68 6d 2e 81 00       	push   $0x812e6d
  80b484:	68 22 01 00 00       	push   $0x122
  80b489:	68 1a 2e 81 00       	push   $0x812e1a
  80b48e:	e8 4e 2f 00 00       	call   80e3e1 <_panic>

  conn->pcb.tcp = NULL;
  80b493:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80b49a:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b49d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b4a1:	74 24                	je     80b4c7 <err_tcp+0x5c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b4a3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b4a6:	85 c0                	test   %eax,%eax
  80b4a8:	74 0d                	je     80b4b7 <err_tcp+0x4c>
  80b4aa:	83 ec 04             	sub    $0x4,%esp
  80b4ad:	6a 00                	push   $0x0
  80b4af:	6a 00                	push   $0x0
  80b4b1:	53                   	push   %ebx
  80b4b2:	ff d0                	call   *%eax
  80b4b4:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b4b7:	83 ec 08             	sub    $0x8,%esp
  80b4ba:	6a 00                	push   $0x0
  80b4bc:	ff 73 14             	pushl  0x14(%ebx)
  80b4bf:	e8 15 ed ff ff       	call   80a1d9 <sys_mbox_post>
  80b4c4:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b4c7:	8b 43 10             	mov    0x10(%ebx),%eax
  80b4ca:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b4cd:	74 19                	je     80b4e8 <err_tcp+0x7d>
  80b4cf:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b4d3:	75 13                	jne    80b4e8 <err_tcp+0x7d>
    conn->state = NETCONN_NONE;
  80b4d5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b4dc:	83 ec 0c             	sub    $0xc,%esp
  80b4df:	50                   	push   %eax
  80b4e0:	e8 b6 ea ff ff       	call   809f9b <sys_sem_signal>
  80b4e5:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b4e8:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b4ec:	74 24                	je     80b512 <err_tcp+0xa7>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b4ee:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b4f1:	85 c0                	test   %eax,%eax
  80b4f3:	74 0d                	je     80b502 <err_tcp+0x97>
  80b4f5:	83 ec 04             	sub    $0x4,%esp
  80b4f8:	6a 00                	push   $0x0
  80b4fa:	6a 00                	push   $0x0
  80b4fc:	53                   	push   %ebx
  80b4fd:	ff d0                	call   *%eax
  80b4ff:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b502:	83 ec 08             	sub    $0x8,%esp
  80b505:	6a 00                	push   $0x0
  80b507:	ff 73 18             	pushl  0x18(%ebx)
  80b50a:	e8 ca ec ff ff       	call   80a1d9 <sys_mbox_post>
  80b50f:	83 c4 10             	add    $0x10,%esp
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b512:	8b 43 04             	mov    0x4(%ebx),%eax
  80b515:	83 f8 04             	cmp    $0x4,%eax
  80b518:	74 05                	je     80b51f <err_tcp+0xb4>
  80b51a:	83 f8 01             	cmp    $0x1,%eax
  80b51d:	75 15                	jne    80b534 <err_tcp+0xc9>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80b51f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80b526:	83 ec 0c             	sub    $0xc,%esp
  80b529:	ff 73 10             	pushl  0x10(%ebx)
  80b52c:	e8 6a ea ff ff       	call   809f9b <sys_sem_signal>
  80b531:	83 c4 10             	add    $0x10,%esp
  }
}
  80b534:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b537:	c9                   	leave  
  80b538:	c3                   	ret    

0080b539 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b539:	55                   	push   %ebp
  80b53a:	89 e5                	mov    %esp,%ebp
  80b53c:	57                   	push   %edi
  80b53d:	56                   	push   %esi
  80b53e:	53                   	push   %ebx
  80b53f:	83 ec 0c             	sub    $0xc,%esp
  80b542:	89 c6                	mov    %eax,%esi
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b544:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b548:	74 17                	je     80b561 <do_writemore+0x28>
  80b54a:	83 ec 04             	sub    $0x4,%esp
  80b54d:	68 7a 2e 81 00       	push   $0x812e7a
  80b552:	68 b8 03 00 00       	push   $0x3b8
  80b557:	68 1a 2e 81 00       	push   $0x812e1a
  80b55c:	e8 80 2e 00 00       	call   80e3e1 <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b561:	8b 40 24             	mov    0x24(%eax),%eax
  80b564:	8b 7e 28             	mov    0x28(%esi),%edi
  80b567:	89 f9                	mov    %edi,%ecx
  80b569:	03 48 04             	add    0x4(%eax),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b56c:	8b 50 08             	mov    0x8(%eax),%edx
  80b56f:	89 d3                	mov    %edx,%ebx
  80b571:	29 fb                	sub    %edi,%ebx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b573:	29 fa                	sub    %edi,%edx
  80b575:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80b57b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80b580:	0f 4f d3             	cmovg  %ebx,%edx
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b583:	8b 7e 08             	mov    0x8(%esi),%edi
  80b586:	0f b7 5f 6e          	movzwl 0x6e(%edi),%ebx
  80b58a:	66 39 da             	cmp    %bx,%dx
  80b58d:	0f 46 da             	cmovbe %edx,%ebx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b590:	0f b7 db             	movzwl %bx,%ebx
  80b593:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b597:	50                   	push   %eax
  80b598:	53                   	push   %ebx
  80b599:	51                   	push   %ecx
  80b59a:	57                   	push   %edi
  80b59b:	e8 b0 c9 ff ff       	call   807f50 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b5a0:	89 da                	mov    %ebx,%edx
  80b5a2:	03 56 28             	add    0x28(%esi),%edx
  80b5a5:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b5a8:	83 c4 10             	add    $0x10,%esp
  80b5ab:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b5ae:	7e 17                	jle    80b5c7 <do_writemore+0x8e>
  80b5b0:	83 ec 04             	sub    $0x4,%esp
  80b5b3:	68 97 2e 81 00       	push   $0x812e97
  80b5b8:	68 cd 03 00 00       	push   $0x3cd
  80b5bd:	68 1a 2e 81 00       	push   $0x812e1a
  80b5c2:	e8 1a 2e 00 00       	call   80e3e1 <_panic>
  if (err == ERR_OK) {
  80b5c7:	84 c0                	test   %al,%al
  80b5c9:	75 6e                	jne    80b639 <do_writemore+0x100>
    conn->write_offset += len;
  80b5cb:	89 56 28             	mov    %edx,0x28(%esi)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80b5ce:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b5d3:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b5d6:	75 13                	jne    80b5eb <do_writemore+0xb2>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80b5d8:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b5df:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80b5e6:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b5eb:	8b 46 08             	mov    0x8(%esi),%eax
  80b5ee:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b5f2:	74 12                	je     80b606 <do_writemore+0xcd>
  80b5f4:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b5f8:	75 0c                	jne    80b606 <do_writemore+0xcd>
  80b5fa:	8b 50 74             	mov    0x74(%eax),%edx
  80b5fd:	85 d2                	test   %edx,%edx
  80b5ff:	74 6e                	je     80b66f <do_writemore+0x136>
  80b601:	83 3a 00             	cmpl   $0x0,(%edx)
  80b604:	74 69                	je     80b66f <do_writemore+0x136>
  80b606:	83 ec 0c             	sub    $0xc,%esp
  80b609:	50                   	push   %eax
  80b60a:	e8 94 c9 ff ff       	call   807fa3 <tcp_output>
    conn->err = err;
  80b60f:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b612:	83 c4 10             	add    $0x10,%esp
  80b615:	84 c0                	test   %al,%al
  80b617:	75 39                	jne    80b652 <do_writemore+0x119>
  80b619:	8b 46 08             	mov    0x8(%esi),%eax
  80b61c:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b622:	77 2e                	ja     80b652 <do_writemore+0x119>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b624:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b627:	85 c0                	test   %eax,%eax
  80b629:	74 27                	je     80b652 <do_writemore+0x119>
  80b62b:	83 ec 04             	sub    $0x4,%esp
  80b62e:	53                   	push   %ebx
  80b62f:	6a 03                	push   $0x3
  80b631:	56                   	push   %esi
  80b632:	ff d0                	call   *%eax
  80b634:	83 c4 10             	add    $0x10,%esp
  80b637:	eb 19                	jmp    80b652 <do_writemore+0x119>
    }
  } else if (err == ERR_MEM) {
  80b639:	3c ff                	cmp    $0xff,%al
  80b63b:	75 10                	jne    80b64d <do_writemore+0x114>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80b63d:	83 ec 0c             	sub    $0xc,%esp
  80b640:	ff 76 08             	pushl  0x8(%esi)
  80b643:	e8 5b c9 ff ff       	call   807fa3 <tcp_output>
  80b648:	83 c4 10             	add    $0x10,%esp
  80b64b:	eb 28                	jmp    80b675 <do_writemore+0x13c>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80b64d:	88 46 0c             	mov    %al,0xc(%esi)
  80b650:	eb 06                	jmp    80b658 <do_writemore+0x11f>
    write_finished = 1;
  }

  if (write_finished) {
  80b652:	89 f8                	mov    %edi,%eax
  80b654:	84 c0                	test   %al,%al
  80b656:	74 1d                	je     80b675 <do_writemore+0x13c>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b658:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b65f:	83 ec 0c             	sub    $0xc,%esp
  80b662:	ff 76 10             	pushl  0x10(%esi)
  80b665:	e8 31 e9 ff ff       	call   809f9b <sys_sem_signal>
  80b66a:	83 c4 10             	add    $0x10,%esp
  80b66d:	eb 06                	jmp    80b675 <do_writemore+0x13c>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80b66f:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b673:	eb a4                	jmp    80b619 <do_writemore+0xe0>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b675:	b8 00 00 00 00       	mov    $0x0,%eax
  80b67a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b67d:	5b                   	pop    %ebx
  80b67e:	5e                   	pop    %esi
  80b67f:	5f                   	pop    %edi
  80b680:	5d                   	pop    %ebp
  80b681:	c3                   	ret    

0080b682 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80b682:	55                   	push   %ebp
  80b683:	89 e5                	mov    %esp,%ebp
  80b685:	53                   	push   %ebx
  80b686:	83 ec 04             	sub    $0x4,%esp
  80b689:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b68b:	85 c0                	test   %eax,%eax
  80b68d:	75 17                	jne    80b6a6 <do_close_internal+0x24>
  80b68f:	83 ec 04             	sub    $0x4,%esp
  80b692:	68 88 2c 81 00       	push   $0x812c88
  80b697:	68 53 02 00 00       	push   $0x253
  80b69c:	68 1a 2e 81 00       	push   $0x812e1a
  80b6a1:	e8 3b 2d 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b6a6:	83 38 10             	cmpl   $0x10,(%eax)
  80b6a9:	74 17                	je     80b6c2 <do_close_internal+0x40>
  80b6ab:	83 ec 04             	sub    $0x4,%esp
  80b6ae:	68 b5 2e 81 00       	push   $0x812eb5
  80b6b3:	68 54 02 00 00       	push   $0x254
  80b6b8:	68 1a 2e 81 00       	push   $0x812e1a
  80b6bd:	e8 1f 2d 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b6c2:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b6c6:	74 17                	je     80b6df <do_close_internal+0x5d>
  80b6c8:	83 ec 04             	sub    $0x4,%esp
  80b6cb:	68 58 2d 81 00       	push   $0x812d58
  80b6d0:	68 55 02 00 00       	push   $0x255
  80b6d5:	68 1a 2e 81 00       	push   $0x812e1a
  80b6da:	e8 02 2d 00 00       	call   80e3e1 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b6df:	8b 40 08             	mov    0x8(%eax),%eax
  80b6e2:	85 c0                	test   %eax,%eax
  80b6e4:	75 17                	jne    80b6fd <do_close_internal+0x7b>
  80b6e6:	83 ec 04             	sub    $0x4,%esp
  80b6e9:	68 d3 2e 81 00       	push   $0x812ed3
  80b6ee:	68 56 02 00 00       	push   $0x256
  80b6f3:	68 1a 2e 81 00       	push   $0x812e1a
  80b6f8:	e8 e4 2c 00 00       	call   80e3e1 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80b6fd:	83 ec 08             	sub    $0x8,%esp
  80b700:	6a 00                	push   $0x0
  80b702:	50                   	push   %eax
  80b703:	e8 f5 a0 ff ff       	call   8057fd <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b708:	8b 43 08             	mov    0x8(%ebx),%eax
  80b70b:	83 c4 10             	add    $0x10,%esp
  80b70e:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b712:	75 10                	jne    80b724 <do_close_internal+0xa2>
    tcp_accept(conn->pcb.tcp, NULL);
  80b714:	83 ec 08             	sub    $0x8,%esp
  80b717:	6a 00                	push   $0x0
  80b719:	50                   	push   %eax
  80b71a:	e8 1f a1 ff ff       	call   80583e <tcp_accept>
  80b71f:	83 c4 10             	add    $0x10,%esp
  80b722:	eb 44                	jmp    80b768 <do_close_internal+0xe6>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80b724:	83 ec 08             	sub    $0x8,%esp
  80b727:	6a 00                	push   $0x0
  80b729:	50                   	push   %eax
  80b72a:	e8 dc a0 ff ff       	call   80580b <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b72f:	83 c4 08             	add    $0x8,%esp
  80b732:	6a 00                	push   $0x0
  80b734:	ff 73 08             	pushl  0x8(%ebx)
  80b737:	e8 02 a1 ff ff       	call   80583e <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80b73c:	83 c4 08             	add    $0x8,%esp
  80b73f:	6a 00                	push   $0x0
  80b741:	ff 73 08             	pushl  0x8(%ebx)
  80b744:	e8 d3 a0 ff ff       	call   80581c <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b749:	83 c4 0c             	add    $0xc,%esp
  80b74c:	6a 04                	push   $0x4
  80b74e:	6a 00                	push   $0x0
  80b750:	ff 73 08             	pushl  0x8(%ebx)
  80b753:	e8 f4 a0 ff ff       	call   80584c <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b758:	83 c4 08             	add    $0x8,%esp
  80b75b:	6a 00                	push   $0x0
  80b75d:	ff 73 08             	pushl  0x8(%ebx)
  80b760:	e8 c8 a0 ff ff       	call   80582d <tcp_err>
  80b765:	83 c4 10             	add    $0x10,%esp
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80b768:	83 ec 0c             	sub    $0xc,%esp
  80b76b:	ff 73 08             	pushl  0x8(%ebx)
  80b76e:	e8 68 a2 ff ff       	call   8059db <tcp_close>
  if (err == ERR_OK) {
  80b773:	83 c4 10             	add    $0x10,%esp
  80b776:	84 c0                	test   %al,%al
  80b778:	75 4a                	jne    80b7c4 <do_close_internal+0x142>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80b77a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80b781:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b788:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b78c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b78f:	85 c0                	test   %eax,%eax
  80b791:	74 21                	je     80b7b4 <do_close_internal+0x132>
  80b793:	83 ec 04             	sub    $0x4,%esp
  80b796:	6a 00                	push   $0x0
  80b798:	6a 00                	push   $0x0
  80b79a:	53                   	push   %ebx
  80b79b:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b79d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7a0:	83 c4 10             	add    $0x10,%esp
  80b7a3:	85 c0                	test   %eax,%eax
  80b7a5:	74 0d                	je     80b7b4 <do_close_internal+0x132>
  80b7a7:	83 ec 04             	sub    $0x4,%esp
  80b7aa:	6a 00                	push   $0x0
  80b7ac:	6a 02                	push   $0x2
  80b7ae:	53                   	push   %ebx
  80b7af:	ff d0                	call   *%eax
  80b7b1:	83 c4 10             	add    $0x10,%esp
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80b7b4:	83 ec 0c             	sub    $0xc,%esp
  80b7b7:	ff 73 10             	pushl  0x10(%ebx)
  80b7ba:	e8 dc e7 ff ff       	call   809f9b <sys_sem_signal>
  80b7bf:	83 c4 10             	add    $0x10,%esp
  80b7c2:	eb 5f                	jmp    80b823 <do_close_internal+0x1a1>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b7c4:	8b 43 08             	mov    0x8(%ebx),%eax
  80b7c7:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b7cb:	75 17                	jne    80b7e4 <do_close_internal+0x162>
  80b7cd:	83 ec 04             	sub    $0x4,%esp
  80b7d0:	68 7c 2d 81 00       	push   $0x812d7c
  80b7d5:	68 75 02 00 00       	push   $0x275
  80b7da:	68 1a 2e 81 00       	push   $0x812e1a
  80b7df:	e8 fd 2b 00 00       	call   80e3e1 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b7e4:	83 ec 08             	sub    $0x8,%esp
  80b7e7:	68 6c b8 80 00       	push   $0x80b86c
  80b7ec:	50                   	push   %eax
  80b7ed:	e8 2a a0 ff ff       	call   80581c <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b7f2:	83 c4 0c             	add    $0xc,%esp
  80b7f5:	6a 04                	push   $0x4
  80b7f7:	68 28 b8 80 00       	push   $0x80b828
  80b7fc:	ff 73 08             	pushl  0x8(%ebx)
  80b7ff:	e8 48 a0 ff ff       	call   80584c <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b804:	83 c4 08             	add    $0x8,%esp
  80b807:	68 6b b4 80 00       	push   $0x80b46b
  80b80c:	ff 73 08             	pushl  0x8(%ebx)
  80b80f:	e8 19 a0 ff ff       	call   80582d <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b814:	83 c4 08             	add    $0x8,%esp
  80b817:	53                   	push   %ebx
  80b818:	ff 73 08             	pushl  0x8(%ebx)
  80b81b:	e8 dd 9f ff ff       	call   8057fd <tcp_arg>
  80b820:	83 c4 10             	add    $0x10,%esp
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80b823:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b826:	c9                   	leave  
  80b827:	c3                   	ret    

0080b828 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80b828:	55                   	push   %ebp
  80b829:	89 e5                	mov    %esp,%ebp
  80b82b:	83 ec 08             	sub    $0x8,%esp
  80b82e:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b831:	85 c0                	test   %eax,%eax
  80b833:	75 17                	jne    80b84c <poll_tcp+0x24>
  80b835:	83 ec 04             	sub    $0x4,%esp
  80b838:	68 6d 2e 81 00       	push   $0x812e6d
  80b83d:	68 eb 00 00 00       	push   $0xeb
  80b842:	68 1a 2e 81 00       	push   $0x812e1a
  80b847:	e8 95 2b 00 00       	call   80e3e1 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b84c:	8b 50 04             	mov    0x4(%eax),%edx
  80b84f:	83 fa 01             	cmp    $0x1,%edx
  80b852:	75 07                	jne    80b85b <poll_tcp+0x33>
    do_writemore(conn);
  80b854:	e8 e0 fc ff ff       	call   80b539 <do_writemore>
  80b859:	eb 0a                	jmp    80b865 <poll_tcp+0x3d>
  } else if (conn->state == NETCONN_CLOSE) {
  80b85b:	83 fa 04             	cmp    $0x4,%edx
  80b85e:	75 05                	jne    80b865 <poll_tcp+0x3d>
    do_close_internal(conn);
  80b860:	e8 1d fe ff ff       	call   80b682 <do_close_internal>
  }

  return ERR_OK;
}
  80b865:	b8 00 00 00 00       	mov    $0x0,%eax
  80b86a:	c9                   	leave  
  80b86b:	c3                   	ret    

0080b86c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80b86c:	55                   	push   %ebp
  80b86d:	89 e5                	mov    %esp,%ebp
  80b86f:	56                   	push   %esi
  80b870:	53                   	push   %ebx
  80b871:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b874:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b877:	85 db                	test   %ebx,%ebx
  80b879:	75 17                	jne    80b892 <sent_tcp+0x26>
  80b87b:	83 ec 04             	sub    $0x4,%esp
  80b87e:	68 6d 2e 81 00       	push   $0x812e6d
  80b883:	68 03 01 00 00       	push   $0x103
  80b888:	68 1a 2e 81 00       	push   $0x812e1a
  80b88d:	e8 4f 2b 00 00       	call   80e3e1 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b892:	8b 43 04             	mov    0x4(%ebx),%eax
  80b895:	83 f8 01             	cmp    $0x1,%eax
  80b898:	75 26                	jne    80b8c0 <sent_tcp+0x54>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b89a:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b89e:	75 17                	jne    80b8b7 <sent_tcp+0x4b>
  80b8a0:	83 ec 04             	sub    $0x4,%esp
  80b8a3:	68 e6 2e 81 00       	push   $0x812ee6
  80b8a8:	68 06 01 00 00       	push   $0x106
  80b8ad:	68 1a 2e 81 00       	push   $0x812e1a
  80b8b2:	e8 2a 2b 00 00       	call   80e3e1 <_panic>
    do_writemore(conn);
  80b8b7:	89 d8                	mov    %ebx,%eax
  80b8b9:	e8 7b fc ff ff       	call   80b539 <do_writemore>
  80b8be:	eb 2e                	jmp    80b8ee <sent_tcp+0x82>
  } else if (conn->state == NETCONN_CLOSE) {
  80b8c0:	83 f8 04             	cmp    $0x4,%eax
  80b8c3:	75 29                	jne    80b8ee <sent_tcp+0x82>
    do_close_internal(conn);
  80b8c5:	89 d8                	mov    %ebx,%eax
  80b8c7:	e8 b6 fd ff ff       	call   80b682 <do_close_internal>
  80b8cc:	eb 20                	jmp    80b8ee <sent_tcp+0x82>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b8ce:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b8d4:	76 1f                	jbe    80b8f5 <sent_tcp+0x89>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b8d6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8d9:	85 c0                	test   %eax,%eax
  80b8db:	74 18                	je     80b8f5 <sent_tcp+0x89>
  80b8dd:	83 ec 04             	sub    $0x4,%esp
  80b8e0:	0f b7 f6             	movzwl %si,%esi
  80b8e3:	56                   	push   %esi
  80b8e4:	6a 02                	push   $0x2
  80b8e6:	53                   	push   %ebx
  80b8e7:	ff d0                	call   *%eax
  80b8e9:	83 c4 10             	add    $0x10,%esp
  80b8ec:	eb 07                	jmp    80b8f5 <sent_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b8ee:	8b 43 08             	mov    0x8(%ebx),%eax
  80b8f1:	85 c0                	test   %eax,%eax
  80b8f3:	75 d9                	jne    80b8ce <sent_tcp+0x62>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80b8f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b8fd:	5b                   	pop    %ebx
  80b8fe:	5e                   	pop    %esi
  80b8ff:	5d                   	pop    %ebp
  80b900:	c3                   	ret    

0080b901 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80b901:	55                   	push   %ebp
  80b902:	89 e5                	mov    %esp,%ebp
  80b904:	56                   	push   %esi
  80b905:	53                   	push   %ebx
  80b906:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b909:	8b 03                	mov    (%ebx),%eax
  80b90b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b90f:	0f 85 ce 00 00 00    	jne    80b9e3 <do_newconn+0xe2>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80b915:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80b919:	8b 33                	mov    (%ebx),%esi
  80b91b:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80b91f:	74 17                	je     80b938 <do_newconn+0x37>
  80b921:	83 ec 04             	sub    $0x4,%esp
  80b924:	68 a0 2d 81 00       	push   $0x812da0
  80b929:	68 8a 01 00 00       	push   $0x18a
  80b92e:	68 1a 2e 81 00       	push   $0x812e1a
  80b933:	e8 a9 2a 00 00       	call   80e3e1 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80b938:	8b 06                	mov    (%esi),%eax
  80b93a:	25 f0 00 00 00       	and    $0xf0,%eax
  80b93f:	83 f8 20             	cmp    $0x20,%eax
  80b942:	74 46                	je     80b98a <do_newconn+0x89>
  80b944:	83 f8 40             	cmp    $0x40,%eax
  80b947:	74 0b                	je     80b954 <do_newconn+0x53>
  80b949:	83 f8 10             	cmp    $0x10,%eax
  80b94c:	0f 85 8d 00 00 00    	jne    80b9df <do_newconn+0xde>
  80b952:	eb 6e                	jmp    80b9c2 <do_newconn+0xc1>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80b954:	83 ec 0c             	sub    $0xc,%esp
  80b957:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80b95b:	50                   	push   %eax
  80b95c:	e8 05 25 00 00       	call   80de66 <raw_new>
  80b961:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80b964:	8b 03                	mov    (%ebx),%eax
  80b966:	8b 50 08             	mov    0x8(%eax),%edx
  80b969:	83 c4 10             	add    $0x10,%esp
  80b96c:	85 d2                	test   %edx,%edx
  80b96e:	75 06                	jne    80b976 <do_newconn+0x75>
       msg->conn->err = ERR_MEM;
  80b970:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b974:	eb 6d                	jmp    80b9e3 <do_newconn+0xe2>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80b976:	83 ec 04             	sub    $0x4,%esp
  80b979:	50                   	push   %eax
  80b97a:	68 e5 b2 80 00       	push   $0x80b2e5
  80b97f:	52                   	push   %edx
  80b980:	e8 61 23 00 00       	call   80dce6 <raw_recv>
  80b985:	83 c4 10             	add    $0x10,%esp
  80b988:	eb 59                	jmp    80b9e3 <do_newconn+0xe2>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80b98a:	e8 96 d5 ff ff       	call   808f25 <udp_new>
  80b98f:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80b992:	8b 03                	mov    (%ebx),%eax
  80b994:	8b 50 08             	mov    0x8(%eax),%edx
  80b997:	85 d2                	test   %edx,%edx
  80b999:	75 06                	jne    80b9a1 <do_newconn+0xa0>
       msg->conn->err = ERR_MEM;
  80b99b:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b99f:	eb 42                	jmp    80b9e3 <do_newconn+0xe2>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80b9a1:	83 38 22             	cmpl   $0x22,(%eax)
  80b9a4:	75 04                	jne    80b9aa <do_newconn+0xa9>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80b9a6:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80b9aa:	8b 03                	mov    (%ebx),%eax
  80b9ac:	83 ec 04             	sub    $0x4,%esp
  80b9af:	50                   	push   %eax
  80b9b0:	68 ed b1 80 00       	push   $0x80b1ed
  80b9b5:	ff 70 08             	pushl  0x8(%eax)
  80b9b8:	e8 10 d5 ff ff       	call   808ecd <udp_recv>
  80b9bd:	83 c4 10             	add    $0x10,%esp
  80b9c0:	eb 21                	jmp    80b9e3 <do_newconn+0xe2>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80b9c2:	e8 b8 a8 ff ff       	call   80627f <tcp_new>
  80b9c7:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80b9ca:	8b 03                	mov    (%ebx),%eax
  80b9cc:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b9d0:	75 06                	jne    80b9d8 <do_newconn+0xd7>
       msg->conn->err = ERR_MEM;
  80b9d2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b9d6:	eb 0b                	jmp    80b9e3 <do_newconn+0xe2>
       break;
     }
     setup_tcp(msg->conn);
  80b9d8:	e8 f1 f9 ff ff       	call   80b3ce <setup_tcp>
  80b9dd:	eb 04                	jmp    80b9e3 <do_newconn+0xe2>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80b9df:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80b9e3:	83 ec 0c             	sub    $0xc,%esp
  80b9e6:	8b 03                	mov    (%ebx),%eax
  80b9e8:	ff 70 10             	pushl  0x10(%eax)
  80b9eb:	e8 ab e5 ff ff       	call   809f9b <sys_sem_signal>
  80b9f0:	83 c4 10             	add    $0x10,%esp
}
  80b9f3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b9f6:	5b                   	pop    %ebx
  80b9f7:	5e                   	pop    %esi
  80b9f8:	5d                   	pop    %ebp
  80b9f9:	c3                   	ret    

0080b9fa <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80b9fa:	55                   	push   %ebp
  80b9fb:	89 e5                	mov    %esp,%ebp
  80b9fd:	53                   	push   %ebx
  80b9fe:	83 ec 10             	sub    $0x10,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80ba01:	6a 07                	push   $0x7
  80ba03:	e8 1e 8a ff ff       	call   804426 <memp_malloc>
  80ba08:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80ba0a:	83 c4 10             	add    $0x10,%esp
  80ba0d:	85 c0                	test   %eax,%eax
  80ba0f:	0f 84 94 00 00 00    	je     80baa9 <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80ba15:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80ba19:	8b 45 08             	mov    0x8(%ebp),%eax
  80ba1c:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80ba1e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80ba25:	83 ec 0c             	sub    $0xc,%esp
  80ba28:	6a 00                	push   $0x0
  80ba2a:	e8 bb e2 ff ff       	call   809cea <sys_sem_new>
  80ba2f:	89 43 10             	mov    %eax,0x10(%ebx)
  80ba32:	83 c4 10             	add    $0x10,%esp
  80ba35:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ba38:	75 15                	jne    80ba4f <netconn_alloc+0x55>
    memp_free(MEMP_NETCONN, conn);
  80ba3a:	83 ec 08             	sub    $0x8,%esp
  80ba3d:	53                   	push   %ebx
  80ba3e:	6a 07                	push   $0x7
  80ba40:	e8 37 8a ff ff       	call   80447c <memp_free>
    return NULL;
  80ba45:	83 c4 10             	add    $0x10,%esp
  80ba48:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba4d:	eb 5f                	jmp    80baae <netconn_alloc+0xb4>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80ba4f:	83 ec 0c             	sub    $0xc,%esp
  80ba52:	6a 00                	push   $0x0
  80ba54:	e8 3f e4 ff ff       	call   809e98 <sys_mbox_new>
  80ba59:	89 43 14             	mov    %eax,0x14(%ebx)
  80ba5c:	83 c4 10             	add    $0x10,%esp
  80ba5f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ba62:	75 20                	jne    80ba84 <netconn_alloc+0x8a>
    sys_sem_free(conn->op_completed);
  80ba64:	83 ec 0c             	sub    $0xc,%esp
  80ba67:	ff 73 10             	pushl  0x10(%ebx)
  80ba6a:	e8 fc e2 ff ff       	call   809d6b <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80ba6f:	83 c4 08             	add    $0x8,%esp
  80ba72:	53                   	push   %ebx
  80ba73:	6a 07                	push   $0x7
  80ba75:	e8 02 8a ff ff       	call   80447c <memp_free>
    return NULL;
  80ba7a:	83 c4 10             	add    $0x10,%esp
  80ba7d:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba82:	eb 2a                	jmp    80baae <netconn_alloc+0xb4>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80ba84:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80ba8b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80ba92:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80ba99:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ba9c:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80ba9f:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80baa5:	89 d8                	mov    %ebx,%eax
  80baa7:	eb 05                	jmp    80baae <netconn_alloc+0xb4>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80baa9:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80baae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bab1:	c9                   	leave  
  80bab2:	c3                   	ret    

0080bab3 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80bab3:	55                   	push   %ebp
  80bab4:	89 e5                	mov    %esp,%ebp
  80bab6:	56                   	push   %esi
  80bab7:	53                   	push   %ebx
  80bab8:	83 ec 10             	sub    $0x10,%esp
  80babb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80babe:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bac2:	74 17                	je     80badb <netconn_free+0x28>
  80bac4:	83 ec 04             	sub    $0x4,%esp
  80bac7:	68 c0 2d 81 00       	push   $0x812dc0
  80bacc:	68 26 02 00 00       	push   $0x226
  80bad1:	68 1a 2e 81 00       	push   $0x812e1a
  80bad6:	e8 06 29 00 00       	call   80e3e1 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80badb:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bade:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bae2:	75 2a                	jne    80bb0e <netconn_free+0x5b>
  80bae4:	eb 51                	jmp    80bb37 <netconn_free+0x84>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80bae6:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bae9:	75 15                	jne    80bb00 <netconn_free+0x4d>
        if(mem != NULL) {
  80baeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80baee:	85 c0                	test   %eax,%eax
  80baf0:	74 1c                	je     80bb0e <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80baf2:	83 ec 0c             	sub    $0xc,%esp
  80baf5:	50                   	push   %eax
  80baf6:	e8 f4 8c ff ff       	call   8047ef <pbuf_free>
  80bafb:	83 c4 10             	add    $0x10,%esp
  80bafe:	eb 0e                	jmp    80bb0e <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80bb00:	83 ec 0c             	sub    $0xc,%esp
  80bb03:	ff 75 f4             	pushl  -0xc(%ebp)
  80bb06:	e8 bd 69 ff ff       	call   8024c8 <netbuf_delete>
  80bb0b:	83 c4 10             	add    $0x10,%esp
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb0e:	83 ec 08             	sub    $0x8,%esp
  80bb11:	56                   	push   %esi
  80bb12:	ff 73 14             	pushl  0x14(%ebx)
  80bb15:	e8 db e7 ff ff       	call   80a2f5 <sys_arch_mbox_tryfetch>
  80bb1a:	83 c4 10             	add    $0x10,%esp
  80bb1d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb20:	75 c4                	jne    80bae6 <netconn_free+0x33>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80bb22:	83 ec 0c             	sub    $0xc,%esp
  80bb25:	ff 73 14             	pushl  0x14(%ebx)
  80bb28:	e8 c7 e2 ff ff       	call   809df4 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bb2d:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bb34:	83 c4 10             	add    $0x10,%esp
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb37:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bb3a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bb3e:	75 10                	jne    80bb50 <netconn_free+0x9d>
  80bb40:	eb 37                	jmp    80bb79 <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80bb42:	83 ec 0c             	sub    $0xc,%esp
  80bb45:	ff 75 f4             	pushl  -0xc(%ebp)
  80bb48:	e8 85 f0 ff ff       	call   80abd2 <netconn_delete>
  80bb4d:	83 c4 10             	add    $0x10,%esp
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bb50:	83 ec 08             	sub    $0x8,%esp
  80bb53:	56                   	push   %esi
  80bb54:	ff 73 18             	pushl  0x18(%ebx)
  80bb57:	e8 99 e7 ff ff       	call   80a2f5 <sys_arch_mbox_tryfetch>
  80bb5c:	83 c4 10             	add    $0x10,%esp
  80bb5f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb62:	75 de                	jne    80bb42 <netconn_free+0x8f>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80bb64:	83 ec 0c             	sub    $0xc,%esp
  80bb67:	ff 73 18             	pushl  0x18(%ebx)
  80bb6a:	e8 85 e2 ff ff       	call   809df4 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bb6f:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bb76:	83 c4 10             	add    $0x10,%esp
  }

  sys_sem_free(conn->op_completed);
  80bb79:	83 ec 0c             	sub    $0xc,%esp
  80bb7c:	ff 73 10             	pushl  0x10(%ebx)
  80bb7f:	e8 e7 e1 ff ff       	call   809d6b <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bb84:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80bb8b:	83 c4 08             	add    $0x8,%esp
  80bb8e:	53                   	push   %ebx
  80bb8f:	6a 07                	push   $0x7
  80bb91:	e8 e6 88 ff ff       	call   80447c <memp_free>
  80bb96:	83 c4 10             	add    $0x10,%esp
}
  80bb99:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bb9c:	5b                   	pop    %ebx
  80bb9d:	5e                   	pop    %esi
  80bb9e:	5d                   	pop    %ebp
  80bb9f:	c3                   	ret    

0080bba0 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80bba0:	55                   	push   %ebp
  80bba1:	89 e5                	mov    %esp,%ebp
  80bba3:	57                   	push   %edi
  80bba4:	56                   	push   %esi
  80bba5:	53                   	push   %ebx
  80bba6:	83 ec 0c             	sub    $0xc,%esp
  80bba9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bbac:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bbaf:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bbb3:	75 17                	jne    80bbcc <accept_function+0x2c>
  80bbb5:	83 ec 04             	sub    $0x4,%esp
  80bbb8:	68 f0 2d 81 00       	push   $0x812df0
  80bbbd:	68 65 01 00 00       	push   $0x165
  80bbc2:	68 1a 2e 81 00       	push   $0x812e1a
  80bbc7:	e8 15 28 00 00       	call   80e3e1 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80bbcc:	83 ec 08             	sub    $0x8,%esp
  80bbcf:	ff 73 2c             	pushl  0x2c(%ebx)
  80bbd2:	ff 33                	pushl  (%ebx)
  80bbd4:	e8 21 fe ff ff       	call   80b9fa <netconn_alloc>
  80bbd9:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bbdb:	83 c4 10             	add    $0x10,%esp
  80bbde:	85 c0                	test   %eax,%eax
  80bbe0:	74 53                	je     80bc35 <accept_function+0x95>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80bbe2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bbe5:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bbe8:	89 f0                	mov    %esi,%eax
  80bbea:	e8 df f7 ff ff       	call   80b3ce <setup_tcp>
  newconn->err = err;
  80bbef:	89 f8                	mov    %edi,%eax
  80bbf1:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bbf4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bbf7:	85 c0                	test   %eax,%eax
  80bbf9:	74 0d                	je     80bc08 <accept_function+0x68>
  80bbfb:	83 ec 04             	sub    $0x4,%esp
  80bbfe:	6a 00                	push   $0x0
  80bc00:	6a 00                	push   $0x0
  80bc02:	53                   	push   %ebx
  80bc03:	ff d0                	call   *%eax
  80bc05:	83 c4 10             	add    $0x10,%esp

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bc08:	83 ec 08             	sub    $0x8,%esp
  80bc0b:	56                   	push   %esi
  80bc0c:	ff 73 18             	pushl  0x18(%ebx)
  80bc0f:	e8 02 e5 ff ff       	call   80a116 <sys_mbox_trypost>
  80bc14:	83 c4 10             	add    $0x10,%esp
  80bc17:	84 c0                	test   %al,%al
  80bc19:	74 1f                	je     80bc3a <accept_function+0x9a>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80bc1b:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bc22:	83 ec 0c             	sub    $0xc,%esp
  80bc25:	56                   	push   %esi
  80bc26:	e8 88 fe ff ff       	call   80bab3 <netconn_free>
    return ERR_MEM;
  80bc2b:	83 c4 10             	add    $0x10,%esp
  80bc2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bc33:	eb 05                	jmp    80bc3a <accept_function+0x9a>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80bc35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
}
  80bc3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bc3d:	5b                   	pop    %ebx
  80bc3e:	5e                   	pop    %esi
  80bc3f:	5f                   	pop    %edi
  80bc40:	5d                   	pop    %ebp
  80bc41:	c3                   	ret    

0080bc42 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80bc42:	55                   	push   %ebp
  80bc43:	89 e5                	mov    %esp,%ebp
  80bc45:	53                   	push   %ebx
  80bc46:	83 ec 04             	sub    $0x4,%esp
  80bc49:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bc4c:	8b 13                	mov    (%ebx),%edx
  80bc4e:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bc51:	85 c9                	test   %ecx,%ecx
  80bc53:	74 4f                	je     80bca4 <do_delconn+0x62>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bc55:	8b 02                	mov    (%edx),%eax
  80bc57:	25 f0 00 00 00       	and    $0xf0,%eax
  80bc5c:	83 f8 20             	cmp    $0x20,%eax
  80bc5f:	74 1a                	je     80bc7b <do_delconn+0x39>
  80bc61:	83 f8 40             	cmp    $0x40,%eax
  80bc64:	74 07                	je     80bc6d <do_delconn+0x2b>
  80bc66:	83 f8 10             	cmp    $0x10,%eax
  80bc69:	75 39                	jne    80bca4 <do_delconn+0x62>
  80bc6b:	eb 27                	jmp    80bc94 <do_delconn+0x52>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80bc6d:	83 ec 0c             	sub    $0xc,%esp
  80bc70:	51                   	push   %ecx
  80bc71:	e8 ac 21 00 00       	call   80de22 <raw_remove>
      break;
  80bc76:	83 c4 10             	add    $0x10,%esp
  80bc79:	eb 29                	jmp    80bca4 <do_delconn+0x62>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80bc7b:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bc82:	83 ec 0c             	sub    $0xc,%esp
  80bc85:	8b 03                	mov    (%ebx),%eax
  80bc87:	ff 70 08             	pushl  0x8(%eax)
  80bc8a:	e8 52 d2 ff ff       	call   808ee1 <udp_remove>
      break;
  80bc8f:	83 c4 10             	add    $0x10,%esp
  80bc92:	eb 10                	jmp    80bca4 <do_delconn+0x62>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80bc94:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bc9b:	8b 03                	mov    (%ebx),%eax
  80bc9d:	e8 e0 f9 ff ff       	call   80b682 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80bca2:	eb 42                	jmp    80bce6 <do_delconn+0xa4>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bca4:	8b 13                	mov    (%ebx),%edx
  80bca6:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bca9:	85 c0                	test   %eax,%eax
  80bcab:	74 23                	je     80bcd0 <do_delconn+0x8e>
  80bcad:	83 ec 04             	sub    $0x4,%esp
  80bcb0:	6a 00                	push   $0x0
  80bcb2:	6a 00                	push   $0x0
  80bcb4:	52                   	push   %edx
  80bcb5:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bcb7:	8b 13                	mov    (%ebx),%edx
  80bcb9:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bcbc:	83 c4 10             	add    $0x10,%esp
  80bcbf:	85 c0                	test   %eax,%eax
  80bcc1:	74 0d                	je     80bcd0 <do_delconn+0x8e>
  80bcc3:	83 ec 04             	sub    $0x4,%esp
  80bcc6:	6a 00                	push   $0x0
  80bcc8:	6a 02                	push   $0x2
  80bcca:	52                   	push   %edx
  80bccb:	ff d0                	call   *%eax
  80bccd:	83 c4 10             	add    $0x10,%esp

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bcd0:	8b 03                	mov    (%ebx),%eax
  80bcd2:	8b 40 10             	mov    0x10(%eax),%eax
  80bcd5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bcd8:	74 0c                	je     80bce6 <do_delconn+0xa4>
    sys_sem_signal(msg->conn->op_completed);
  80bcda:	83 ec 0c             	sub    $0xc,%esp
  80bcdd:	50                   	push   %eax
  80bcde:	e8 b8 e2 ff ff       	call   809f9b <sys_sem_signal>
  80bce3:	83 c4 10             	add    $0x10,%esp
  }
}
  80bce6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bce9:	c9                   	leave  
  80bcea:	c3                   	ret    

0080bceb <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80bceb:	55                   	push   %ebp
  80bcec:	89 e5                	mov    %esp,%ebp
  80bcee:	56                   	push   %esi
  80bcef:	53                   	push   %ebx
  80bcf0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bcf3:	8b 33                	mov    (%ebx),%esi
  80bcf5:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bcf9:	7c 69                	jl     80bd64 <do_bind+0x79>
    if (msg->conn->pcb.tcp != NULL) {
  80bcfb:	8b 56 08             	mov    0x8(%esi),%edx
  80bcfe:	85 d2                	test   %edx,%edx
  80bd00:	74 5e                	je     80bd60 <do_bind+0x75>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd02:	8b 06                	mov    (%esi),%eax
  80bd04:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd09:	83 f8 20             	cmp    $0x20,%eax
  80bd0c:	74 20                	je     80bd2e <do_bind+0x43>
  80bd0e:	83 f8 40             	cmp    $0x40,%eax
  80bd11:	74 07                	je     80bd1a <do_bind+0x2f>
  80bd13:	83 f8 10             	cmp    $0x10,%eax
  80bd16:	75 4c                	jne    80bd64 <do_bind+0x79>
  80bd18:	eb 2d                	jmp    80bd47 <do_bind+0x5c>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bd1a:	83 ec 08             	sub    $0x8,%esp
  80bd1d:	ff 73 04             	pushl  0x4(%ebx)
  80bd20:	52                   	push   %edx
  80bd21:	e8 81 1f 00 00       	call   80dca7 <raw_bind>
  80bd26:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd29:	83 c4 10             	add    $0x10,%esp
  80bd2c:	eb 36                	jmp    80bd64 <do_bind+0x79>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd2e:	83 ec 04             	sub    $0x4,%esp
  80bd31:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd35:	50                   	push   %eax
  80bd36:	ff 73 04             	pushl  0x4(%ebx)
  80bd39:	52                   	push   %edx
  80bd3a:	e8 4d ce ff ff       	call   808b8c <udp_bind>
  80bd3f:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd42:	83 c4 10             	add    $0x10,%esp
  80bd45:	eb 1d                	jmp    80bd64 <do_bind+0x79>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd47:	83 ec 04             	sub    $0x4,%esp
  80bd4a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd4e:	50                   	push   %eax
  80bd4f:	ff 73 04             	pushl  0x4(%ebx)
  80bd52:	52                   	push   %edx
  80bd53:	e8 31 96 ff ff       	call   805389 <tcp_bind>
  80bd58:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bd5b:	83 c4 10             	add    $0x10,%esp
  80bd5e:	eb 04                	jmp    80bd64 <do_bind+0x79>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80bd60:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bd64:	83 ec 0c             	sub    $0xc,%esp
  80bd67:	8b 03                	mov    (%ebx),%eax
  80bd69:	ff 70 10             	pushl  0x10(%eax)
  80bd6c:	e8 2a e2 ff ff       	call   809f9b <sys_sem_signal>
  80bd71:	83 c4 10             	add    $0x10,%esp
}
  80bd74:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bd77:	5b                   	pop    %ebx
  80bd78:	5e                   	pop    %esi
  80bd79:	5d                   	pop    %ebp
  80bd7a:	c3                   	ret    

0080bd7b <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80bd7b:	55                   	push   %ebp
  80bd7c:	89 e5                	mov    %esp,%ebp
  80bd7e:	56                   	push   %esi
  80bd7f:	53                   	push   %ebx
  80bd80:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bd83:	8b 33                	mov    (%ebx),%esi
  80bd85:	8b 56 08             	mov    0x8(%esi),%edx
  80bd88:	85 d2                	test   %edx,%edx
  80bd8a:	75 13                	jne    80bd9f <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80bd8c:	83 ec 0c             	sub    $0xc,%esp
  80bd8f:	ff 76 10             	pushl  0x10(%esi)
  80bd92:	e8 04 e2 ff ff       	call   809f9b <sys_sem_signal>
    return;
  80bd97:	83 c4 10             	add    $0x10,%esp
  80bd9a:	e9 8a 00 00 00       	jmp    80be29 <do_connect+0xae>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd9f:	8b 06                	mov    (%esi),%eax
  80bda1:	25 f0 00 00 00       	and    $0xf0,%eax
  80bda6:	83 f8 20             	cmp    $0x20,%eax
  80bda9:	74 2d                	je     80bdd8 <do_connect+0x5d>
  80bdab:	83 f8 40             	cmp    $0x40,%eax
  80bdae:	74 07                	je     80bdb7 <do_connect+0x3c>
  80bdb0:	83 f8 10             	cmp    $0x10,%eax
  80bdb3:	75 74                	jne    80be29 <do_connect+0xae>
  80bdb5:	eb 47                	jmp    80bdfe <do_connect+0x83>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bdb7:	83 ec 08             	sub    $0x8,%esp
  80bdba:	ff 73 04             	pushl  0x4(%ebx)
  80bdbd:	52                   	push   %edx
  80bdbe:	e8 03 1f 00 00       	call   80dcc6 <raw_connect>
  80bdc3:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bdc6:	83 c4 04             	add    $0x4,%esp
  80bdc9:	8b 03                	mov    (%ebx),%eax
  80bdcb:	ff 70 10             	pushl  0x10(%eax)
  80bdce:	e8 c8 e1 ff ff       	call   809f9b <sys_sem_signal>
    break;
  80bdd3:	83 c4 10             	add    $0x10,%esp
  80bdd6:	eb 51                	jmp    80be29 <do_connect+0xae>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bdd8:	83 ec 04             	sub    $0x4,%esp
  80bddb:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bddf:	50                   	push   %eax
  80bde0:	ff 73 04             	pushl  0x4(%ebx)
  80bde3:	52                   	push   %edx
  80bde4:	e8 56 d0 ff ff       	call   808e3f <udp_connect>
  80bde9:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bdec:	83 c4 04             	add    $0x4,%esp
  80bdef:	8b 03                	mov    (%ebx),%eax
  80bdf1:	ff 70 10             	pushl  0x10(%eax)
  80bdf4:	e8 a2 e1 ff ff       	call   809f9b <sys_sem_signal>
    break;
  80bdf9:	83 c4 10             	add    $0x10,%esp
  80bdfc:	eb 2b                	jmp    80be29 <do_connect+0xae>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80bdfe:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80be05:	8b 03                	mov    (%ebx),%eax
  80be07:	e8 c2 f5 ff ff       	call   80b3ce <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80be0c:	8b 33                	mov    (%ebx),%esi
  80be0e:	68 21 b4 80 00       	push   $0x80b421
  80be13:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be17:	50                   	push   %eax
  80be18:	ff 73 04             	pushl  0x4(%ebx)
  80be1b:	ff 76 08             	pushl  0x8(%esi)
  80be1e:	e8 a4 a4 ff ff       	call   8062c7 <tcp_connect>
  80be23:	88 46 0c             	mov    %al,0xc(%esi)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  80be26:	83 c4 10             	add    $0x10,%esp
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80be29:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be2c:	5b                   	pop    %ebx
  80be2d:	5e                   	pop    %esi
  80be2e:	5d                   	pop    %ebp
  80be2f:	c3                   	ret    

0080be30 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80be30:	55                   	push   %ebp
  80be31:	89 e5                	mov    %esp,%ebp
  80be33:	53                   	push   %ebx
  80be34:	83 ec 04             	sub    $0x4,%esp
  80be37:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80be3a:	8b 13                	mov    (%ebx),%edx
  80be3c:	8b 02                	mov    (%edx),%eax
  80be3e:	25 f0 00 00 00       	and    $0xf0,%eax
  80be43:	83 f8 20             	cmp    $0x20,%eax
  80be46:	75 0e                	jne    80be56 <do_disconnect+0x26>
    udp_disconnect(msg->conn->pcb.udp);
  80be48:	83 ec 0c             	sub    $0xc,%esp
  80be4b:	ff 72 08             	pushl  0x8(%edx)
  80be4e:	e8 5f d0 ff ff       	call   808eb2 <udp_disconnect>
  80be53:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80be56:	83 ec 0c             	sub    $0xc,%esp
  80be59:	8b 03                	mov    (%ebx),%eax
  80be5b:	ff 70 10             	pushl  0x10(%eax)
  80be5e:	e8 38 e1 ff ff       	call   809f9b <sys_sem_signal>
  80be63:	83 c4 10             	add    $0x10,%esp
}
  80be66:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80be69:	c9                   	leave  
  80be6a:	c3                   	ret    

0080be6b <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80be6b:	55                   	push   %ebp
  80be6c:	89 e5                	mov    %esp,%ebp
  80be6e:	57                   	push   %edi
  80be6f:	56                   	push   %esi
  80be70:	53                   	push   %ebx
  80be71:	83 ec 0c             	sub    $0xc,%esp
  80be74:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80be77:	8b 03                	mov    (%ebx),%eax
  80be79:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80be7d:	0f 8c bc 00 00 00    	jl     80bf3f <do_listen+0xd4>
    if (msg->conn->pcb.tcp != NULL) {
  80be83:	8b 50 08             	mov    0x8(%eax),%edx
  80be86:	85 d2                	test   %edx,%edx
  80be88:	0f 84 b1 00 00 00    	je     80bf3f <do_listen+0xd4>
      if (msg->conn->type == NETCONN_TCP) {
  80be8e:	83 38 10             	cmpl   $0x10,(%eax)
  80be91:	0f 85 a8 00 00 00    	jne    80bf3f <do_listen+0xd4>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80be97:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80be9b:	0f 85 9a 00 00 00    	jne    80bf3b <do_listen+0xd0>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80bea1:	83 ec 08             	sub    $0x8,%esp
  80bea4:	68 ff 00 00 00       	push   $0xff
  80bea9:	52                   	push   %edx
  80beaa:	e8 6a 96 ff ff       	call   805519 <tcp_listen_with_backlog>
  80beaf:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80beb1:	83 c4 10             	add    $0x10,%esp
  80beb4:	85 c0                	test   %eax,%eax
  80beb6:	75 08                	jne    80bec0 <do_listen+0x55>
            msg->conn->err = ERR_MEM;
  80beb8:	8b 03                	mov    (%ebx),%eax
  80beba:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bebe:	eb 7f                	jmp    80bf3f <do_listen+0xd4>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80bec0:	8b 03                	mov    (%ebx),%eax
  80bec2:	8b 40 14             	mov    0x14(%eax),%eax
  80bec5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bec8:	74 15                	je     80bedf <do_listen+0x74>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80beca:	83 ec 0c             	sub    $0xc,%esp
  80becd:	50                   	push   %eax
  80bece:	e8 21 df ff ff       	call   809df4 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80bed3:	8b 03                	mov    (%ebx),%eax
  80bed5:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80bedc:	83 c4 10             	add    $0x10,%esp
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80bedf:	8b 3b                	mov    (%ebx),%edi
  80bee1:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80bee5:	75 1b                	jne    80bf02 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80bee7:	83 ec 0c             	sub    $0xc,%esp
  80beea:	6a 00                	push   $0x0
  80beec:	e8 a7 df ff ff       	call   809e98 <sys_mbox_new>
  80bef1:	89 47 18             	mov    %eax,0x18(%edi)
  80bef4:	83 c4 10             	add    $0x10,%esp
  80bef7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80befa:	75 06                	jne    80bf02 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80befc:	8b 03                	mov    (%ebx),%eax
  80befe:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80bf02:	8b 03                	mov    (%ebx),%eax
  80bf04:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bf08:	75 35                	jne    80bf3f <do_listen+0xd4>
              msg->conn->state = NETCONN_LISTEN;
  80bf0a:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80bf11:	8b 03                	mov    (%ebx),%eax
  80bf13:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80bf16:	8b 03                	mov    (%ebx),%eax
  80bf18:	83 ec 08             	sub    $0x8,%esp
  80bf1b:	50                   	push   %eax
  80bf1c:	ff 70 08             	pushl  0x8(%eax)
  80bf1f:	e8 d9 98 ff ff       	call   8057fd <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80bf24:	83 c4 08             	add    $0x8,%esp
  80bf27:	68 a0 bb 80 00       	push   $0x80bba0
  80bf2c:	8b 03                	mov    (%ebx),%eax
  80bf2e:	ff 70 08             	pushl  0x8(%eax)
  80bf31:	e8 08 99 ff ff       	call   80583e <tcp_accept>
  80bf36:	83 c4 10             	add    $0x10,%esp
  80bf39:	eb 04                	jmp    80bf3f <do_listen+0xd4>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80bf3b:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80bf3f:	83 ec 0c             	sub    $0xc,%esp
  80bf42:	8b 03                	mov    (%ebx),%eax
  80bf44:	ff 70 10             	pushl  0x10(%eax)
  80bf47:	e8 4f e0 ff ff       	call   809f9b <sys_sem_signal>
  80bf4c:	83 c4 10             	add    $0x10,%esp
}
  80bf4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf52:	5b                   	pop    %ebx
  80bf53:	5e                   	pop    %esi
  80bf54:	5f                   	pop    %edi
  80bf55:	5d                   	pop    %ebp
  80bf56:	c3                   	ret    

0080bf57 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80bf57:	55                   	push   %ebp
  80bf58:	89 e5                	mov    %esp,%ebp
  80bf5a:	57                   	push   %edi
  80bf5b:	56                   	push   %esi
  80bf5c:	53                   	push   %ebx
  80bf5d:	83 ec 0c             	sub    $0xc,%esp
  80bf60:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf63:	8b 1e                	mov    (%esi),%ebx
  80bf65:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80bf69:	7c 7a                	jl     80bfe5 <do_send+0x8e>
    if (msg->conn->pcb.tcp != NULL) {
  80bf6b:	8b 53 08             	mov    0x8(%ebx),%edx
  80bf6e:	85 d2                	test   %edx,%edx
  80bf70:	74 73                	je     80bfe5 <do_send+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bf72:	8b 03                	mov    (%ebx),%eax
  80bf74:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf79:	83 f8 20             	cmp    $0x20,%eax
  80bf7c:	74 36                	je     80bfb4 <do_send+0x5d>
  80bf7e:	83 f8 40             	cmp    $0x40,%eax
  80bf81:	75 62                	jne    80bfe5 <do_send+0x8e>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80bf83:	8b 46 04             	mov    0x4(%esi),%eax
  80bf86:	8b 48 08             	mov    0x8(%eax),%ecx
  80bf89:	85 c9                	test   %ecx,%ecx
  80bf8b:	75 13                	jne    80bfa0 <do_send+0x49>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80bf8d:	83 ec 08             	sub    $0x8,%esp
  80bf90:	ff 30                	pushl  (%eax)
  80bf92:	52                   	push   %edx
  80bf93:	e8 72 1e 00 00       	call   80de0a <raw_send>
  80bf98:	88 43 0c             	mov    %al,0xc(%ebx)
  80bf9b:	83 c4 10             	add    $0x10,%esp
  80bf9e:	eb 45                	jmp    80bfe5 <do_send+0x8e>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80bfa0:	83 ec 04             	sub    $0x4,%esp
  80bfa3:	51                   	push   %ecx
  80bfa4:	ff 30                	pushl  (%eax)
  80bfa6:	52                   	push   %edx
  80bfa7:	e8 4e 1d 00 00       	call   80dcfa <raw_sendto>
  80bfac:	88 43 0c             	mov    %al,0xc(%ebx)
  80bfaf:	83 c4 10             	add    $0x10,%esp
  80bfb2:	eb 31                	jmp    80bfe5 <do_send+0x8e>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80bfb4:	8b 46 04             	mov    0x4(%esi),%eax
  80bfb7:	8b 48 08             	mov    0x8(%eax),%ecx
  80bfba:	85 c9                	test   %ecx,%ecx
  80bfbc:	75 13                	jne    80bfd1 <do_send+0x7a>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80bfbe:	83 ec 08             	sub    $0x8,%esp
  80bfc1:	ff 30                	pushl  (%eax)
  80bfc3:	52                   	push   %edx
  80bfc4:	e8 59 ce ff ff       	call   808e22 <udp_send>
  80bfc9:	88 43 0c             	mov    %al,0xc(%ebx)
  80bfcc:	83 c4 10             	add    $0x10,%esp
  80bfcf:	eb 14                	jmp    80bfe5 <do_send+0x8e>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80bfd1:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80bfd5:	57                   	push   %edi
  80bfd6:	51                   	push   %ecx
  80bfd7:	ff 30                	pushl  (%eax)
  80bfd9:	52                   	push   %edx
  80bfda:	e8 03 ce ff ff       	call   808de2 <udp_sendto>
  80bfdf:	88 43 0c             	mov    %al,0xc(%ebx)
  80bfe2:	83 c4 10             	add    $0x10,%esp
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bfe5:	83 ec 0c             	sub    $0xc,%esp
  80bfe8:	8b 06                	mov    (%esi),%eax
  80bfea:	ff 70 10             	pushl  0x10(%eax)
  80bfed:	e8 a9 df ff ff       	call   809f9b <sys_sem_signal>
  80bff2:	83 c4 10             	add    $0x10,%esp
}
  80bff5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bff8:	5b                   	pop    %ebx
  80bff9:	5e                   	pop    %esi
  80bffa:	5f                   	pop    %edi
  80bffb:	5d                   	pop    %ebp
  80bffc:	c3                   	ret    

0080bffd <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80bffd:	55                   	push   %ebp
  80bffe:	89 e5                	mov    %esp,%ebp
  80c000:	53                   	push   %ebx
  80c001:	83 ec 04             	sub    $0x4,%esp
  80c004:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c007:	8b 03                	mov    (%ebx),%eax
  80c009:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c00d:	7c 1d                	jl     80c02c <do_recv+0x2f>
    if (msg->conn->pcb.tcp != NULL) {
  80c00f:	8b 50 08             	mov    0x8(%eax),%edx
  80c012:	85 d2                	test   %edx,%edx
  80c014:	74 16                	je     80c02c <do_recv+0x2f>
      if (msg->conn->type == NETCONN_TCP) {
  80c016:	83 38 10             	cmpl   $0x10,(%eax)
  80c019:	75 11                	jne    80c02c <do_recv+0x2f>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c01b:	83 ec 08             	sub    $0x8,%esp
  80c01e:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c022:	50                   	push   %eax
  80c023:	52                   	push   %edx
  80c024:	e8 15 96 ff ff       	call   80563e <tcp_recved>
  80c029:	83 c4 10             	add    $0x10,%esp
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80c02c:	83 ec 0c             	sub    $0xc,%esp
  80c02f:	8b 03                	mov    (%ebx),%eax
  80c031:	ff 70 10             	pushl  0x10(%eax)
  80c034:	e8 62 df ff ff       	call   809f9b <sys_sem_signal>
  80c039:	83 c4 10             	add    $0x10,%esp
}
  80c03c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c03f:	c9                   	leave  
  80c040:	c3                   	ret    

0080c041 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c041:	55                   	push   %ebp
  80c042:	89 e5                	mov    %esp,%ebp
  80c044:	83 ec 08             	sub    $0x8,%esp
  80c047:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c04a:	8b 02                	mov    (%edx),%eax
  80c04c:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c050:	7c 2d                	jl     80c07f <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c052:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c056:	74 23                	je     80c07b <do_write+0x3a>
  80c058:	83 38 10             	cmpl   $0x10,(%eax)
  80c05b:	75 1e                	jne    80c07b <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80c05d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80c064:	8b 02                	mov    (%edx),%eax
  80c066:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c069:	8b 02                	mov    (%edx),%eax
  80c06b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80c072:	8b 02                	mov    (%edx),%eax
  80c074:	e8 c0 f4 ff ff       	call   80b539 <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80c079:	eb 14                	jmp    80c08f <do_write+0x4e>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c07b:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c07f:	83 ec 0c             	sub    $0xc,%esp
  80c082:	8b 02                	mov    (%edx),%eax
  80c084:	ff 70 10             	pushl  0x10(%eax)
  80c087:	e8 0f df ff ff       	call   809f9b <sys_sem_signal>
  80c08c:	83 c4 10             	add    $0x10,%esp
}
  80c08f:	c9                   	leave  
  80c090:	c3                   	ret    

0080c091 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c091:	55                   	push   %ebp
  80c092:	89 e5                	mov    %esp,%ebp
  80c094:	83 ec 08             	sub    $0x8,%esp
  80c097:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c09a:	8b 08                	mov    (%eax),%ecx
  80c09c:	8b 51 08             	mov    0x8(%ecx),%edx
  80c09f:	85 d2                	test   %edx,%edx
  80c0a1:	0f 84 98 00 00 00    	je     80c13f <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c0a7:	8b 48 04             	mov    0x4(%eax),%ecx
  80c0aa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c0ae:	74 06                	je     80c0b6 <do_getaddr+0x25>
  80c0b0:	8b 12                	mov    (%edx),%edx
  80c0b2:	89 11                	mov    %edx,(%ecx)
  80c0b4:	eb 05                	jmp    80c0bb <do_getaddr+0x2a>
  80c0b6:	8b 52 04             	mov    0x4(%edx),%edx
  80c0b9:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c0bb:	8b 08                	mov    (%eax),%ecx
  80c0bd:	8b 11                	mov    (%ecx),%edx
  80c0bf:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c0c5:	83 fa 20             	cmp    $0x20,%edx
  80c0c8:	74 27                	je     80c0f1 <do_getaddr+0x60>
  80c0ca:	83 fa 40             	cmp    $0x40,%edx
  80c0cd:	74 07                	je     80c0d6 <do_getaddr+0x45>
  80c0cf:	83 fa 10             	cmp    $0x10,%edx
  80c0d2:	75 6f                	jne    80c143 <do_getaddr+0xb2>
  80c0d4:	eb 4b                	jmp    80c121 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80c0d6:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c0da:	74 0f                	je     80c0eb <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c0dc:	8b 50 08             	mov    0x8(%eax),%edx
  80c0df:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c0e2:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c0e6:	66 89 0a             	mov    %cx,(%edx)
  80c0e9:	eb 58                	jmp    80c143 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80c0eb:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c0ef:	eb 52                	jmp    80c143 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80c0f1:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c0f5:	74 0f                	je     80c106 <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c0f7:	8b 50 08             	mov    0x8(%eax),%edx
  80c0fa:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c0fd:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c101:	66 89 0a             	mov    %cx,(%edx)
  80c104:	eb 3d                	jmp    80c143 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c106:	8b 51 08             	mov    0x8(%ecx),%edx
  80c109:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c10d:	75 06                	jne    80c115 <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80c10f:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c113:	eb 2e                	jmp    80c143 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c115:	8b 48 08             	mov    0x8(%eax),%ecx
  80c118:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c11c:	66 89 11             	mov    %dx,(%ecx)
  80c11f:	eb 22                	jmp    80c143 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c121:	8b 50 08             	mov    0x8(%eax),%edx
  80c124:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c128:	74 09                	je     80c133 <do_getaddr+0xa2>
  80c12a:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c12d:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80c131:	eb 07                	jmp    80c13a <do_getaddr+0xa9>
  80c133:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c136:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80c13a:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c13d:	eb 04                	jmp    80c143 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80c13f:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80c143:	83 ec 0c             	sub    $0xc,%esp
  80c146:	8b 00                	mov    (%eax),%eax
  80c148:	ff 70 10             	pushl  0x10(%eax)
  80c14b:	e8 4b de ff ff       	call   809f9b <sys_sem_signal>
  80c150:	83 c4 10             	add    $0x10,%esp
}
  80c153:	c9                   	leave  
  80c154:	c3                   	ret    

0080c155 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c155:	55                   	push   %ebp
  80c156:	89 e5                	mov    %esp,%ebp
  80c158:	83 ec 08             	sub    $0x8,%esp
  80c15b:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c15e:	8b 02                	mov    (%edx),%eax
  80c160:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c164:	74 15                	je     80c17b <do_close+0x26>
  80c166:	83 38 10             	cmpl   $0x10,(%eax)
  80c169:	75 10                	jne    80c17b <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80c16b:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c172:	8b 02                	mov    (%edx),%eax
  80c174:	e8 09 f5 ff ff       	call   80b682 <do_close_internal>
  80c179:	eb 14                	jmp    80c18f <do_close+0x3a>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c17b:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c17f:	83 ec 0c             	sub    $0xc,%esp
  80c182:	8b 02                	mov    (%edx),%eax
  80c184:	ff 70 10             	pushl  0x10(%eax)
  80c187:	e8 0f de ff ff       	call   809f9b <sys_sem_signal>
  80c18c:	83 c4 10             	add    $0x10,%esp
  }
}
  80c18f:	c9                   	leave  
  80c190:	c3                   	ret    

0080c191 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c191:	55                   	push   %ebp
  80c192:	89 e5                	mov    %esp,%ebp
  80c194:	57                   	push   %edi
  80c195:	56                   	push   %esi
  80c196:	53                   	push   %ebx
  80c197:	83 ec 18             	sub    $0x18,%esp
  80c19a:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c19c:	8b 35 f0 b2 b3 00    	mov    0xb3b2f0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c1a2:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c1a6:	50                   	push   %eax
  80c1a7:	e8 ae b4 ff ff       	call   80765a <ntohs>
  80c1ac:	83 c4 10             	add    $0x10,%esp
  80c1af:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c1b3:	0f 86 83 00 00 00    	jbe    80c23c <tcp_parseopt+0xab>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c1b9:	83 c6 14             	add    $0x14,%esi
  80c1bc:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c1c1:	eb 4f                	jmp    80c212 <tcp_parseopt+0x81>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80c1c3:	0f b6 d3             	movzbl %bl,%edx
  80c1c6:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c1ca:	84 c0                	test   %al,%al
  80c1cc:	74 6e                	je     80c23c <tcp_parseopt+0xab>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80c1ce:	3c 01                	cmp    $0x1,%al
  80c1d0:	75 05                	jne    80c1d7 <tcp_parseopt+0x46>
        ++c;
  80c1d2:	83 c3 01             	add    $0x1,%ebx
  80c1d5:	eb 3b                	jmp    80c212 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80c1d7:	3c 02                	cmp    $0x2,%al
  80c1d9:	75 2c                	jne    80c207 <tcp_parseopt+0x76>
  80c1db:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c1e0:	75 25                	jne    80c207 <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c1e2:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80c1e7:	c1 e0 08             	shl    $0x8,%eax
  80c1ea:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c1ef:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c1f1:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c1f4:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80c1f9:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80c1fe:	0f 47 c2             	cmova  %edx,%eax
  80c201:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80c205:	eb 35                	jmp    80c23c <tcp_parseopt+0xab>
      } else {
        if (opts[c + 1] == 0) {
  80c207:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c20c:	84 c0                	test   %al,%al
  80c20e:	74 2c                	je     80c23c <tcp_parseopt+0xab>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c210:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c212:	83 ec 0c             	sub    $0xc,%esp
  80c215:	a1 f0 b2 b3 00       	mov    0xb3b2f0,%eax
  80c21a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c21e:	50                   	push   %eax
  80c21f:	e8 36 b4 ff ff       	call   80765a <ntohs>
  80c224:	0f b6 d3             	movzbl %bl,%edx
  80c227:	66 c1 e8 0c          	shr    $0xc,%ax
  80c22b:	0f b7 c0             	movzwl %ax,%eax
  80c22e:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c235:	83 c4 10             	add    $0x10,%esp
  80c238:	39 c2                	cmp    %eax,%edx
  80c23a:	7c 87                	jl     80c1c3 <tcp_parseopt+0x32>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80c23c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c23f:	5b                   	pop    %ebx
  80c240:	5e                   	pop    %esi
  80c241:	5f                   	pop    %edi
  80c242:	5d                   	pop    %ebp
  80c243:	c3                   	ret    

0080c244 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80c244:	55                   	push   %ebp
  80c245:	89 e5                	mov    %esp,%ebp
  80c247:	57                   	push   %edi
  80c248:	56                   	push   %esi
  80c249:	53                   	push   %ebx
  80c24a:	83 ec 1c             	sub    $0x1c,%esp
  80c24d:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80c24f:	f6 05 e0 b2 b3 00 10 	testb  $0x10,0xb3b2e0
  80c256:	0f 84 45 04 00 00    	je     80c6a1 <tcp_receive+0x45d>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c25c:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80c260:	8b 40 60             	mov    0x60(%eax),%eax

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c263:	8b 15 e8 b2 b3 00    	mov    0xb3b2e8,%edx
  80c269:	39 d0                	cmp    %edx,%eax
  80c26b:	78 26                	js     80c293 <tcp_receive+0x4f>
  80c26d:	39 d0                	cmp    %edx,%eax
  80c26f:	75 0b                	jne    80c27c <tcp_receive+0x38>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c271:	8b 0d e4 b2 b3 00    	mov    0xb3b2e4,%ecx
  80c277:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c27a:	78 17                	js     80c293 <tcp_receive+0x4f>
  80c27c:	8b 0d e4 b2 b3 00    	mov    0xb3b2e4,%ecx
  80c282:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c285:	75 3b                	jne    80c2c2 <tcp_receive+0x7e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c287:	8b 0d f0 b2 b3 00    	mov    0xb3b2f0,%ecx
  80c28d:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80c291:	73 2f                	jae    80c2c2 <tcp_receive+0x7e>
      pcb->snd_wnd = tcphdr->wnd;
  80c293:	8b 0d f0 b2 b3 00    	mov    0xb3b2f0,%ecx
  80c299:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80c29d:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c2a1:	89 57 60             	mov    %edx,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c2a4:	8b 15 e4 b2 b3 00    	mov    0xb3b2e4,%edx
  80c2aa:	89 57 64             	mov    %edx,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c2ad:	66 85 c9             	test   %cx,%cx
  80c2b0:	74 10                	je     80c2c2 <tcp_receive+0x7e>
  80c2b2:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c2b9:	74 07                	je     80c2c2 <tcp_receive+0x7e>
          pcb->persist_backoff = 0;
  80c2bb:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80c2c2:	8b 4f 48             	mov    0x48(%edi),%ecx
  80c2c5:	8b 15 e4 b2 b3 00    	mov    0xb3b2e4,%edx
  80c2cb:	39 d1                	cmp    %edx,%ecx
  80c2cd:	0f 85 ad 00 00 00    	jne    80c380 <tcp_receive+0x13c>
      pcb->acked = 0;
  80c2d3:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c2d9:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c2dd:	03 57 60             	add    0x60(%edi),%edx
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c2e0:	0f b7 db             	movzwl %bx,%ebx
  80c2e3:	01 d8                	add    %ebx,%eax
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c2e5:	39 c2                	cmp    %eax,%edx
  80c2e7:	0f 85 e2 02 00 00    	jne    80c5cf <tcp_receive+0x38b>
        ++pcb->dupacks;
  80c2ed:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c2f1:	83 c0 01             	add    $0x1,%eax
  80c2f4:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c2f7:	3c 02                	cmp    $0x2,%al
  80c2f9:	0f 86 d0 02 00 00    	jbe    80c5cf <tcp_receive+0x38b>
  80c2ff:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c303:	0f 84 c6 02 00 00    	je     80c5cf <tcp_receive+0x38b>
          if (!(pcb->flags & TF_INFR)) {
  80c309:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c30d:	75 55                	jne    80c364 <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80c30f:	83 ec 0c             	sub    $0xc,%esp
  80c312:	57                   	push   %edi
  80c313:	e8 80 c2 ff ff       	call   808598 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80c318:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80c31c:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c320:	83 c4 10             	add    $0x10,%esp
  80c323:	66 39 d0             	cmp    %dx,%ax
  80c326:	76 09                	jbe    80c331 <tcp_receive+0xed>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c328:	66 d1 ea             	shr    %dx
  80c32b:	66 89 57 50          	mov    %dx,0x50(%edi)
  80c32f:	eb 07                	jmp    80c338 <tcp_receive+0xf4>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80c331:	66 d1 e8             	shr    %ax
  80c334:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80c338:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c33c:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80c340:	0f b7 d0             	movzwl %ax,%edx
  80c343:	01 d2                	add    %edx,%edx
  80c345:	39 d1                	cmp    %edx,%ecx
  80c347:	7d 07                	jge    80c350 <tcp_receive+0x10c>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80c349:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c34c:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c350:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c353:	66 03 47 50          	add    0x50(%edi),%ax
  80c357:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c35b:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c35f:	e9 6b 02 00 00       	jmp    80c5cf <tcp_receive+0x38b>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c364:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c368:	89 d0                	mov    %edx,%eax
  80c36a:	66 03 47 34          	add    0x34(%edi),%ax
  80c36e:	66 39 c2             	cmp    %ax,%dx
  80c371:	0f 83 58 02 00 00    	jae    80c5cf <tcp_receive+0x38b>
              pcb->cwnd += pcb->mss;
  80c377:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c37b:	e9 4f 02 00 00       	jmp    80c5cf <tcp_receive+0x38b>
  80c380:	8d 42 ff             	lea    -0x1(%edx),%eax
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c383:	39 c8                	cmp    %ecx,%eax
  80c385:	0f 88 9d 01 00 00    	js     80c528 <tcp_receive+0x2e4>
  80c38b:	89 d0                	mov    %edx,%eax
  80c38d:	2b 47 58             	sub    0x58(%edi),%eax
  80c390:	85 c0                	test   %eax,%eax
  80c392:	0f 8f 90 01 00 00    	jg     80c528 <tcp_receive+0x2e4>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80c398:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80c39c:	a8 04                	test   $0x4,%al
  80c39e:	74 0e                	je     80c3ae <tcp_receive+0x16a>
        pcb->flags &= ~TF_INFR;
  80c3a0:	83 e0 fb             	and    $0xfffffffb,%eax
  80c3a3:	88 47 20             	mov    %al,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c3a6:	0f b7 47 50          	movzwl 0x50(%edi),%eax
  80c3aa:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80c3ae:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c3b2:	0f b7 47 40          	movzwl 0x40(%edi),%eax
  80c3b6:	66 c1 f8 03          	sar    $0x3,%ax
  80c3ba:	66 03 47 42          	add    0x42(%edi),%ax
  80c3be:	66 89 47 44          	mov    %ax,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c3c2:	89 d0                	mov    %edx,%eax
  80c3c4:	29 c8                	sub    %ecx,%eax
  80c3c6:	66 89 47 6c          	mov    %ax,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80c3ca:	66 01 47 6e          	add    %ax,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80c3ce:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c3d2:	89 57 48             	mov    %edx,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80c3d5:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c3d9:	0f 86 c3 00 00 00    	jbe    80c4a2 <tcp_receive+0x25e>
        if (pcb->cwnd < pcb->ssthresh) {
  80c3df:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c3e3:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c3e7:	73 18                	jae    80c401 <tcp_receive+0x1bd>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c3e9:	89 c8                	mov    %ecx,%eax
  80c3eb:	66 03 47 34          	add    0x34(%edi),%ax
  80c3ef:	66 39 c1             	cmp    %ax,%cx
  80c3f2:	0f 83 aa 00 00 00    	jae    80c4a2 <tcp_receive+0x25e>
            pcb->cwnd += pcb->mss;
  80c3f8:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c3fc:	e9 a1 00 00 00       	jmp    80c4a2 <tcp_receive+0x25e>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c401:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c405:	0f af c0             	imul   %eax,%eax
  80c408:	0f b7 d9             	movzwl %cx,%ebx
  80c40b:	99                   	cltd   
  80c40c:	f7 fb                	idiv   %ebx
  80c40e:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c410:	66 39 c1             	cmp    %ax,%cx
  80c413:	0f 83 89 00 00 00    	jae    80c4a2 <tcp_receive+0x25e>
            pcb->cwnd = new_cwnd;
  80c419:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c41d:	e9 80 00 00 00       	jmp    80c4a2 <tcp_receive+0x25e>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80c422:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c425:	8b 03                	mov    (%ebx),%eax
  80c427:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c42a:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c42e:	83 ec 0c             	sub    $0xc,%esp
  80c431:	ff 73 04             	pushl  0x4(%ebx)
  80c434:	e8 08 88 ff ff       	call   804c41 <pbuf_clen>
  80c439:	0f b6 c0             	movzbl %al,%eax
  80c43c:	83 c4 10             	add    $0x10,%esp
  80c43f:	66 39 c6             	cmp    %ax,%si
  80c442:	73 17                	jae    80c45b <tcp_receive+0x217>
  80c444:	83 ec 04             	sub    $0x4,%esp
  80c447:	68 fc 2e 81 00       	push   $0x812efc
  80c44c:	68 55 03 00 00       	push   $0x355
  80c451:	68 68 30 81 00       	push   $0x813068
  80c456:	e8 86 1f 00 00       	call   80e3e1 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c45b:	83 ec 0c             	sub    $0xc,%esp
  80c45e:	ff 73 04             	pushl  0x4(%ebx)
  80c461:	e8 db 87 ff ff       	call   804c41 <pbuf_clen>
  80c466:	0f b6 c0             	movzbl %al,%eax
  80c469:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c46d:	89 1c 24             	mov    %ebx,(%esp)
  80c470:	e8 ce 92 ff ff       	call   805743 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80c475:	83 c4 10             	add    $0x10,%esp
  80c478:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c47d:	74 23                	je     80c4a2 <tcp_receive+0x25e>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c47f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c483:	75 1d                	jne    80c4a2 <tcp_receive+0x25e>
  80c485:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c489:	75 17                	jne    80c4a2 <tcp_receive+0x25e>
  80c48b:	83 ec 04             	sub    $0x4,%esp
  80c48e:	68 24 2f 81 00       	push   $0x812f24
  80c493:	68 5c 03 00 00       	push   $0x35c
  80c498:	68 68 30 81 00       	push   $0x813068
  80c49d:	e8 3f 1f 00 00       	call   80e3e1 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c4a2:	8b 47 78             	mov    0x78(%edi),%eax
  80c4a5:	85 c0                	test   %eax,%eax
  80c4a7:	74 68                	je     80c511 <tcp_receive+0x2cd>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c4a9:	83 ec 0c             	sub    $0xc,%esp
  80c4ac:	8b 40 10             	mov    0x10(%eax),%eax
  80c4af:	ff 70 04             	pushl  0x4(%eax)
  80c4b2:	e8 e7 b3 ff ff       	call   80789e <ntohl>
  80c4b7:	89 c3                	mov    %eax,%ebx
  80c4b9:	8b 47 78             	mov    0x78(%edi),%eax
  80c4bc:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c4c0:	8b 40 10             	mov    0x10(%eax),%eax
  80c4c3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c4c7:	89 04 24             	mov    %eax,(%esp)
  80c4ca:	e8 8b b1 ff ff       	call   80765a <ntohs>
  80c4cf:	83 c4 10             	add    $0x10,%esp
  80c4d2:	ba 01 00 00 00       	mov    $0x1,%edx
  80c4d7:	a8 01                	test   $0x1,%al
  80c4d9:	75 1e                	jne    80c4f9 <tcp_receive+0x2b5>
  80c4db:	83 ec 0c             	sub    $0xc,%esp
  80c4de:	8b 47 78             	mov    0x78(%edi),%eax
  80c4e1:	8b 40 10             	mov    0x10(%eax),%eax
  80c4e4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c4e8:	50                   	push   %eax
  80c4e9:	e8 6c b1 ff ff       	call   80765a <ntohs>
  80c4ee:	66 d1 e8             	shr    %ax
  80c4f1:	89 c2                	mov    %eax,%edx
  80c4f3:	83 e2 01             	and    $0x1,%edx
  80c4f6:	83 c4 10             	add    $0x10,%esp
  80c4f9:	2b 1d e4 b2 b3 00    	sub    0xb3b2e4,%ebx
  80c4ff:	01 d6                	add    %edx,%esi
  80c501:	01 f3                	add    %esi,%ebx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c503:	85 db                	test   %ebx,%ebx
  80c505:	0f 8e 17 ff ff ff    	jle    80c422 <tcp_receive+0x1de>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80c50b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c50f:	75 08                	jne    80c519 <tcp_receive+0x2d5>
        pcb->rtime = -1;
  80c511:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80c517:	eb 06                	jmp    80c51f <tcp_receive+0x2db>
      else
        pcb->rtime = 0;
  80c519:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80c51f:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c523:	e9 a7 00 00 00       	jmp    80c5cf <tcp_receive+0x38b>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80c528:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c52e:	e9 9c 00 00 00       	jmp    80c5cf <tcp_receive+0x38b>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80c533:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c536:	8b 03                	mov    (%ebx),%eax
  80c538:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c53b:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c53f:	83 ec 0c             	sub    $0xc,%esp
  80c542:	ff 73 04             	pushl  0x4(%ebx)
  80c545:	e8 f7 86 ff ff       	call   804c41 <pbuf_clen>
  80c54a:	0f b6 c0             	movzbl %al,%eax
  80c54d:	83 c4 10             	add    $0x10,%esp
  80c550:	66 39 c6             	cmp    %ax,%si
  80c553:	73 17                	jae    80c56c <tcp_receive+0x328>
  80c555:	83 ec 04             	sub    $0x4,%esp
  80c558:	68 fc 2e 81 00       	push   $0x812efc
  80c55d:	68 7f 03 00 00       	push   $0x37f
  80c562:	68 68 30 81 00       	push   $0x813068
  80c567:	e8 75 1e 00 00       	call   80e3e1 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c56c:	83 ec 0c             	sub    $0xc,%esp
  80c56f:	ff 73 04             	pushl  0x4(%ebx)
  80c572:	e8 ca 86 ff ff       	call   804c41 <pbuf_clen>
  80c577:	0f b6 c0             	movzbl %al,%eax
  80c57a:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c57e:	89 1c 24             	mov    %ebx,(%esp)
  80c581:	e8 bd 91 ff ff       	call   805743 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80c586:	83 c4 10             	add    $0x10,%esp
  80c589:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c58e:	74 24                	je     80c5b4 <tcp_receive+0x370>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c590:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c594:	75 1e                	jne    80c5b4 <tcp_receive+0x370>
  80c596:	8b 47 74             	mov    0x74(%edi),%eax
  80c599:	85 c0                	test   %eax,%eax
  80c59b:	75 1e                	jne    80c5bb <tcp_receive+0x377>
  80c59d:	83 ec 04             	sub    $0x4,%esp
  80c5a0:	68 24 2f 81 00       	push   $0x812f24
  80c5a5:	68 85 03 00 00       	push   $0x385
  80c5aa:	68 68 30 81 00       	push   $0x813068
  80c5af:	e8 2d 1e 00 00       	call   80e3e1 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80c5b4:	8b 47 74             	mov    0x74(%edi),%eax
  80c5b7:	85 c0                	test   %eax,%eax
  80c5b9:	74 14                	je     80c5cf <tcp_receive+0x38b>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c5bb:	83 ec 0c             	sub    $0xc,%esp
  80c5be:	8b 40 10             	mov    0x10(%eax),%eax
  80c5c1:	ff 70 04             	pushl  0x4(%eax)
  80c5c4:	e8 9e b0 ff ff       	call   807667 <htonl>
  80c5c9:	89 47 54             	mov    %eax,0x54(%edi)
  80c5cc:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c5cf:	8b 47 74             	mov    0x74(%edi),%eax
  80c5d2:	85 c0                	test   %eax,%eax
  80c5d4:	74 70                	je     80c646 <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c5d6:	8b 1d e4 b2 b3 00    	mov    0xb3b2e4,%ebx
  80c5dc:	83 ec 0c             	sub    $0xc,%esp
  80c5df:	8b 40 10             	mov    0x10(%eax),%eax
  80c5e2:	ff 70 04             	pushl  0x4(%eax)
  80c5e5:	e8 b4 b2 ff ff       	call   80789e <ntohl>
  80c5ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c5ed:	8b 47 74             	mov    0x74(%edi),%eax
  80c5f0:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c5f4:	8b 40 10             	mov    0x10(%eax),%eax
  80c5f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5fb:	89 04 24             	mov    %eax,(%esp)
  80c5fe:	e8 57 b0 ff ff       	call   80765a <ntohs>
  80c603:	83 c4 10             	add    $0x10,%esp
  80c606:	ba 01 00 00 00       	mov    $0x1,%edx
  80c60b:	a8 01                	test   $0x1,%al
  80c60d:	75 1e                	jne    80c62d <tcp_receive+0x3e9>
  80c60f:	83 ec 0c             	sub    $0xc,%esp
  80c612:	8b 47 74             	mov    0x74(%edi),%eax
  80c615:	8b 40 10             	mov    0x10(%eax),%eax
  80c618:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c61c:	50                   	push   %eax
  80c61d:	e8 38 b0 ff ff       	call   80765a <ntohs>
  80c622:	66 d1 e8             	shr    %ax
  80c625:	89 c2                	mov    %eax,%edx
  80c627:	83 e2 01             	and    $0x1,%edx
  80c62a:	83 c4 10             	add    $0x10,%esp
  80c62d:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
  80c630:	01 d6                	add    %edx,%esi
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c632:	39 f3                	cmp    %esi,%ebx
  80c634:	78 10                	js     80c646 <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c636:	a1 e4 b2 b3 00       	mov    0xb3b2e4,%eax
  80c63b:	2b 47 58             	sub    0x58(%edi),%eax
  80c63e:	85 c0                	test   %eax,%eax
  80c640:	0f 8e ed fe ff ff    	jle    80c533 <tcp_receive+0x2ef>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c646:	8b 47 38             	mov    0x38(%edi),%eax
  80c649:	85 c0                	test   %eax,%eax
  80c64b:	74 54                	je     80c6a1 <tcp_receive+0x45d>
  80c64d:	8b 0d e4 b2 b3 00    	mov    0xb3b2e4,%ecx
  80c653:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c656:	79 49                	jns    80c6a1 <tcp_receive+0x45d>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80c658:	0f b7 4f 40          	movzwl 0x40(%edi),%ecx
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c65c:	0f b7 15 80 b3 b3 00 	movzwl 0xb3b380,%edx
  80c663:	29 c2                	sub    %eax,%edx

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80c665:	89 c8                	mov    %ecx,%eax
  80c667:	66 c1 f8 03          	sar    $0x3,%ax
  80c66b:	29 c2                	sub    %eax,%edx
      pcb->sa += m;
  80c66d:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  80c670:	66 89 47 40          	mov    %ax,0x40(%edi)
      if (m < 0) {
        m = -m;
  80c674:	89 d1                	mov    %edx,%ecx
  80c676:	f7 d9                	neg    %ecx
  80c678:	66 85 d2             	test   %dx,%dx
  80c67b:	0f 49 ca             	cmovns %edx,%ecx
      }
      m = m - (pcb->sv >> 2);
  80c67e:	0f b7 57 42          	movzwl 0x42(%edi),%edx
  80c682:	89 d3                	mov    %edx,%ebx
  80c684:	66 c1 fb 02          	sar    $0x2,%bx
  80c688:	29 da                	sub    %ebx,%edx
      pcb->sv += m;
  80c68a:	01 ca                	add    %ecx,%edx
  80c68c:	66 89 57 42          	mov    %dx,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c690:	66 c1 f8 03          	sar    $0x3,%ax
  80c694:	01 d0                	add    %edx,%eax
  80c696:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80c69a:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80c6a1:	0f b7 05 de b2 b3 00 	movzwl 0xb3b2de,%eax
  80c6a8:	66 85 c0             	test   %ax,%ax
  80c6ab:	0f 84 8f 07 00 00    	je     80ce40 <tcp_receive+0xbfc>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c6b1:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c6b4:	8b 15 e8 b2 b3 00    	mov    0xb3b2e8,%edx
  80c6ba:	89 d9                	mov    %ebx,%ecx
  80c6bc:	29 d1                	sub    %edx,%ecx
  80c6be:	89 ce                	mov    %ecx,%esi
  80c6c0:	83 ee 01             	sub    $0x1,%esi
  80c6c3:	0f 88 27 01 00 00    	js     80c7f0 <tcp_receive+0x5ac>
  80c6c9:	8d 73 01             	lea    0x1(%ebx),%esi
  80c6cc:	29 d6                	sub    %edx,%esi
  80c6ce:	0f b7 c0             	movzwl %ax,%eax
  80c6d1:	29 c6                	sub    %eax,%esi
  80c6d3:	85 f6                	test   %esi,%esi
  80c6d5:	0f 8f 15 01 00 00    	jg     80c7f0 <tcp_receive+0x5ac>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80c6db:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c6dd:	8b 1d f8 b2 b3 00    	mov    0xb3b2f8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c6e3:	85 db                	test   %ebx,%ebx
  80c6e5:	75 17                	jne    80c6fe <tcp_receive+0x4ba>
  80c6e7:	83 ec 04             	sub    $0x4,%esp
  80c6ea:	68 7f 30 81 00       	push   $0x81307f
  80c6ef:	68 e5 03 00 00       	push   $0x3e5
  80c6f4:	68 68 30 81 00       	push   $0x813068
  80c6f9:	e8 e3 1c 00 00       	call   80e3e1 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c6fe:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c704:	7e 17                	jle    80c71d <tcp_receive+0x4d9>
  80c706:	83 ec 04             	sub    $0x4,%esp
  80c709:	68 8f 30 81 00       	push   $0x81308f
  80c70e:	68 e6 03 00 00       	push   $0x3e6
  80c713:	68 68 30 81 00       	push   $0x813068
  80c718:	e8 c4 1c 00 00       	call   80e3e1 <_panic>
      if (inseg.p->len < off) {
  80c71d:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c721:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c724:	39 d1                	cmp    %edx,%ecx
  80c726:	7e 6a                	jle    80c792 <tcp_receive+0x54e>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c728:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c72c:	0f b7 d6             	movzwl %si,%edx
  80c72f:	39 d1                	cmp    %edx,%ecx
  80c731:	7e 17                	jle    80c74a <tcp_receive+0x506>
  80c733:	83 ec 04             	sub    $0x4,%esp
  80c736:	68 9e 30 81 00       	push   $0x81309e
  80c73b:	68 e8 03 00 00       	push   $0x3e8
  80c740:	68 68 30 81 00       	push   $0x813068
  80c745:	e8 97 1c 00 00       	call   80e3e1 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c74a:	29 ce                	sub    %ecx,%esi
  80c74c:	89 f1                	mov    %esi,%ecx
  80c74e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        while (p->len < off) {
          off -= p->len;
  80c751:	29 d0                	sub    %edx,%eax
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80c753:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c757:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c75d:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80c75f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c763:	39 c2                	cmp    %eax,%edx
  80c765:	7c ea                	jl     80c751 <tcp_receive+0x50d>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80c767:	83 ec 08             	sub    $0x8,%esp
  80c76a:	f7 d8                	neg    %eax
  80c76c:	98                   	cwtl   
  80c76d:	50                   	push   %eax
  80c76e:	53                   	push   %ebx
  80c76f:	e8 a9 7f ff ff       	call   80471d <pbuf_header>
  80c774:	83 c4 10             	add    $0x10,%esp
  80c777:	84 c0                	test   %al,%al
  80c779:	74 44                	je     80c7bf <tcp_receive+0x57b>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c77b:	83 ec 04             	sub    $0x4,%esp
  80c77e:	68 ae 30 81 00       	push   $0x8130ae
  80c783:	68 f5 03 00 00       	push   $0x3f5
  80c788:	68 68 30 81 00       	push   $0x813068
  80c78d:	e8 4f 1c 00 00       	call   80e3e1 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c792:	83 ec 08             	sub    $0x8,%esp
  80c795:	f7 d9                	neg    %ecx
  80c797:	0f bf c1             	movswl %cx,%eax
  80c79a:	50                   	push   %eax
  80c79b:	53                   	push   %ebx
  80c79c:	e8 7c 7f ff ff       	call   80471d <pbuf_header>
  80c7a1:	83 c4 10             	add    $0x10,%esp
  80c7a4:	84 c0                	test   %al,%al
  80c7a6:	74 17                	je     80c7bf <tcp_receive+0x57b>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c7a8:	83 ec 04             	sub    $0x4,%esp
  80c7ab:	68 ae 30 81 00       	push   $0x8130ae
  80c7b0:	68 fa 03 00 00       	push   $0x3fa
  80c7b5:	68 68 30 81 00       	push   $0x813068
  80c7ba:	e8 22 1c 00 00       	call   80e3e1 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80c7bf:	8b 43 04             	mov    0x4(%ebx),%eax
  80c7c2:	a3 fc b2 b3 00       	mov    %eax,0xb3b2fc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c7c7:	8b 57 24             	mov    0x24(%edi),%edx
  80c7ca:	0f b7 05 00 b3 b3 00 	movzwl 0xb3b300,%eax
  80c7d1:	66 03 05 e8 b2 b3 00 	add    0xb3b2e8,%ax
  80c7d8:	29 d0                	sub    %edx,%eax
  80c7da:	66 a3 00 b3 b3 00    	mov    %ax,0xb3b300
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c7e0:	89 15 e8 b2 b3 00    	mov    %edx,0xb3b2e8
  80c7e6:	a1 04 b3 b3 00       	mov    0xb3b304,%eax
  80c7eb:	89 50 04             	mov    %edx,0x4(%eax)
  80c7ee:	eb 14                	jmp    80c804 <tcp_receive+0x5c0>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c7f0:	39 da                	cmp    %ebx,%edx
  80c7f2:	79 21                	jns    80c815 <tcp_receive+0x5d1>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80c7f4:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c7f8:	83 ec 0c             	sub    $0xc,%esp
  80c7fb:	57                   	push   %edi
  80c7fc:	e8 a2 b7 ff ff       	call   807fa3 <tcp_output>
  80c801:	83 c4 10             	add    $0x10,%esp
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c804:	8b 15 e8 b2 b3 00    	mov    0xb3b2e8,%edx
  80c80a:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c80d:	39 da                	cmp    %ebx,%edx
  80c80f:	0f 88 14 06 00 00    	js     80ce29 <tcp_receive+0xbe5>
  80c815:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c819:	89 d1                	mov    %edx,%ecx
  80c81b:	29 c1                	sub    %eax,%ecx
  80c81d:	8d 41 01             	lea    0x1(%ecx),%eax
  80c820:	29 d8                	sub    %ebx,%eax
  80c822:	85 c0                	test   %eax,%eax
  80c824:	0f 8f ff 05 00 00    	jg     80ce29 <tcp_receive+0xbe5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80c82a:	39 da                	cmp    %ebx,%edx
  80c82c:	0f 85 78 03 00 00    	jne    80cbaa <tcp_receive+0x966>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c832:	8b 4f 7c             	mov    0x7c(%edi),%ecx
  80c835:	85 c9                	test   %ecx,%ecx
  80c837:	0f 84 86 00 00 00    	je     80c8c3 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c83d:	8b 41 10             	mov    0x10(%ecx),%eax
  80c840:	8b 58 04             	mov    0x4(%eax),%ebx
  80c843:	0f b7 05 00 b3 b3 00 	movzwl 0xb3b300,%eax
  80c84a:	89 de                	mov    %ebx,%esi
  80c84c:	29 c6                	sub    %eax,%esi
  80c84e:	89 f0                	mov    %esi,%eax
  80c850:	29 d0                	sub    %edx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c852:	85 c0                	test   %eax,%eax
  80c854:	7f 6d                	jg     80c8c3 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80c856:	66 83 79 0c 00       	cmpw   $0x0,0xc(%ecx)
  80c85b:	74 20                	je     80c87d <tcp_receive+0x639>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80c85d:	29 d3                	sub    %edx,%ebx
  80c85f:	66 89 1d 00 b3 b3 00 	mov    %bx,0xb3b300
            pbuf_realloc(inseg.p, inseg.len);
  80c866:	83 ec 08             	sub    $0x8,%esp
  80c869:	0f b7 db             	movzwl %bx,%ebx
  80c86c:	53                   	push   %ebx
  80c86d:	ff 35 f8 b2 b3 00    	pushl  0xb3b2f8
  80c873:	e8 bc 82 ff ff       	call   804b34 <pbuf_realloc>
  80c878:	83 c4 10             	add    $0x10,%esp
  80c87b:	eb 46                	jmp    80c8c3 <tcp_receive+0x67f>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c87d:	83 ec 0c             	sub    $0xc,%esp
  80c880:	a1 04 b3 b3 00       	mov    0xb3b304,%eax
  80c885:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c889:	50                   	push   %eax
  80c88a:	e8 cb ad ff ff       	call   80765a <ntohs>
  80c88f:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80c891:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c894:	8b 40 10             	mov    0x10(%eax),%eax
  80c897:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c89b:	89 04 24             	mov    %eax,(%esp)
  80c89e:	e8 b7 ad ff ff       	call   80765a <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c8a3:	31 c3                	xor    %eax,%ebx
  80c8a5:	83 c4 10             	add    $0x10,%esp
  80c8a8:	f6 c3 03             	test   $0x3,%bl
  80c8ab:	75 16                	jne    80c8c3 <tcp_receive+0x67f>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80c8ad:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80c8b0:	8b 10                	mov    (%eax),%edx
  80c8b2:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80c8b5:	83 ec 08             	sub    $0x8,%esp
  80c8b8:	50                   	push   %eax
  80c8b9:	6a 04                	push   $0x4
  80c8bb:	e8 bc 7b ff ff       	call   80447c <memp_free>
  80c8c0:	83 c4 10             	add    $0x10,%esp
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80c8c3:	0f b7 1d 00 b3 b3 00 	movzwl 0xb3b300,%ebx
  80c8ca:	83 ec 0c             	sub    $0xc,%esp
  80c8cd:	a1 04 b3 b3 00       	mov    0xb3b304,%eax
  80c8d2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8d6:	50                   	push   %eax
  80c8d7:	e8 7e ad ff ff       	call   80765a <ntohs>
  80c8dc:	83 c4 10             	add    $0x10,%esp
  80c8df:	ba 01 00 00 00       	mov    $0x1,%edx
  80c8e4:	a8 01                	test   $0x1,%al
  80c8e6:	75 1d                	jne    80c905 <tcp_receive+0x6c1>
  80c8e8:	83 ec 0c             	sub    $0xc,%esp
  80c8eb:	a1 04 b3 b3 00       	mov    0xb3b304,%eax
  80c8f0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8f4:	50                   	push   %eax
  80c8f5:	e8 60 ad ff ff       	call   80765a <ntohs>
  80c8fa:	66 d1 e8             	shr    %ax
  80c8fd:	89 c2                	mov    %eax,%edx
  80c8ff:	83 e2 01             	and    $0x1,%edx
  80c902:	83 c4 10             	add    $0x10,%esp
  80c905:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80c908:	66 a3 de b2 b3 00    	mov    %ax,0xb3b2de

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80c90e:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c912:	74 06                	je     80c91a <tcp_receive+0x6d6>
          pcb->rcv_nxt += tcplen;
  80c914:	0f b7 d0             	movzwl %ax,%edx
  80c917:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80c91a:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80c91e:	66 39 d0             	cmp    %dx,%ax
  80c921:	76 08                	jbe    80c92b <tcp_receive+0x6e7>
          pcb->rcv_wnd = 0;
  80c923:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80c929:	eb 06                	jmp    80c931 <tcp_receive+0x6ed>
        } else {
          pcb->rcv_wnd -= tcplen;
  80c92b:	29 c2                	sub    %eax,%edx
  80c92d:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80c931:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80c935:	66 39 d0             	cmp    %dx,%ax
  80c938:	76 08                	jbe    80c942 <tcp_receive+0x6fe>
          pcb->rcv_ann_wnd = 0;
  80c93a:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80c940:	eb 06                	jmp    80c948 <tcp_receive+0x704>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80c942:	29 c2                	sub    %eax,%edx
  80c944:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80c948:	a1 f8 b2 b3 00       	mov    0xb3b2f8,%eax
  80c94d:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80c952:	74 0f                	je     80c963 <tcp_receive+0x71f>
          recv_data = inseg.p;
  80c954:	a3 d8 b2 b3 00       	mov    %eax,0xb3b2d8
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80c959:	c7 05 f8 b2 b3 00 00 	movl   $0x0,0xb3b2f8
  80c960:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80c963:	83 ec 0c             	sub    $0xc,%esp
  80c966:	a1 04 b3 b3 00       	mov    0xb3b304,%eax
  80c96b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c96f:	50                   	push   %eax
  80c970:	e8 e5 ac ff ff       	call   80765a <ntohs>
  80c975:	83 c4 10             	add    $0x10,%esp
  80c978:	a8 01                	test   $0x1,%al
  80c97a:	0f 84 dd 01 00 00    	je     80cb5d <tcp_receive+0x919>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80c980:	c6 05 dc b2 b3 00 20 	movb   $0x20,0xb3b2dc
  80c987:	e9 d1 01 00 00       	jmp    80cb5d <tcp_receive+0x919>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80c98c:	a3 e8 b2 b3 00       	mov    %eax,0xb3b2e8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80c991:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c995:	83 ec 0c             	sub    $0xc,%esp
  80c998:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80c99c:	50                   	push   %eax
  80c99d:	e8 b8 ac ff ff       	call   80765a <ntohs>
  80c9a2:	83 c4 10             	add    $0x10,%esp
  80c9a5:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9aa:	a8 01                	test   $0x1,%al
  80c9ac:	75 1b                	jne    80c9c9 <tcp_receive+0x785>
  80c9ae:	83 ec 0c             	sub    $0xc,%esp
  80c9b1:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9b4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9b8:	50                   	push   %eax
  80c9b9:	e8 9c ac ff ff       	call   80765a <ntohs>
  80c9be:	66 d1 e8             	shr    %ax
  80c9c1:	89 c2                	mov    %eax,%edx
  80c9c3:	83 e2 01             	and    $0x1,%edx
  80c9c6:	83 c4 10             	add    $0x10,%esp
  80c9c9:	01 d6                	add    %edx,%esi
  80c9cb:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80c9ce:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c9d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c9d5:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c9d9:	83 ec 0c             	sub    $0xc,%esp
  80c9dc:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9df:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9e3:	50                   	push   %eax
  80c9e4:	e8 71 ac ff ff       	call   80765a <ntohs>
  80c9e9:	83 c4 10             	add    $0x10,%esp
  80c9ec:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9f1:	a8 01                	test   $0x1,%al
  80c9f3:	75 1b                	jne    80ca10 <tcp_receive+0x7cc>
  80c9f5:	83 ec 0c             	sub    $0xc,%esp
  80c9f8:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9fb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9ff:	50                   	push   %eax
  80ca00:	e8 55 ac ff ff       	call   80765a <ntohs>
  80ca05:	66 d1 e8             	shr    %ax
  80ca08:	89 c2                	mov    %eax,%edx
  80ca0a:	83 e2 01             	and    $0x1,%edx
  80ca0d:	83 c4 10             	add    $0x10,%esp
  80ca10:	01 d6                	add    %edx,%esi
  80ca12:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ca15:	7d 08                	jge    80ca1f <tcp_receive+0x7db>
            pcb->rcv_wnd = 0;
  80ca17:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80ca1d:	eb 41                	jmp    80ca60 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80ca1f:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ca23:	83 ec 0c             	sub    $0xc,%esp
  80ca26:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca29:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca2d:	50                   	push   %eax
  80ca2e:	e8 27 ac ff ff       	call   80765a <ntohs>
  80ca33:	83 c4 10             	add    $0x10,%esp
  80ca36:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca3b:	a8 01                	test   $0x1,%al
  80ca3d:	75 1b                	jne    80ca5a <tcp_receive+0x816>
  80ca3f:	83 ec 0c             	sub    $0xc,%esp
  80ca42:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca45:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca49:	50                   	push   %eax
  80ca4a:	e8 0b ac ff ff       	call   80765a <ntohs>
  80ca4f:	66 d1 e8             	shr    %ax
  80ca52:	89 c2                	mov    %eax,%edx
  80ca54:	83 e2 01             	and    $0x1,%edx
  80ca57:	83 c4 10             	add    $0x10,%esp
  80ca5a:	01 d6                	add    %edx,%esi
  80ca5c:	66 29 77 28          	sub    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80ca60:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80ca64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ca67:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ca6b:	83 ec 0c             	sub    $0xc,%esp
  80ca6e:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca71:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca75:	50                   	push   %eax
  80ca76:	e8 df ab ff ff       	call   80765a <ntohs>
  80ca7b:	83 c4 10             	add    $0x10,%esp
  80ca7e:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca83:	a8 01                	test   $0x1,%al
  80ca85:	75 1b                	jne    80caa2 <tcp_receive+0x85e>
  80ca87:	83 ec 0c             	sub    $0xc,%esp
  80ca8a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca8d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca91:	50                   	push   %eax
  80ca92:	e8 c3 ab ff ff       	call   80765a <ntohs>
  80ca97:	66 d1 e8             	shr    %ax
  80ca9a:	89 c2                	mov    %eax,%edx
  80ca9c:	83 e2 01             	and    $0x1,%edx
  80ca9f:	83 c4 10             	add    $0x10,%esp
  80caa2:	01 d6                	add    %edx,%esi
  80caa4:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80caa7:	7d 08                	jge    80cab1 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80caa9:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80caaf:	eb 41                	jmp    80caf2 <tcp_receive+0x8ae>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cab1:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cab5:	83 ec 0c             	sub    $0xc,%esp
  80cab8:	8b 43 10             	mov    0x10(%ebx),%eax
  80cabb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cabf:	50                   	push   %eax
  80cac0:	e8 95 ab ff ff       	call   80765a <ntohs>
  80cac5:	83 c4 10             	add    $0x10,%esp
  80cac8:	ba 01 00 00 00       	mov    $0x1,%edx
  80cacd:	a8 01                	test   $0x1,%al
  80cacf:	75 1b                	jne    80caec <tcp_receive+0x8a8>
  80cad1:	83 ec 0c             	sub    $0xc,%esp
  80cad4:	8b 43 10             	mov    0x10(%ebx),%eax
  80cad7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cadb:	50                   	push   %eax
  80cadc:	e8 79 ab ff ff       	call   80765a <ntohs>
  80cae1:	66 d1 e8             	shr    %ax
  80cae4:	89 c2                	mov    %eax,%edx
  80cae6:	83 e2 01             	and    $0x1,%edx
  80cae9:	83 c4 10             	add    $0x10,%esp
  80caec:	01 d6                	add    %edx,%esi
  80caee:	66 29 77 2a          	sub    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80caf2:	8b 43 04             	mov    0x4(%ebx),%eax
  80caf5:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cafa:	74 25                	je     80cb21 <tcp_receive+0x8dd>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80cafc:	8b 15 d8 b2 b3 00    	mov    0xb3b2d8,%edx
  80cb02:	85 d2                	test   %edx,%edx
  80cb04:	74 0f                	je     80cb15 <tcp_receive+0x8d1>
              pbuf_cat(recv_data, cseg->p);
  80cb06:	83 ec 08             	sub    $0x8,%esp
  80cb09:	50                   	push   %eax
  80cb0a:	52                   	push   %edx
  80cb0b:	e8 5a 81 ff ff       	call   804c6a <pbuf_cat>
  80cb10:	83 c4 10             	add    $0x10,%esp
  80cb13:	eb 05                	jmp    80cb1a <tcp_receive+0x8d6>
            } else {
              recv_data = cseg->p;
  80cb15:	a3 d8 b2 b3 00       	mov    %eax,0xb3b2d8
            }
            cseg->p = NULL;
  80cb1a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cb21:	83 ec 0c             	sub    $0xc,%esp
  80cb24:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb27:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb2b:	50                   	push   %eax
  80cb2c:	e8 29 ab ff ff       	call   80765a <ntohs>
  80cb31:	83 c4 10             	add    $0x10,%esp
  80cb34:	a8 01                	test   $0x1,%al
  80cb36:	74 14                	je     80cb4c <tcp_receive+0x908>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80cb38:	c6 05 dc b2 b3 00 20 	movb   $0x20,0xb3b2dc
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cb3f:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cb43:	75 07                	jne    80cb4c <tcp_receive+0x908>
              pcb->state = CLOSE_WAIT;
  80cb45:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80cb4c:	8b 03                	mov    (%ebx),%eax
  80cb4e:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cb51:	83 ec 0c             	sub    $0xc,%esp
  80cb54:	53                   	push   %ebx
  80cb55:	e8 e9 8b ff ff       	call   805743 <tcp_seg_free>
  80cb5a:	83 c4 10             	add    $0x10,%esp
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cb5d:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cb60:	85 db                	test   %ebx,%ebx
  80cb62:	74 0f                	je     80cb73 <tcp_receive+0x92f>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cb64:	8b 53 10             	mov    0x10(%ebx),%edx
  80cb67:	8b 42 04             	mov    0x4(%edx),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cb6a:	3b 47 24             	cmp    0x24(%edi),%eax
  80cb6d:	0f 84 19 fe ff ff    	je     80c98c <tcp_receive+0x748>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cb73:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cb77:	a8 01                	test   $0x1,%al
  80cb79:	74 1f                	je     80cb9a <tcp_receive+0x956>
  80cb7b:	83 e0 fe             	and    $0xfffffffe,%eax
  80cb7e:	83 c8 02             	or     $0x2,%eax
  80cb81:	88 47 20             	mov    %al,0x20(%edi)
  80cb84:	83 ec 0c             	sub    $0xc,%esp
  80cb87:	57                   	push   %edi
  80cb88:	e8 16 b4 ff ff       	call   807fa3 <tcp_output>
  80cb8d:	83 c4 10             	add    $0x10,%esp
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cb90:	b8 01 00 00 00       	mov    $0x1,%eax
  80cb95:	e9 07 03 00 00       	jmp    80cea1 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cb9a:	83 c8 01             	or     $0x1,%eax
  80cb9d:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cba0:	b8 01 00 00 00       	mov    $0x1,%eax
  80cba5:	e9 f7 02 00 00       	jmp    80cea1 <tcp_receive+0xc5d>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80cbaa:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cbae:	83 ec 0c             	sub    $0xc,%esp
  80cbb1:	57                   	push   %edi
  80cbb2:	e8 ec b3 ff ff       	call   807fa3 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80cbb7:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cbba:	83 c4 10             	add    $0x10,%esp
  80cbbd:	85 db                	test   %ebx,%ebx
  80cbbf:	75 1d                	jne    80cbde <tcp_receive+0x99a>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cbc1:	83 ec 0c             	sub    $0xc,%esp
  80cbc4:	68 f4 b2 b3 00       	push   $0xb3b2f4
  80cbc9:	e8 f5 8b ff ff       	call   8057c3 <tcp_seg_copy>
  80cbce:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cbd1:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cbd4:	b8 00 00 00 00       	mov    $0x0,%eax
  80cbd9:	e9 c3 02 00 00       	jmp    80cea1 <tcp_receive+0xc5d>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80cbde:	8b 0d e8 b2 b3 00    	mov    0xb3b2e8,%ecx
  80cbe4:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cbe7:	8d 51 01             	lea    0x1(%ecx),%edx
  80cbea:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cbed:	be 00 00 00 00       	mov    $0x0,%esi
  80cbf2:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cbf5:	89 c7                	mov    %eax,%edi
  80cbf7:	eb 02                	jmp    80cbfb <tcp_receive+0x9b7>
  80cbf9:	89 d3                	mov    %edx,%ebx
  80cbfb:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbfe:	8b 40 04             	mov    0x4(%eax),%eax
  80cc01:	39 c8                	cmp    %ecx,%eax
  80cc03:	0f 85 a6 00 00 00    	jne    80ccaf <tcp_receive+0xa6b>
  80cc09:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc0c:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80cc11:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cc15:	66 39 0d 00 b3 b3 00 	cmp    %cx,0xb3b300
  80cc1c:	0f 86 7f 02 00 00    	jbe    80cea1 <tcp_receive+0xc5d>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80cc22:	83 ec 0c             	sub    $0xc,%esp
  80cc25:	68 f4 b2 b3 00       	push   $0xb3b2f4
  80cc2a:	e8 94 8b ff ff       	call   8057c3 <tcp_seg_copy>
  80cc2f:	89 c1                	mov    %eax,%ecx
  80cc31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80cc34:	83 c4 10             	add    $0x10,%esp
  80cc37:	85 c0                	test   %eax,%eax
  80cc39:	0f 84 33 02 00 00    	je     80ce72 <tcp_receive+0xc2e>
                  cseg->next = next->next;
  80cc3f:	8b 03                	mov    (%ebx),%eax
  80cc41:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cc43:	85 f6                	test   %esi,%esi
  80cc45:	74 04                	je     80cc4b <tcp_receive+0xa07>
                    prev->next = cseg;
  80cc47:	89 0e                	mov    %ecx,(%esi)
  80cc49:	eb 06                	jmp    80cc51 <tcp_receive+0xa0d>
                  } else {
                    pcb->ooseq = cseg;
  80cc4b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cc4e:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80cc51:	83 ec 0c             	sub    $0xc,%esp
  80cc54:	53                   	push   %ebx
  80cc55:	e8 e9 8a ff ff       	call   805743 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cc5a:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80cc5d:	8b 06                	mov    (%esi),%eax
  80cc5f:	83 c4 10             	add    $0x10,%esp
  80cc62:	85 c0                	test   %eax,%eax
  80cc64:	0f 84 0f 02 00 00    	je     80ce79 <tcp_receive+0xc35>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cc6a:	8b 1d e8 b2 b3 00    	mov    0xb3b2e8,%ebx
  80cc70:	8b 40 10             	mov    0x10(%eax),%eax
  80cc73:	8b 50 04             	mov    0x4(%eax),%edx
  80cc76:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cc7a:	29 d1                	sub    %edx,%ecx
  80cc7c:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc7e:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cc83:	85 c9                	test   %ecx,%ecx
  80cc85:	0f 8e 16 02 00 00    	jle    80cea1 <tcp_receive+0xc5d>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80cc8b:	89 d0                	mov    %edx,%eax
  80cc8d:	29 d8                	sub    %ebx,%eax
  80cc8f:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80cc93:	83 ec 08             	sub    $0x8,%esp
  80cc96:	0f b7 c0             	movzwl %ax,%eax
  80cc99:	50                   	push   %eax
  80cc9a:	ff 76 04             	pushl  0x4(%esi)
  80cc9d:	e8 92 7e ff ff       	call   804b34 <pbuf_realloc>
  80cca2:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cca5:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccaa:	e9 f2 01 00 00       	jmp    80cea1 <tcp_receive+0xc5d>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80ccaf:	85 f6                	test   %esi,%esi
  80ccb1:	75 5e                	jne    80cd11 <tcp_receive+0xacd>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80ccb3:	39 c1                	cmp    %eax,%ecx
  80ccb5:	0f 89 fc 00 00 00    	jns    80cdb7 <tcp_receive+0xb73>
  80ccbb:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80ccbe:	0f b7 15 00 b3 b3 00 	movzwl 0xb3b300,%edx
  80ccc5:	01 ca                	add    %ecx,%edx
  80ccc7:	29 c2                	sub    %eax,%edx
  80ccc9:	85 d2                	test   %edx,%edx
  80cccb:	7e 1d                	jle    80ccea <tcp_receive+0xaa6>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cccd:	29 c8                	sub    %ecx,%eax
  80cccf:	66 a3 00 b3 b3 00    	mov    %ax,0xb3b300
                    pbuf_realloc(inseg.p, inseg.len);
  80ccd5:	83 ec 08             	sub    $0x8,%esp
  80ccd8:	0f b7 c0             	movzwl %ax,%eax
  80ccdb:	50                   	push   %eax
  80ccdc:	ff 35 f8 b2 b3 00    	pushl  0xb3b2f8
  80cce2:	e8 4d 7e ff ff       	call   804b34 <pbuf_realloc>
  80cce7:	83 c4 10             	add    $0x10,%esp
                  }
                  cseg = tcp_seg_copy(&inseg);
  80ccea:	83 ec 0c             	sub    $0xc,%esp
  80cced:	68 f4 b2 b3 00       	push   $0xb3b2f4
  80ccf2:	e8 cc 8a ff ff       	call   8057c3 <tcp_seg_copy>
                  if (cseg != NULL) {
  80ccf7:	83 c4 10             	add    $0x10,%esp
  80ccfa:	85 c0                	test   %eax,%eax
  80ccfc:	0f 84 7e 01 00 00    	je     80ce80 <tcp_receive+0xc3c>
                    cseg->next = next;
  80cd02:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cd04:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd07:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd0c:	e9 90 01 00 00       	jmp    80cea1 <tcp_receive+0xc5d>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cd11:	8b 56 10             	mov    0x10(%esi),%edx
  80cd14:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cd17:	0f 88 9a 00 00 00    	js     80cdb7 <tcp_receive+0xb73>
  80cd1d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cd20:	29 c2                	sub    %eax,%edx
  80cd22:	85 d2                	test   %edx,%edx
  80cd24:	0f 8f 8d 00 00 00    	jg     80cdb7 <tcp_receive+0xb73>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cd2a:	0f b7 15 00 b3 b3 00 	movzwl 0xb3b300,%edx
  80cd31:	01 ca                	add    %ecx,%edx
  80cd33:	29 c2                	sub    %eax,%edx
  80cd35:	85 d2                	test   %edx,%edx
  80cd37:	7e 1d                	jle    80cd56 <tcp_receive+0xb12>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cd39:	29 c8                	sub    %ecx,%eax
  80cd3b:	66 a3 00 b3 b3 00    	mov    %ax,0xb3b300
                  pbuf_realloc(inseg.p, inseg.len);
  80cd41:	83 ec 08             	sub    $0x8,%esp
  80cd44:	0f b7 c0             	movzwl %ax,%eax
  80cd47:	50                   	push   %eax
  80cd48:	ff 35 f8 b2 b3 00    	pushl  0xb3b2f8
  80cd4e:	e8 e1 7d ff ff       	call   804b34 <pbuf_realloc>
  80cd53:	83 c4 10             	add    $0x10,%esp
                }

                cseg = tcp_seg_copy(&inseg);
  80cd56:	83 ec 0c             	sub    $0xc,%esp
  80cd59:	68 f4 b2 b3 00       	push   $0xb3b2f4
  80cd5e:	e8 60 8a ff ff       	call   8057c3 <tcp_seg_copy>
                if (cseg != NULL) {
  80cd63:	83 c4 10             	add    $0x10,%esp
  80cd66:	85 c0                	test   %eax,%eax
  80cd68:	0f 84 19 01 00 00    	je     80ce87 <tcp_receive+0xc43>
                  cseg->next = next;
  80cd6e:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80cd70:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cd72:	8b 46 10             	mov    0x10(%esi),%eax
  80cd75:	8b 58 04             	mov    0x4(%eax),%ebx
  80cd78:	8b 15 e8 b2 b3 00    	mov    0xb3b2e8,%edx
  80cd7e:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cd82:	29 d1                	sub    %edx,%ecx
  80cd84:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd86:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cd8b:	85 c9                	test   %ecx,%ecx
  80cd8d:	0f 8e 0e 01 00 00    	jle    80cea1 <tcp_receive+0xc5d>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80cd93:	89 d0                	mov    %edx,%eax
  80cd95:	29 d8                	sub    %ebx,%eax
  80cd97:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cd9b:	83 ec 08             	sub    $0x8,%esp
  80cd9e:	0f b7 c0             	movzwl %ax,%eax
  80cda1:	50                   	push   %eax
  80cda2:	ff 76 04             	pushl  0x4(%esi)
  80cda5:	e8 8a 7d ff ff       	call   804b34 <pbuf_realloc>
  80cdaa:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdad:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdb2:	e9 ea 00 00 00       	jmp    80cea1 <tcp_receive+0xc5d>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80cdb7:	8b 13                	mov    (%ebx),%edx
  80cdb9:	89 de                	mov    %ebx,%esi
  80cdbb:	85 d2                	test   %edx,%edx
  80cdbd:	0f 85 36 fe ff ff    	jne    80cbf9 <tcp_receive+0x9b5>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80cdc3:	29 c1                	sub    %eax,%ecx
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80cdc5:	85 c9                	test   %ecx,%ecx
  80cdc7:	0f 8e c1 00 00 00    	jle    80ce8e <tcp_receive+0xc4a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80cdcd:	83 ec 0c             	sub    $0xc,%esp
  80cdd0:	68 f4 b2 b3 00       	push   $0xb3b2f4
  80cdd5:	e8 e9 89 ff ff       	call   8057c3 <tcp_seg_copy>
  80cdda:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80cddc:	83 c4 10             	add    $0x10,%esp
  80cddf:	85 c0                	test   %eax,%eax
  80cde1:	0f 84 ae 00 00 00    	je     80ce95 <tcp_receive+0xc51>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cde7:	8b 43 10             	mov    0x10(%ebx),%eax
  80cdea:	8b 70 04             	mov    0x4(%eax),%esi
  80cded:	8b 15 e8 b2 b3 00    	mov    0xb3b2e8,%edx
  80cdf3:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cdf7:	29 d1                	sub    %edx,%ecx
  80cdf9:	01 f1                	add    %esi,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdfb:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80ce00:	85 c9                	test   %ecx,%ecx
  80ce02:	0f 8e 99 00 00 00    	jle    80cea1 <tcp_receive+0xc5d>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80ce08:	89 d0                	mov    %edx,%eax
  80ce0a:	29 f0                	sub    %esi,%eax
  80ce0c:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80ce10:	83 ec 08             	sub    $0x8,%esp
  80ce13:	0f b7 c0             	movzwl %ax,%eax
  80ce16:	50                   	push   %eax
  80ce17:	ff 73 04             	pushl  0x4(%ebx)
  80ce1a:	e8 15 7d ff ff       	call   804b34 <pbuf_realloc>
  80ce1f:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce22:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce27:	eb 78                	jmp    80cea1 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80ce29:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ce2d:	83 ec 0c             	sub    $0xc,%esp
  80ce30:	57                   	push   %edi
  80ce31:	e8 6d b1 ff ff       	call   807fa3 <tcp_output>
  80ce36:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce39:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce3e:	eb 61                	jmp    80cea1 <tcp_receive+0xc5d>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80ce40:	a1 e8 b2 b3 00       	mov    0xb3b2e8,%eax
  80ce45:	8b 57 24             	mov    0x24(%edi),%edx
  80ce48:	39 d0                	cmp    %edx,%eax
  80ce4a:	78 0f                	js     80ce5b <tcp_receive+0xc17>
  80ce4c:	83 c0 01             	add    $0x1,%eax
  80ce4f:	29 d0                	sub    %edx,%eax
  80ce51:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80ce55:	29 d0                	sub    %edx,%eax
  80ce57:	85 c0                	test   %eax,%eax
  80ce59:	7e 41                	jle    80ce9c <tcp_receive+0xc58>
      tcp_ack_now(pcb);
  80ce5b:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ce5f:	83 ec 0c             	sub    $0xc,%esp
  80ce62:	57                   	push   %edi
  80ce63:	e8 3b b1 ff ff       	call   807fa3 <tcp_output>
  80ce68:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ce6b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce70:	eb 2f                	jmp    80cea1 <tcp_receive+0xc5d>
  80ce72:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce77:	eb 28                	jmp    80cea1 <tcp_receive+0xc5d>
  80ce79:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce7e:	eb 21                	jmp    80cea1 <tcp_receive+0xc5d>
  80ce80:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce85:	eb 1a                	jmp    80cea1 <tcp_receive+0xc5d>
  80ce87:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce8c:	eb 13                	jmp    80cea1 <tcp_receive+0xc5d>
  80ce8e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce93:	eb 0c                	jmp    80cea1 <tcp_receive+0xc5d>
  80ce95:	b8 00 00 00 00       	mov    $0x0,%eax
  80ce9a:	eb 05                	jmp    80cea1 <tcp_receive+0xc5d>
  80ce9c:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80cea1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80cea4:	5b                   	pop    %ebx
  80cea5:	5e                   	pop    %esi
  80cea6:	5f                   	pop    %edi
  80cea7:	5d                   	pop    %ebp
  80cea8:	c3                   	ret    

0080cea9 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80cea9:	55                   	push   %ebp
  80ceaa:	89 e5                	mov    %esp,%ebp
  80ceac:	57                   	push   %edi
  80cead:	56                   	push   %esi
  80ceae:	53                   	push   %ebx
  80ceaf:	83 ec 38             	sub    $0x38,%esp
  80ceb2:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80ceb5:	8b 5e 04             	mov    0x4(%esi),%ebx
  80ceb8:	89 1d ec b2 b3 00    	mov    %ebx,0xb3b2ec
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80cebe:	0f b7 03             	movzwl (%ebx),%eax
  80cec1:	50                   	push   %eax
  80cec2:	e8 93 a7 ff ff       	call   80765a <ntohs>
  80cec7:	66 c1 e8 08          	shr    $0x8,%ax
  80cecb:	83 e0 0f             	and    $0xf,%eax
  80cece:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80ced1:	a3 f0 b2 b3 00       	mov    %eax,0xb3b2f0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80ced6:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
  80cedb:	0f b7 00             	movzwl (%eax),%eax
  80cede:	89 04 24             	mov    %eax,(%esp)
  80cee1:	e8 74 a7 ff ff       	call   80765a <ntohs>
  80cee6:	83 c4 08             	add    $0x8,%esp
  80cee9:	66 c1 e8 06          	shr    $0x6,%ax
  80ceed:	83 e0 3c             	and    $0x3c,%eax
  80cef0:	f7 d8                	neg    %eax
  80cef2:	98                   	cwtl   
  80cef3:	50                   	push   %eax
  80cef4:	56                   	push   %esi
  80cef5:	e8 23 78 ff ff       	call   80471d <pbuf_header>
  80cefa:	83 c4 10             	add    $0x10,%esp
  80cefd:	84 c0                	test   %al,%al
  80ceff:	75 07                	jne    80cf08 <tcp_input+0x5f>
  80cf01:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80cf06:	77 11                	ja     80cf19 <tcp_input+0x70>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf08:	83 ec 0c             	sub    $0xc,%esp
  80cf0b:	56                   	push   %esi
  80cf0c:	e8 de 78 ff ff       	call   8047ef <pbuf_free>
    return;
  80cf11:	83 c4 10             	add    $0x10,%esp
  80cf14:	e9 d6 0c 00 00       	jmp    80dbef <tcp_input+0xd46>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80cf19:	83 ec 08             	sub    $0x8,%esp
  80cf1c:	ff 75 0c             	pushl  0xc(%ebp)
  80cf1f:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
  80cf24:	83 c0 10             	add    $0x10,%eax
  80cf27:	50                   	push   %eax
  80cf28:	e8 ff 94 ff ff       	call   80642c <ip_addr_isbroadcast>
  80cf2d:	83 c4 10             	add    $0x10,%esp
  80cf30:	84 c0                	test   %al,%al
  80cf32:	75 2a                	jne    80cf5e <tcp_input+0xb5>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80cf34:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
  80cf39:	8b 58 10             	mov    0x10(%eax),%ebx
  80cf3c:	83 ec 0c             	sub    $0xc,%esp
  80cf3f:	68 00 00 00 f0       	push   $0xf0000000
  80cf44:	e8 55 a9 ff ff       	call   80789e <ntohl>
  80cf49:	21 c3                	and    %eax,%ebx
  80cf4b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cf52:	e8 47 a9 ff ff       	call   80789e <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80cf57:	83 c4 10             	add    $0x10,%esp
  80cf5a:	39 c3                	cmp    %eax,%ebx
  80cf5c:	75 11                	jne    80cf6f <tcp_input+0xc6>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf5e:	83 ec 0c             	sub    $0xc,%esp
  80cf61:	56                   	push   %esi
  80cf62:	e8 88 78 ff ff       	call   8047ef <pbuf_free>
    return;
  80cf67:	83 c4 10             	add    $0x10,%esp
  80cf6a:	e9 80 0c 00 00       	jmp    80dbef <tcp_input+0xd46>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80cf6f:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80cf74:	83 ec 0c             	sub    $0xc,%esp
  80cf77:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80cf7b:	52                   	push   %edx
  80cf7c:	6a 06                	push   $0x6
  80cf7e:	8d 50 10             	lea    0x10(%eax),%edx
  80cf81:	52                   	push   %edx
  80cf82:	83 c0 0c             	add    $0xc,%eax
  80cf85:	50                   	push   %eax
  80cf86:	56                   	push   %esi
  80cf87:	e8 a1 a3 ff ff       	call   80732d <inet_chksum_pseudo>
  80cf8c:	83 c4 20             	add    $0x20,%esp
  80cf8f:	66 85 c0             	test   %ax,%ax
  80cf92:	74 11                	je     80cfa5 <tcp_input+0xfc>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf94:	83 ec 0c             	sub    $0xc,%esp
  80cf97:	56                   	push   %esi
  80cf98:	e8 52 78 ff ff       	call   8047ef <pbuf_free>
    return;
  80cf9d:	83 c4 10             	add    $0x10,%esp
  80cfa0:	e9 4a 0c 00 00       	jmp    80dbef <tcp_input+0xd46>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80cfa5:	83 ec 0c             	sub    $0xc,%esp
  80cfa8:	a1 f0 b2 b3 00       	mov    0xb3b2f0,%eax
  80cfad:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfb1:	50                   	push   %eax
  80cfb2:	e8 a3 a6 ff ff       	call   80765a <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80cfb7:	83 c4 08             	add    $0x8,%esp
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80cfba:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80cfbe:	f7 d8                	neg    %eax
  80cfc0:	c1 e0 02             	shl    $0x2,%eax
  80cfc3:	98                   	cwtl   
  80cfc4:	50                   	push   %eax
  80cfc5:	56                   	push   %esi
  80cfc6:	e8 52 77 ff ff       	call   80471d <pbuf_header>
  80cfcb:	83 c4 10             	add    $0x10,%esp
  80cfce:	84 c0                	test   %al,%al
  80cfd0:	74 11                	je     80cfe3 <tcp_input+0x13a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cfd2:	83 ec 0c             	sub    $0xc,%esp
  80cfd5:	56                   	push   %esi
  80cfd6:	e8 14 78 ff ff       	call   8047ef <pbuf_free>
    return;
  80cfdb:	83 c4 10             	add    $0x10,%esp
  80cfde:	e9 0c 0c 00 00       	jmp    80dbef <tcp_input+0xd46>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80cfe3:	8b 1d f0 b2 b3 00    	mov    0xb3b2f0,%ebx
  80cfe9:	83 ec 0c             	sub    $0xc,%esp
  80cfec:	0f b7 03             	movzwl (%ebx),%eax
  80cfef:	50                   	push   %eax
  80cff0:	e8 65 a6 ff ff       	call   80765a <ntohs>
  80cff5:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80cff8:	8b 1d f0 b2 b3 00    	mov    0xb3b2f0,%ebx
  80cffe:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d002:	89 04 24             	mov    %eax,(%esp)
  80d005:	e8 50 a6 ff ff       	call   80765a <ntohs>
  80d00a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d00e:	8b 1d f0 b2 b3 00    	mov    0xb3b2f0,%ebx
  80d014:	83 c4 04             	add    $0x4,%esp
  80d017:	ff 73 04             	pushl  0x4(%ebx)
  80d01a:	e8 7f a8 ff ff       	call   80789e <ntohl>
  80d01f:	89 43 04             	mov    %eax,0x4(%ebx)
  80d022:	a3 e8 b2 b3 00       	mov    %eax,0xb3b2e8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d027:	8b 1d f0 b2 b3 00    	mov    0xb3b2f0,%ebx
  80d02d:	83 c4 04             	add    $0x4,%esp
  80d030:	ff 73 08             	pushl  0x8(%ebx)
  80d033:	e8 66 a8 ff ff       	call   80789e <ntohl>
  80d038:	89 43 08             	mov    %eax,0x8(%ebx)
  80d03b:	a3 e4 b2 b3 00       	mov    %eax,0xb3b2e4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d040:	8b 1d f0 b2 b3 00    	mov    0xb3b2f0,%ebx
  80d046:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d04a:	89 04 24             	mov    %eax,(%esp)
  80d04d:	e8 08 a6 ff ff       	call   80765a <ntohs>
  80d052:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d056:	a1 f0 b2 b3 00       	mov    0xb3b2f0,%eax
  80d05b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d05f:	89 04 24             	mov    %eax,(%esp)
  80d062:	e8 f3 a5 ff ff       	call   80765a <ntohs>
  80d067:	89 c1                	mov    %eax,%ecx
  80d069:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d06d:	83 e0 3f             	and    $0x3f,%eax
  80d070:	a2 e0 b2 b3 00       	mov    %al,0xb3b2e0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d075:	83 c4 10             	add    $0x10,%esp
  80d078:	89 c8                	mov    %ecx,%eax
  80d07a:	a8 03                	test   $0x3,%al
  80d07c:	0f 95 c0             	setne  %al
  80d07f:	0f b6 c0             	movzbl %al,%eax
  80d082:	66 03 46 08          	add    0x8(%esi),%ax
  80d086:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d08a:	66 a3 de b2 b3 00    	mov    %ax,0xb3b2de
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d090:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
  80d095:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80d098:	8b 15 f0 b2 b3 00    	mov    0xb3b2f0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d09e:	8b 0d ec b2 b3 00    	mov    0xb3b2ec,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0a4:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80d0a6:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0ab:	e9 d1 00 00 00       	jmp    80d181 <tcp_input+0x2d8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d0b0:	8b 43 10             	mov    0x10(%ebx),%eax
  80d0b3:	85 c0                	test   %eax,%eax
  80d0b5:	75 17                	jne    80d0ce <tcp_input+0x225>
  80d0b7:	83 ec 04             	sub    $0x4,%esp
  80d0ba:	68 44 2f 81 00       	push   $0x812f44
  80d0bf:	68 b5 00 00 00       	push   $0xb5
  80d0c4:	68 68 30 81 00       	push   $0x813068
  80d0c9:	e8 13 13 00 00       	call   80e3e1 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d0ce:	83 f8 0a             	cmp    $0xa,%eax
  80d0d1:	75 17                	jne    80d0ea <tcp_input+0x241>
  80d0d3:	83 ec 04             	sub    $0x4,%esp
  80d0d6:	68 6c 2f 81 00       	push   $0x812f6c
  80d0db:	68 b6 00 00 00       	push   $0xb6
  80d0e0:	68 68 30 81 00       	push   $0x813068
  80d0e5:	e8 f7 12 00 00       	call   80e3e1 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d0ea:	83 f8 01             	cmp    $0x1,%eax
  80d0ed:	75 17                	jne    80d106 <tcp_input+0x25d>
  80d0ef:	83 ec 04             	sub    $0x4,%esp
  80d0f2:	68 98 2f 81 00       	push   $0x812f98
  80d0f7:	68 b7 00 00 00       	push   $0xb7
  80d0fc:	68 68 30 81 00       	push   $0x813068
  80d101:	e8 db 12 00 00       	call   80e3e1 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80d106:	0f b7 02             	movzwl (%edx),%eax
  80d109:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d10d:	75 6d                	jne    80d17c <tcp_input+0x2d3>
  80d10f:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d113:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d117:	75 63                	jne    80d17c <tcp_input+0x2d3>
       pcb->local_port == tcphdr->dest &&
  80d119:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d11c:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d11f:	75 5b                	jne    80d17c <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d121:	8b 41 10             	mov    0x10(%ecx),%eax
  80d124:	39 03                	cmp    %eax,(%ebx)
  80d126:	75 54                	jne    80d17c <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d128:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d12b:	39 d8                	cmp    %ebx,%eax
  80d12d:	75 17                	jne    80d146 <tcp_input+0x29d>
  80d12f:	83 ec 04             	sub    $0x4,%esp
  80d132:	68 c0 2f 81 00       	push   $0x812fc0
  80d137:	68 c0 00 00 00       	push   $0xc0
  80d13c:	68 68 30 81 00       	push   $0x813068
  80d141:	e8 9b 12 00 00       	call   80e3e1 <_panic>
      if (prev != NULL) {
  80d146:	85 ff                	test   %edi,%edi
  80d148:	0f 84 60 0a 00 00    	je     80dbae <tcp_input+0xd05>
        prev->next = pcb->next;
  80d14e:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d151:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d154:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d157:	89 1d 7c b3 b3 00    	mov    %ebx,0xb3b37c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d15d:	39 d8                	cmp    %ebx,%eax
  80d15f:	0f 85 6e 02 00 00    	jne    80d3d3 <tcp_input+0x52a>
  80d165:	83 ec 04             	sub    $0x4,%esp
  80d168:	68 ec 2f 81 00       	push   $0x812fec
  80d16d:	68 c6 00 00 00       	push   $0xc6
  80d172:	68 68 30 81 00       	push   $0x813068
  80d177:	e8 65 12 00 00       	call   80e3e1 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d17c:	89 df                	mov    %ebx,%edi
  80d17e:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d181:	85 db                	test   %ebx,%ebx
  80d183:	0f 85 27 ff ff ff    	jne    80d0b0 <tcp_input+0x207>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d189:	8b 1d 90 b3 b3 00    	mov    0xb3b390,%ebx
  80d18f:	e9 88 00 00 00       	jmp    80d21c <tcp_input+0x373>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d194:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d198:	74 17                	je     80d1b1 <tcp_input+0x308>
  80d19a:	83 ec 04             	sub    $0x4,%esp
  80d19d:	68 18 30 81 00       	push   $0x813018
  80d1a2:	68 d0 00 00 00       	push   $0xd0
  80d1a7:	68 68 30 81 00       	push   $0x813068
  80d1ac:	e8 30 12 00 00       	call   80e3e1 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80d1b1:	0f b7 02             	movzwl (%edx),%eax
  80d1b4:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d1b8:	75 5f                	jne    80d219 <tcp_input+0x370>
  80d1ba:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d1be:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d1c2:	75 55                	jne    80d219 <tcp_input+0x370>
         pcb->local_port == tcphdr->dest &&
  80d1c4:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d1c7:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d1ca:	75 4d                	jne    80d219 <tcp_input+0x370>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d1cc:	8b 41 10             	mov    0x10(%ecx),%eax
  80d1cf:	39 03                	cmp    %eax,(%ebx)
  80d1d1:	75 46                	jne    80d219 <tcp_input+0x370>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d1d3:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d1d7:	03 05 e8 b2 b3 00    	add    0xb3b2e8,%eax
  80d1dd:	89 c2                	mov    %eax,%edx
  80d1df:	2b 53 24             	sub    0x24(%ebx),%edx
  80d1e2:	85 d2                	test   %edx,%edx
  80d1e4:	7e 03                	jle    80d1e9 <tcp_input+0x340>
    pcb->rcv_nxt = seqno + tcplen;
  80d1e6:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80d1e9:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80d1ee:	74 10                	je     80d200 <tcp_input+0x357>
    tcp_ack_now(pcb);
  80d1f0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d1f4:	83 ec 0c             	sub    $0xc,%esp
  80d1f7:	53                   	push   %ebx
  80d1f8:	e8 a6 ad ff ff       	call   807fa3 <tcp_output>
  80d1fd:	83 c4 10             	add    $0x10,%esp
  }
  return tcp_output(pcb);
  80d200:	83 ec 0c             	sub    $0xc,%esp
  80d203:	53                   	push   %ebx
  80d204:	e8 9a ad ff ff       	call   807fa3 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80d209:	89 34 24             	mov    %esi,(%esp)
  80d20c:	e8 de 75 ff ff       	call   8047ef <pbuf_free>
        return;
  80d211:	83 c4 10             	add    $0x10,%esp
  80d214:	e9 d6 09 00 00       	jmp    80dbef <tcp_input+0xd46>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d219:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d21c:	85 db                	test   %ebx,%ebx
  80d21e:	0f 85 70 ff ff ff    	jne    80d194 <tcp_input+0x2eb>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d224:	a1 84 b3 b3 00       	mov    0xb3b384,%eax
  80d229:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d22c:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80d22e:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d233:	e9 8e 01 00 00       	jmp    80d3c6 <tcp_input+0x51d>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d238:	85 db                	test   %ebx,%ebx
  80d23a:	74 0f                	je     80d24b <tcp_input+0x3a2>
  80d23c:	8b 03                	mov    (%ebx),%eax
  80d23e:	85 c0                	test   %eax,%eax
  80d240:	74 09                	je     80d24b <tcp_input+0x3a2>
  80d242:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d245:	0f 85 76 01 00 00    	jne    80d3c1 <tcp_input+0x518>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d24b:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d24f:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d253:	0f 85 68 01 00 00    	jne    80d3c1 <tcp_input+0x518>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80d259:	85 ff                	test   %edi,%edi
  80d25b:	74 12                	je     80d26f <tcp_input+0x3c6>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d25d:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d260:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d263:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d266:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d269:	89 1d 84 b3 b3 00    	mov    %ebx,0xb3b384
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80d26f:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80d273:	74 3a                	je     80d2af <tcp_input+0x406>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  80d275:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80d27a:	83 ec 08             	sub    $0x8,%esp
  80d27d:	0f b7 0a             	movzwl (%edx),%ecx
  80d280:	51                   	push   %ecx
  80d281:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d285:	52                   	push   %edx
  80d286:	8d 50 0c             	lea    0xc(%eax),%edx
  80d289:	52                   	push   %edx
  80d28a:	83 c0 10             	add    $0x10,%eax
  80d28d:	50                   	push   %eax
  80d28e:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d292:	03 05 e8 b2 b3 00    	add    0xb3b2e8,%eax
  80d298:	50                   	push   %eax
  80d299:	a1 e4 b2 b3 00       	mov    0xb3b2e4,%eax
  80d29e:	83 c0 01             	add    $0x1,%eax
  80d2a1:	50                   	push   %eax
  80d2a2:	e8 73 b1 ff ff       	call   80841a <tcp_rst>
  80d2a7:	83 c4 20             	add    $0x20,%esp
  80d2aa:	e9 01 01 00 00       	jmp    80d3b0 <tcp_input+0x507>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80d2af:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80d2b3:	0f 84 f7 00 00 00    	je     80d3b0 <tcp_input+0x507>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80d2b9:	83 ec 0c             	sub    $0xc,%esp
  80d2bc:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80d2c0:	50                   	push   %eax
  80d2c1:	e8 3b 8e ff ff       	call   806101 <tcp_alloc>
  80d2c6:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80d2c8:	83 c4 10             	add    $0x10,%esp
  80d2cb:	85 c0                	test   %eax,%eax
  80d2cd:	0f 84 dd 00 00 00    	je     80d3b0 <tcp_input+0x507>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d2d3:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
  80d2d8:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d2db:	74 05                	je     80d2e2 <tcp_input+0x439>
  80d2dd:	8b 50 10             	mov    0x10(%eax),%edx
  80d2e0:	eb 05                	jmp    80d2e7 <tcp_input+0x43e>
  80d2e2:	ba 00 00 00 00       	mov    $0x0,%edx
  80d2e7:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80d2e9:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80d2ed:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d2f1:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d2f4:	74 05                	je     80d2fb <tcp_input+0x452>
  80d2f6:	8b 40 0c             	mov    0xc(%eax),%eax
  80d2f9:	eb 05                	jmp    80d300 <tcp_input+0x457>
  80d2fb:	b8 00 00 00 00       	mov    $0x0,%eax
  80d300:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80d303:	8b 15 f0 b2 b3 00    	mov    0xb3b2f0,%edx
  80d309:	0f b7 02             	movzwl (%edx),%eax
  80d30c:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80d310:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80d317:	a1 e8 b2 b3 00       	mov    0xb3b2e8,%eax
  80d31c:	8d 48 01             	lea    0x1(%eax),%ecx
  80d31f:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80d322:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d326:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80d32a:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d32e:	83 e8 01             	sub    $0x1,%eax
  80d331:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80d334:	8b 43 18             	mov    0x18(%ebx),%eax
  80d337:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80d33a:	8b 43 20             	mov    0x20(%ebx),%eax
  80d33d:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d343:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80d347:	66 25 99 01          	and    $0x199,%ax
  80d34b:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80d34f:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
  80d354:	89 47 0c             	mov    %eax,0xc(%edi)
  80d357:	89 3d 7c b3 b3 00    	mov    %edi,0xb3b37c
  80d35d:	e8 d7 4e ff ff       	call   802239 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80d362:	89 f8                	mov    %edi,%eax
  80d364:	e8 28 ee ff ff       	call   80c191 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d369:	83 ec 08             	sub    $0x8,%esp
  80d36c:	8d 47 04             	lea    0x4(%edi),%eax
  80d36f:	50                   	push   %eax
  80d370:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80d374:	50                   	push   %eax
  80d375:	e8 14 8f ff ff       	call   80628e <tcp_eff_send_mss>
  80d37a:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80d37e:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d385:	e8 dd a2 ff ff       	call   807667 <htonl>
  80d38a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d38d:	83 c4 0c             	add    $0xc,%esp
  80d390:	6a 04                	push   $0x4
  80d392:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d395:	50                   	push   %eax
  80d396:	6a 00                	push   $0x0
  80d398:	6a 12                	push   $0x12
  80d39a:	6a 00                	push   $0x0
  80d39c:	6a 00                	push   $0x0
  80d39e:	57                   	push   %edi
  80d39f:	e8 0a a5 ff ff       	call   8078ae <tcp_enqueue>
    return tcp_output(npcb);
  80d3a4:	83 c4 14             	add    $0x14,%esp
  80d3a7:	57                   	push   %edi
  80d3a8:	e8 f6 ab ff ff       	call   807fa3 <tcp_output>
  80d3ad:	83 c4 10             	add    $0x10,%esp
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80d3b0:	83 ec 0c             	sub    $0xc,%esp
  80d3b3:	56                   	push   %esi
  80d3b4:	e8 36 74 ff ff       	call   8047ef <pbuf_free>
        return;
  80d3b9:	83 c4 10             	add    $0x10,%esp
  80d3bc:	e9 2e 08 00 00       	jmp    80dbef <tcp_input+0xd46>
  80d3c1:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d3c3:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d3c6:	85 db                	test   %ebx,%ebx
  80d3c8:	0f 85 6a fe ff ff    	jne    80d238 <tcp_input+0x38f>
  80d3ce:	e9 79 07 00 00       	jmp    80db4c <tcp_input+0xca3>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  80d3d3:	85 db                	test   %ebx,%ebx
  80d3d5:	0f 84 71 07 00 00    	je     80db4c <tcp_input+0xca3>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80d3db:	c7 05 f4 b2 b3 00 00 	movl   $0x0,0xb3b2f4
  80d3e2:	00 00 00 
    inseg.len = p->tot_len;
  80d3e5:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d3e9:	66 a3 00 b3 b3 00    	mov    %ax,0xb3b300
    inseg.dataptr = p->payload;
  80d3ef:	8b 46 04             	mov    0x4(%esi),%eax
  80d3f2:	a3 fc b2 b3 00       	mov    %eax,0xb3b2fc
    inseg.p = p;
  80d3f7:	89 35 f8 b2 b3 00    	mov    %esi,0xb3b2f8
    inseg.tcphdr = tcphdr;
  80d3fd:	a1 f0 b2 b3 00       	mov    0xb3b2f0,%eax
  80d402:	a3 04 b3 b3 00       	mov    %eax,0xb3b304

    recv_data = NULL;
  80d407:	c7 05 d8 b2 b3 00 00 	movl   $0x0,0xb3b2d8
  80d40e:	00 00 00 
    recv_flags = 0;
  80d411:	c6 05 dc b2 b3 00 00 	movb   $0x0,0xb3b2dc

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80d418:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d41e:	85 c0                	test   %eax,%eax
  80d420:	74 45                	je     80d467 <tcp_input+0x5be>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d422:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d428:	85 d2                	test   %edx,%edx
  80d42a:	74 12                	je     80d43e <tcp_input+0x595>
  80d42c:	6a 00                	push   $0x0
  80d42e:	50                   	push   %eax
  80d42f:	53                   	push   %ebx
  80d430:	ff 73 18             	pushl  0x18(%ebx)
  80d433:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d435:	83 c4 10             	add    $0x10,%esp
  80d438:	84 c0                	test   %al,%al
  80d43a:	74 0e                	je     80d44a <tcp_input+0x5a1>
  80d43c:	eb 18                	jmp    80d456 <tcp_input+0x5ad>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d43e:	83 ec 0c             	sub    $0xc,%esp
  80d441:	50                   	push   %eax
  80d442:	e8 a8 73 ff ff       	call   8047ef <pbuf_free>
  80d447:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80d44a:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d451:	00 00 00 
  80d454:	eb 11                	jmp    80d467 <tcp_input+0x5be>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80d456:	83 ec 0c             	sub    $0xc,%esp
  80d459:	56                   	push   %esi
  80d45a:	e8 90 73 ff ff       	call   8047ef <pbuf_free>
        return;
  80d45f:	83 c4 10             	add    $0x10,%esp
  80d462:	e9 88 07 00 00       	jmp    80dbef <tcp_input+0xd46>
      }
    }

    tcp_input_pcb = pcb;
  80d467:	89 1d 98 b3 b3 00    	mov    %ebx,0xb3b398
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80d46d:	0f b6 05 e0 b2 b3 00 	movzbl 0xb3b2e0,%eax
  80d474:	a8 04                	test   $0x4,%al
  80d476:	74 5e                	je     80d4d6 <tcp_input+0x62d>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80d478:	8b 53 10             	mov    0x10(%ebx),%edx
  80d47b:	83 fa 02             	cmp    $0x2,%edx
  80d47e:	75 0f                	jne    80d48f <tcp_input+0x5e6>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d480:	a1 e4 b2 b3 00       	mov    0xb3b2e4,%eax
  80d485:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d488:	74 3c                	je     80d4c6 <tcp_input+0x61d>
  80d48a:	e9 69 05 00 00       	jmp    80d9f8 <tcp_input+0xb4f>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d48f:	a1 e8 b2 b3 00       	mov    0xb3b2e8,%eax
  80d494:	2b 43 24             	sub    0x24(%ebx),%eax
  80d497:	0f 88 5b 05 00 00    	js     80d9f8 <tcp_input+0xb4f>
  80d49d:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d4a1:	29 c8                	sub    %ecx,%eax
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d4a3:	85 c0                	test   %eax,%eax
  80d4a5:	0f 8f 10 07 00 00    	jg     80dbbb <tcp_input+0xd12>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d4ab:	85 d2                	test   %edx,%edx
  80d4ad:	75 17                	jne    80d4c6 <tcp_input+0x61d>
  80d4af:	83 ec 04             	sub    $0x4,%esp
  80d4b2:	68 48 30 81 00       	push   $0x813048
  80d4b7:	68 09 02 00 00       	push   $0x209
  80d4bc:	68 68 30 81 00       	push   $0x813068
  80d4c1:	e8 1b 0f 00 00       	call   80e3e1 <_panic>
      recv_flags = TF_RESET;
  80d4c6:	c6 05 dc b2 b3 00 08 	movb   $0x8,0xb3b2dc
      pcb->flags &= ~TF_ACK_DELAY;
  80d4cd:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80d4d1:	e9 e5 06 00 00       	jmp    80dbbb <tcp_input+0xd12>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80d4d6:	8b 15 80 b3 b3 00    	mov    0xb3b380,%edx
  80d4dc:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d4df:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80d4e6:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d4ea:	0f 87 08 05 00 00    	ja     80d9f8 <tcp_input+0xb4f>
  80d4f0:	8b 53 10             	mov    0x10(%ebx),%edx
  80d4f3:	ff 24 95 ec 30 81 00 	jmp    *0x8130ec(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d4fa:	83 e0 12             	and    $0x12,%eax
  80d4fd:	3c 12                	cmp    $0x12,%al
  80d4ff:	0f 85 04 01 00 00    	jne    80d609 <tcp_input+0x760>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d505:	83 ec 0c             	sub    $0xc,%esp
  80d508:	8b 43 78             	mov    0x78(%ebx),%eax
  80d50b:	8b 40 10             	mov    0x10(%eax),%eax
  80d50e:	ff 70 04             	pushl  0x4(%eax)
  80d511:	e8 88 a3 ff ff       	call   80789e <ntohl>
  80d516:	8d 50 01             	lea    0x1(%eax),%edx
  80d519:	83 c4 10             	add    $0x10,%esp
  80d51c:	3b 15 e4 b2 b3 00    	cmp    0xb3b2e4,%edx
  80d522:	0f 85 e1 00 00 00    	jne    80d609 <tcp_input+0x760>
      pcb->snd_buf++;
  80d528:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d52d:	a1 e8 b2 b3 00       	mov    0xb3b2e8,%eax
  80d532:	8d 48 01             	lea    0x1(%eax),%ecx
  80d535:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d538:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d53b:	8b 15 f0 b2 b3 00    	mov    0xb3b2f0,%edx
  80d541:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d545:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d549:	83 e8 01             	sub    $0x1,%eax
  80d54c:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d54f:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80d556:	89 d8                	mov    %ebx,%eax
  80d558:	e8 34 ec ff ff       	call   80c191 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d55d:	83 ec 08             	sub    $0x8,%esp
  80d560:	8d 43 04             	lea    0x4(%ebx),%eax
  80d563:	50                   	push   %eax
  80d564:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d568:	50                   	push   %eax
  80d569:	e8 20 8d ff ff       	call   80628e <tcp_eff_send_mss>
  80d56e:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80d572:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d575:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d579:	83 c4 10             	add    $0x10,%esp
  80d57c:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80d57f:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d584:	0f 44 c2             	cmove  %edx,%eax
  80d587:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d58b:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d58f:	66 85 c0             	test   %ax,%ax
  80d592:	75 17                	jne    80d5ab <tcp_input+0x702>
  80d594:	83 ec 04             	sub    $0x4,%esp
  80d597:	68 c1 30 81 00       	push   $0x8130c1
  80d59c:	68 35 02 00 00       	push   $0x235
  80d5a1:	68 68 30 81 00       	push   $0x813068
  80d5a6:	e8 36 0e 00 00       	call   80e3e1 <_panic>
      --pcb->snd_queuelen;
  80d5ab:	83 e8 01             	sub    $0x1,%eax
  80d5ae:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80d5b2:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d5b5:	8b 10                	mov    (%eax),%edx
  80d5b7:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d5ba:	85 d2                	test   %edx,%edx
  80d5bc:	75 08                	jne    80d5c6 <tcp_input+0x71d>
        pcb->rtime = -1;
  80d5be:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d5c4:	eb 0a                	jmp    80d5d0 <tcp_input+0x727>
      else {
        pcb->rtime = 0;
  80d5c6:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d5cc:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80d5d0:	83 ec 0c             	sub    $0xc,%esp
  80d5d3:	50                   	push   %eax
  80d5d4:	e8 6a 81 ff ff       	call   805743 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d5d9:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d5df:	83 c4 10             	add    $0x10,%esp
  80d5e2:	85 c0                	test   %eax,%eax
  80d5e4:	74 0e                	je     80d5f4 <tcp_input+0x74b>
  80d5e6:	83 ec 04             	sub    $0x4,%esp
  80d5e9:	6a 00                	push   $0x0
  80d5eb:	53                   	push   %ebx
  80d5ec:	ff 73 18             	pushl  0x18(%ebx)
  80d5ef:	ff d0                	call   *%eax
  80d5f1:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d5f4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d5f8:	83 ec 0c             	sub    $0xc,%esp
  80d5fb:	53                   	push   %ebx
  80d5fc:	e8 a2 a9 ff ff       	call   807fa3 <tcp_output>
  80d601:	83 c4 10             	add    $0x10,%esp
  80d604:	e9 b2 05 00 00       	jmp    80dbbb <tcp_input+0xd12>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80d609:	f6 05 e0 b2 b3 00 10 	testb  $0x10,0xb3b2e0
  80d610:	0f 84 a5 05 00 00    	je     80dbbb <tcp_input+0xd12>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80d616:	8b 15 f0 b2 b3 00    	mov    0xb3b2f0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d61c:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
  80d621:	83 ec 08             	sub    $0x8,%esp
  80d624:	0f b7 0a             	movzwl (%edx),%ecx
  80d627:	51                   	push   %ecx
  80d628:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d62c:	52                   	push   %edx
  80d62d:	8d 50 0c             	lea    0xc(%eax),%edx
  80d630:	52                   	push   %edx
  80d631:	83 c0 10             	add    $0x10,%eax
  80d634:	50                   	push   %eax
  80d635:	0f b7 05 de b2 b3 00 	movzwl 0xb3b2de,%eax
  80d63c:	03 05 e8 b2 b3 00    	add    0xb3b2e8,%eax
  80d642:	50                   	push   %eax
  80d643:	ff 35 e4 b2 b3 00    	pushl  0xb3b2e4
  80d649:	e8 cc ad ff ff       	call   80841a <tcp_rst>
  80d64e:	83 c4 20             	add    $0x20,%esp
  80d651:	e9 65 05 00 00       	jmp    80dbbb <tcp_input+0xd12>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80d656:	83 e0 14             	and    $0x14,%eax
  80d659:	3c 10                	cmp    $0x10,%al
  80d65b:	0f 85 5a 05 00 00    	jne    80dbbb <tcp_input+0xd12>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d661:	8b 15 e4 b2 b3 00    	mov    0xb3b2e4,%edx
  80d667:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d66a:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d66d:	0f 88 b5 00 00 00    	js     80d728 <tcp_input+0x87f>
  80d673:	89 d0                	mov    %edx,%eax
  80d675:	2b 43 54             	sub    0x54(%ebx),%eax
  80d678:	85 c0                	test   %eax,%eax
  80d67a:	0f 8f a8 00 00 00    	jg     80d728 <tcp_input+0x87f>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80d680:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d687:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d68d:	85 c0                	test   %eax,%eax
  80d68f:	75 17                	jne    80d6a8 <tcp_input+0x7ff>
  80d691:	83 ec 04             	sub    $0x4,%esp
  80d694:	68 d7 30 81 00       	push   $0x8130d7
  80d699:	68 5b 02 00 00       	push   $0x25b
  80d69e:	68 68 30 81 00       	push   $0x813068
  80d6a3:	e8 39 0d 00 00       	call   80e3e1 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d6a8:	83 ec 04             	sub    $0x4,%esp
  80d6ab:	6a 00                	push   $0x0
  80d6ad:	53                   	push   %ebx
  80d6ae:	ff 73 18             	pushl  0x18(%ebx)
  80d6b1:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d6b3:	83 c4 10             	add    $0x10,%esp
  80d6b6:	84 c0                	test   %al,%al
  80d6b8:	74 1b                	je     80d6d5 <tcp_input+0x82c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80d6ba:	83 ec 0c             	sub    $0xc,%esp
  80d6bd:	53                   	push   %ebx
  80d6be:	e8 a5 84 ff ff       	call   805b68 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d6c3:	c7 05 98 b3 b3 00 00 	movl   $0x0,0xb3b398
  80d6ca:	00 00 00 
  80d6cd:	83 c4 10             	add    $0x10,%esp
  80d6d0:	e9 4f 04 00 00       	jmp    80db24 <tcp_input+0xc7b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80d6d5:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80d6d9:	89 d8                	mov    %ebx,%eax
  80d6db:	e8 64 eb ff ff       	call   80c244 <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d6e0:	66 83 fe 01          	cmp    $0x1,%si
  80d6e4:	75 09                	jne    80d6ef <tcp_input+0x846>
  80d6e6:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d6ea:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d6ed:	eb 04                	jmp    80d6f3 <tcp_input+0x84a>
  80d6ef:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d6f3:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80d6f7:	84 c0                	test   %al,%al
  80d6f9:	0f 84 bc 04 00 00    	je     80dbbb <tcp_input+0xd12>
  80d6ff:	f6 05 e0 b2 b3 00 01 	testb  $0x1,0xb3b2e0
  80d706:	0f 84 af 04 00 00    	je     80dbbb <tcp_input+0xd12>
          tcp_ack_now(pcb);
  80d70c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d710:	83 ec 0c             	sub    $0xc,%esp
  80d713:	53                   	push   %ebx
  80d714:	e8 8a a8 ff ff       	call   807fa3 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d719:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d720:	83 c4 10             	add    $0x10,%esp
  80d723:	e9 93 04 00 00       	jmp    80dbbb <tcp_input+0xd12>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80d728:	8b 0d f0 b2 b3 00    	mov    0xb3b2f0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d72e:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
  80d733:	83 ec 08             	sub    $0x8,%esp
  80d736:	0f b7 31             	movzwl (%ecx),%esi
  80d739:	56                   	push   %esi
  80d73a:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d73e:	51                   	push   %ecx
  80d73f:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d742:	51                   	push   %ecx
  80d743:	83 c0 10             	add    $0x10,%eax
  80d746:	50                   	push   %eax
  80d747:	0f b7 05 de b2 b3 00 	movzwl 0xb3b2de,%eax
  80d74e:	03 05 e8 b2 b3 00    	add    0xb3b2e8,%eax
  80d754:	50                   	push   %eax
  80d755:	52                   	push   %edx
  80d756:	e8 bf ac ff ff       	call   80841a <tcp_rst>
  80d75b:	83 c4 20             	add    $0x20,%esp
  80d75e:	e9 58 04 00 00       	jmp    80dbbb <tcp_input+0xd12>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80d763:	89 d8                	mov    %ebx,%eax
  80d765:	e8 da ea ff ff       	call   80c244 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d76a:	84 c0                	test   %al,%al
  80d76c:	0f 84 49 04 00 00    	je     80dbbb <tcp_input+0xd12>
  80d772:	f6 05 e0 b2 b3 00 01 	testb  $0x1,0xb3b2e0
  80d779:	0f 84 3c 04 00 00    	je     80dbbb <tcp_input+0xd12>
      tcp_ack_now(pcb);
  80d77f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d783:	83 ec 0c             	sub    $0xc,%esp
  80d786:	53                   	push   %ebx
  80d787:	e8 17 a8 ff ff       	call   807fa3 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d78c:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d793:	83 c4 10             	add    $0x10,%esp
  80d796:	e9 20 04 00 00       	jmp    80dbbb <tcp_input+0xd12>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80d79b:	89 d8                	mov    %ebx,%eax
  80d79d:	e8 a2 ea ff ff       	call   80c244 <tcp_receive>
    if (flags & TCP_FIN) {
  80d7a2:	0f b6 05 e0 b2 b3 00 	movzbl 0xb3b2e0,%eax
  80d7a9:	a8 01                	test   $0x1,%al
  80d7ab:	0f 84 b7 00 00 00    	je     80d868 <tcp_input+0x9bf>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d7b1:	a8 10                	test   $0x10,%al
  80d7b3:	0f 84 93 00 00 00    	je     80d84c <tcp_input+0x9a3>
  80d7b9:	a1 e4 b2 b3 00       	mov    0xb3b2e4,%eax
  80d7be:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d7c1:	0f 85 85 00 00 00    	jne    80d84c <tcp_input+0x9a3>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80d7c7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7cb:	83 ec 0c             	sub    $0xc,%esp
  80d7ce:	53                   	push   %ebx
  80d7cf:	e8 cf a7 ff ff       	call   807fa3 <tcp_output>
        tcp_pcb_purge(pcb);
  80d7d4:	89 1c 24             	mov    %ebx,(%esp)
  80d7d7:	e8 87 80 ff ff       	call   805863 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d7dc:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
  80d7e1:	83 c4 10             	add    $0x10,%esp
  80d7e4:	39 d8                	cmp    %ebx,%eax
  80d7e6:	75 0a                	jne    80d7f2 <tcp_input+0x949>
  80d7e8:	8b 40 0c             	mov    0xc(%eax),%eax
  80d7eb:	a3 7c b3 b3 00       	mov    %eax,0xb3b37c
  80d7f0:	eb 3b                	jmp    80d82d <tcp_input+0x984>
  80d7f2:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  80d7f7:	89 de                	mov    %ebx,%esi
  80d7f9:	eb 22                	jmp    80d81d <tcp_input+0x974>
  80d7fb:	8b 50 0c             	mov    0xc(%eax),%edx
  80d7fe:	39 f2                	cmp    %esi,%edx
  80d800:	0f 94 c3             	sete   %bl
  80d803:	85 d2                	test   %edx,%edx
  80d805:	0f 95 c1             	setne  %cl
  80d808:	84 cb                	test   %cl,%bl
  80d80a:	74 0f                	je     80d81b <tcp_input+0x972>
  80d80c:	89 f3                	mov    %esi,%ebx
  80d80e:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  80d813:	8b 56 0c             	mov    0xc(%esi),%edx
  80d816:	89 50 0c             	mov    %edx,0xc(%eax)
  80d819:	eb 12                	jmp    80d82d <tcp_input+0x984>
  80d81b:	89 d0                	mov    %edx,%eax
  80d81d:	85 c0                	test   %eax,%eax
  80d81f:	75 da                	jne    80d7fb <tcp_input+0x952>
  80d821:	89 f3                	mov    %esi,%ebx
  80d823:	c7 05 88 b3 b3 00 00 	movl   $0x0,0xb3b388
  80d82a:	00 00 00 
        pcb->state = TIME_WAIT;
  80d82d:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80d834:	a1 90 b3 b3 00       	mov    0xb3b390,%eax
  80d839:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d83c:	89 1d 90 b3 b3 00    	mov    %ebx,0xb3b390
  80d842:	e8 f2 49 ff ff       	call   802239 <tcp_timer_needed>
  80d847:	e9 6f 03 00 00       	jmp    80dbbb <tcp_input+0xd12>
      } else {
        tcp_ack_now(pcb);
  80d84c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d850:	83 ec 0c             	sub    $0xc,%esp
  80d853:	53                   	push   %ebx
  80d854:	e8 4a a7 ff ff       	call   807fa3 <tcp_output>
        pcb->state = CLOSING;
  80d859:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d860:	83 c4 10             	add    $0x10,%esp
  80d863:	e9 53 03 00 00       	jmp    80dbbb <tcp_input+0xd12>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d868:	a8 10                	test   $0x10,%al
  80d86a:	0f 84 4b 03 00 00    	je     80dbbb <tcp_input+0xd12>
  80d870:	a1 e4 b2 b3 00       	mov    0xb3b2e4,%eax
  80d875:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d878:	0f 85 3d 03 00 00    	jne    80dbbb <tcp_input+0xd12>
      pcb->state = FIN_WAIT_2;
  80d87e:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80d885:	e9 31 03 00 00       	jmp    80dbbb <tcp_input+0xd12>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80d88a:	89 d8                	mov    %ebx,%eax
  80d88c:	e8 b3 e9 ff ff       	call   80c244 <tcp_receive>
    if (flags & TCP_FIN) {
  80d891:	f6 05 e0 b2 b3 00 01 	testb  $0x1,0xb3b2e0
  80d898:	0f 84 1d 03 00 00    	je     80dbbb <tcp_input+0xd12>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d89e:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d8a2:	83 ec 0c             	sub    $0xc,%esp
  80d8a5:	53                   	push   %ebx
  80d8a6:	e8 f8 a6 ff ff       	call   807fa3 <tcp_output>
      tcp_pcb_purge(pcb);
  80d8ab:	89 1c 24             	mov    %ebx,(%esp)
  80d8ae:	e8 b0 7f ff ff       	call   805863 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d8b3:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
  80d8b8:	83 c4 10             	add    $0x10,%esp
  80d8bb:	39 d8                	cmp    %ebx,%eax
  80d8bd:	75 0a                	jne    80d8c9 <tcp_input+0xa20>
  80d8bf:	8b 40 0c             	mov    0xc(%eax),%eax
  80d8c2:	a3 7c b3 b3 00       	mov    %eax,0xb3b37c
  80d8c7:	eb 3b                	jmp    80d904 <tcp_input+0xa5b>
  80d8c9:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  80d8ce:	89 de                	mov    %ebx,%esi
  80d8d0:	eb 22                	jmp    80d8f4 <tcp_input+0xa4b>
  80d8d2:	8b 50 0c             	mov    0xc(%eax),%edx
  80d8d5:	39 f2                	cmp    %esi,%edx
  80d8d7:	0f 94 c3             	sete   %bl
  80d8da:	85 d2                	test   %edx,%edx
  80d8dc:	0f 95 c1             	setne  %cl
  80d8df:	84 cb                	test   %cl,%bl
  80d8e1:	74 0f                	je     80d8f2 <tcp_input+0xa49>
  80d8e3:	89 f3                	mov    %esi,%ebx
  80d8e5:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  80d8ea:	8b 56 0c             	mov    0xc(%esi),%edx
  80d8ed:	89 50 0c             	mov    %edx,0xc(%eax)
  80d8f0:	eb 12                	jmp    80d904 <tcp_input+0xa5b>
  80d8f2:	89 d0                	mov    %edx,%eax
  80d8f4:	85 c0                	test   %eax,%eax
  80d8f6:	75 da                	jne    80d8d2 <tcp_input+0xa29>
  80d8f8:	89 f3                	mov    %esi,%ebx
  80d8fa:	c7 05 88 b3 b3 00 00 	movl   $0x0,0xb3b388
  80d901:	00 00 00 
      pcb->state = TIME_WAIT;
  80d904:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d90b:	a1 90 b3 b3 00       	mov    0xb3b390,%eax
  80d910:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d913:	89 1d 90 b3 b3 00    	mov    %ebx,0xb3b390
  80d919:	e8 1b 49 ff ff       	call   802239 <tcp_timer_needed>
  80d91e:	e9 98 02 00 00       	jmp    80dbbb <tcp_input+0xd12>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80d923:	89 d8                	mov    %ebx,%eax
  80d925:	e8 1a e9 ff ff       	call   80c244 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d92a:	f6 05 e0 b2 b3 00 10 	testb  $0x10,0xb3b2e0
  80d931:	0f 84 84 02 00 00    	je     80dbbb <tcp_input+0xd12>
  80d937:	a1 e4 b2 b3 00       	mov    0xb3b2e4,%eax
  80d93c:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d93f:	0f 85 76 02 00 00    	jne    80dbbb <tcp_input+0xd12>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d945:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d949:	83 ec 0c             	sub    $0xc,%esp
  80d94c:	53                   	push   %ebx
  80d94d:	e8 51 a6 ff ff       	call   807fa3 <tcp_output>
      tcp_pcb_purge(pcb);
  80d952:	89 1c 24             	mov    %ebx,(%esp)
  80d955:	e8 09 7f ff ff       	call   805863 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d95a:	a1 7c b3 b3 00       	mov    0xb3b37c,%eax
  80d95f:	83 c4 10             	add    $0x10,%esp
  80d962:	39 d8                	cmp    %ebx,%eax
  80d964:	75 0a                	jne    80d970 <tcp_input+0xac7>
  80d966:	8b 40 0c             	mov    0xc(%eax),%eax
  80d969:	a3 7c b3 b3 00       	mov    %eax,0xb3b37c
  80d96e:	eb 3b                	jmp    80d9ab <tcp_input+0xb02>
  80d970:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  80d975:	89 de                	mov    %ebx,%esi
  80d977:	eb 22                	jmp    80d99b <tcp_input+0xaf2>
  80d979:	8b 50 0c             	mov    0xc(%eax),%edx
  80d97c:	39 f2                	cmp    %esi,%edx
  80d97e:	0f 94 c3             	sete   %bl
  80d981:	85 d2                	test   %edx,%edx
  80d983:	0f 95 c1             	setne  %cl
  80d986:	84 cb                	test   %cl,%bl
  80d988:	74 0f                	je     80d999 <tcp_input+0xaf0>
  80d98a:	89 f3                	mov    %esi,%ebx
  80d98c:	a3 88 b3 b3 00       	mov    %eax,0xb3b388
  80d991:	8b 56 0c             	mov    0xc(%esi),%edx
  80d994:	89 50 0c             	mov    %edx,0xc(%eax)
  80d997:	eb 12                	jmp    80d9ab <tcp_input+0xb02>
  80d999:	89 d0                	mov    %edx,%eax
  80d99b:	85 c0                	test   %eax,%eax
  80d99d:	75 da                	jne    80d979 <tcp_input+0xad0>
  80d99f:	89 f3                	mov    %esi,%ebx
  80d9a1:	c7 05 88 b3 b3 00 00 	movl   $0x0,0xb3b388
  80d9a8:	00 00 00 
      pcb->state = TIME_WAIT;
  80d9ab:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d9b2:	a1 90 b3 b3 00       	mov    0xb3b390,%eax
  80d9b7:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d9ba:	89 1d 90 b3 b3 00    	mov    %ebx,0xb3b390
  80d9c0:	e8 74 48 ff ff       	call   802239 <tcp_timer_needed>
  80d9c5:	e9 f1 01 00 00       	jmp    80dbbb <tcp_input+0xd12>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80d9ca:	89 d8                	mov    %ebx,%eax
  80d9cc:	e8 73 e8 ff ff       	call   80c244 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d9d1:	f6 05 e0 b2 b3 00 10 	testb  $0x10,0xb3b2e0
  80d9d8:	0f 84 dd 01 00 00    	je     80dbbb <tcp_input+0xd12>
  80d9de:	a1 e4 b2 b3 00       	mov    0xb3b2e4,%eax
  80d9e3:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d9e6:	0f 85 cf 01 00 00    	jne    80dbbb <tcp_input+0xd12>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80d9ec:	c6 05 dc b2 b3 00 10 	movb   $0x10,0xb3b2dc
  80d9f3:	e9 c3 01 00 00       	jmp    80dbbb <tcp_input+0xd12>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d9f8:	c7 05 98 b3 b3 00 00 	movl   $0x0,0xb3b398
  80d9ff:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80da02:	0f b6 05 dc b2 b3 00 	movzbl 0xb3b2dc,%eax
  80da09:	a8 08                	test   $0x8,%al
  80da0b:	74 38                	je     80da45 <tcp_input+0xb9c>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80da0d:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80da13:	85 c0                	test   %eax,%eax
  80da15:	74 0d                	je     80da24 <tcp_input+0xb7b>
  80da17:	83 ec 08             	sub    $0x8,%esp
  80da1a:	6a fa                	push   $0xfffffffa
  80da1c:	ff 73 18             	pushl  0x18(%ebx)
  80da1f:	ff d0                	call   *%eax
  80da21:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80da24:	83 ec 08             	sub    $0x8,%esp
  80da27:	53                   	push   %ebx
  80da28:	68 7c b3 b3 00       	push   $0xb3b37c
  80da2d:	e8 ac 7e ff ff       	call   8058de <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80da32:	83 c4 08             	add    $0x8,%esp
  80da35:	53                   	push   %ebx
  80da36:	6a 02                	push   $0x2
  80da38:	e8 3f 6a ff ff       	call   80447c <memp_free>
  80da3d:	83 c4 10             	add    $0x10,%esp
  80da40:	e9 df 00 00 00       	jmp    80db24 <tcp_input+0xc7b>
      } else if (recv_flags & TF_CLOSED) {
  80da45:	a8 10                	test   $0x10,%al
  80da47:	74 21                	je     80da6a <tcp_input+0xbc1>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80da49:	83 ec 08             	sub    $0x8,%esp
  80da4c:	53                   	push   %ebx
  80da4d:	68 7c b3 b3 00       	push   $0xb3b37c
  80da52:	e8 87 7e ff ff       	call   8058de <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80da57:	83 c4 08             	add    $0x8,%esp
  80da5a:	53                   	push   %ebx
  80da5b:	6a 02                	push   $0x2
  80da5d:	e8 1a 6a ff ff       	call   80447c <memp_free>
  80da62:	83 c4 10             	add    $0x10,%esp
  80da65:	e9 ba 00 00 00       	jmp    80db24 <tcp_input+0xc7b>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80da6a:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80da6e:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80da73:	66 85 d2             	test   %dx,%dx
  80da76:	74 1a                	je     80da92 <tcp_input+0xbe9>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80da78:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80da7e:	85 c9                	test   %ecx,%ecx
  80da80:	74 10                	je     80da92 <tcp_input+0xbe9>
  80da82:	83 ec 04             	sub    $0x4,%esp
  80da85:	0f b7 d2             	movzwl %dx,%edx
  80da88:	52                   	push   %edx
  80da89:	53                   	push   %ebx
  80da8a:	ff 73 18             	pushl  0x18(%ebx)
  80da8d:	ff d1                	call   *%ecx
  80da8f:	83 c4 10             	add    $0x10,%esp
        }
      
        if (recv_data != NULL) {
  80da92:	8b 15 d8 b2 b3 00    	mov    0xb3b2d8,%edx
  80da98:	85 d2                	test   %edx,%edx
  80da9a:	74 58                	je     80daf4 <tcp_input+0xc4b>
          if(flags & TCP_PSH) {
  80da9c:	f6 05 e0 b2 b3 00 08 	testb  $0x8,0xb3b2e0
  80daa3:	0f 84 21 01 00 00    	je     80dbca <tcp_input+0xd21>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80daa9:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80daad:	e9 18 01 00 00       	jmp    80dbca <tcp_input+0xd21>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dab2:	6a 00                	push   $0x0
  80dab4:	52                   	push   %edx
  80dab5:	53                   	push   %ebx
  80dab6:	ff 73 18             	pushl  0x18(%ebx)
  80dab9:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80dabb:	83 c4 10             	add    $0x10,%esp
  80dabe:	84 c0                	test   %al,%al
  80dac0:	75 1c                	jne    80dade <tcp_input+0xc35>
  80dac2:	e9 16 01 00 00       	jmp    80dbdd <tcp_input+0xd34>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dac7:	83 ec 0c             	sub    $0xc,%esp
  80daca:	52                   	push   %edx
  80dacb:	e8 1f 6d ff ff       	call   8047ef <pbuf_free>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80dad0:	83 c4 10             	add    $0x10,%esp
  80dad3:	f6 05 dc b2 b3 00 20 	testb  $0x20,0xb3b2dc
  80dada:	75 21                	jne    80dafd <tcp_input+0xc54>
  80dadc:	eb 3a                	jmp    80db18 <tcp_input+0xc6f>
          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80dade:	a1 d8 b2 b3 00       	mov    0xb3b2d8,%eax
  80dae3:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80dae9:	f6 05 dc b2 b3 00 20 	testb  $0x20,0xb3b2dc
  80daf0:	75 0b                	jne    80dafd <tcp_input+0xc54>
  80daf2:	eb 30                	jmp    80db24 <tcp_input+0xc7b>
  80daf4:	f6 05 dc b2 b3 00 20 	testb  $0x20,0xb3b2dc
  80dafb:	74 17                	je     80db14 <tcp_input+0xc6b>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80dafd:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80db03:	85 c0                	test   %eax,%eax
  80db05:	74 11                	je     80db18 <tcp_input+0xc6f>
  80db07:	6a 00                	push   $0x0
  80db09:	6a 00                	push   $0x0
  80db0b:	53                   	push   %ebx
  80db0c:	ff 73 18             	pushl  0x18(%ebx)
  80db0f:	ff d0                	call   *%eax
  80db11:	83 c4 10             	add    $0x10,%esp
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80db14:	84 c0                	test   %al,%al
  80db16:	75 0c                	jne    80db24 <tcp_input+0xc7b>
          tcp_output(pcb);
  80db18:	83 ec 0c             	sub    $0xc,%esp
  80db1b:	53                   	push   %ebx
  80db1c:	e8 82 a4 ff ff       	call   807fa3 <tcp_output>
  80db21:	83 c4 10             	add    $0x10,%esp
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80db24:	a1 f8 b2 b3 00       	mov    0xb3b2f8,%eax
  80db29:	85 c0                	test   %eax,%eax
  80db2b:	0f 84 be 00 00 00    	je     80dbef <tcp_input+0xd46>
    {
      pbuf_free(inseg.p);
  80db31:	83 ec 0c             	sub    $0xc,%esp
  80db34:	50                   	push   %eax
  80db35:	e8 b5 6c ff ff       	call   8047ef <pbuf_free>
      inseg.p = NULL;
  80db3a:	c7 05 f8 b2 b3 00 00 	movl   $0x0,0xb3b2f8
  80db41:	00 00 00 
  80db44:	83 c4 10             	add    $0x10,%esp
  80db47:	e9 a3 00 00 00       	jmp    80dbef <tcp_input+0xd46>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80db4c:	83 ec 0c             	sub    $0xc,%esp
  80db4f:	a1 f0 b2 b3 00       	mov    0xb3b2f0,%eax
  80db54:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80db58:	50                   	push   %eax
  80db59:	e8 fc 9a ff ff       	call   80765a <ntohs>
  80db5e:	83 c4 10             	add    $0x10,%esp
  80db61:	a8 04                	test   $0x4,%al
  80db63:	75 3b                	jne    80dba0 <tcp_input+0xcf7>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80db65:	8b 15 f0 b2 b3 00    	mov    0xb3b2f0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80db6b:	a1 ec b2 b3 00       	mov    0xb3b2ec,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80db70:	83 ec 08             	sub    $0x8,%esp
  80db73:	0f b7 0a             	movzwl (%edx),%ecx
  80db76:	51                   	push   %ecx
  80db77:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80db7b:	52                   	push   %edx
  80db7c:	8d 50 0c             	lea    0xc(%eax),%edx
  80db7f:	52                   	push   %edx
  80db80:	83 c0 10             	add    $0x10,%eax
  80db83:	50                   	push   %eax
  80db84:	0f b7 05 de b2 b3 00 	movzwl 0xb3b2de,%eax
  80db8b:	03 05 e8 b2 b3 00    	add    0xb3b2e8,%eax
  80db91:	50                   	push   %eax
  80db92:	ff 35 e4 b2 b3 00    	pushl  0xb3b2e4
  80db98:	e8 7d a8 ff ff       	call   80841a <tcp_rst>
  80db9d:	83 c4 20             	add    $0x20,%esp
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80dba0:	83 ec 0c             	sub    $0xc,%esp
  80dba3:	56                   	push   %esi
  80dba4:	e8 46 6c ff ff       	call   8047ef <pbuf_free>
  80dba9:	83 c4 10             	add    $0x10,%esp
  80dbac:	eb 41                	jmp    80dbef <tcp_input+0xd46>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  80dbae:	85 db                	test   %ebx,%ebx
  80dbb0:	0f 85 25 f8 ff ff    	jne    80d3db <tcp_input+0x532>
  80dbb6:	e9 ce f5 ff ff       	jmp    80d189 <tcp_input+0x2e0>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80dbbb:	c7 05 98 b3 b3 00 00 	movl   $0x0,0xb3b398
  80dbc2:	00 00 00 
  80dbc5:	e9 38 fe ff ff       	jmp    80da02 <tcp_input+0xb59>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dbca:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dbd0:	85 c0                	test   %eax,%eax
  80dbd2:	0f 85 da fe ff ff    	jne    80dab2 <tcp_input+0xc09>
  80dbd8:	e9 ea fe ff ff       	jmp    80dac7 <tcp_input+0xc1e>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80dbdd:	f6 05 dc b2 b3 00 20 	testb  $0x20,0xb3b2dc
  80dbe4:	0f 85 13 ff ff ff    	jne    80dafd <tcp_input+0xc54>
  80dbea:	e9 29 ff ff ff       	jmp    80db18 <tcp_input+0xc6f>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80dbef:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dbf2:	5b                   	pop    %ebx
  80dbf3:	5e                   	pop    %esi
  80dbf4:	5f                   	pop    %edi
  80dbf5:	5d                   	pop    %ebp
  80dbf6:	c3                   	ret    

0080dbf7 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80dbf7:	55                   	push   %ebp
  80dbf8:	89 e5                	mov    %esp,%ebp
  80dbfa:	57                   	push   %edi
  80dbfb:	56                   	push   %esi
  80dbfc:	53                   	push   %ebx
  80dbfd:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dc00:	8b 45 08             	mov    0x8(%ebp),%eax
  80dc03:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80dc06:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80dc09:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80dc0d:	50                   	push   %eax
  80dc0e:	e8 47 9a ff ff       	call   80765a <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80dc13:	8b 1d 08 b3 b3 00    	mov    0xb3b308,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc19:	83 c4 10             	add    $0x10,%esp
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80dc1c:	be 00 00 00 00       	mov    $0x0,%esi
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80dc21:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80dc28:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dc2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80dc2e:	83 c0 0c             	add    $0xc,%eax
  80dc31:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc34:	eb 5d                	jmp    80dc93 <raw_input+0x9c>
    if (pcb->protocol == proto) {
  80dc36:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dc3a:	39 f8                	cmp    %edi,%eax
  80dc3c:	75 4f                	jne    80dc8d <raw_input+0x96>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80dc3e:	8b 43 14             	mov    0x14(%ebx),%eax
  80dc41:	85 c0                	test   %eax,%eax
  80dc43:	74 48                	je     80dc8d <raw_input+0x96>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dc45:	ff 75 e0             	pushl  -0x20(%ebp)
  80dc48:	ff 75 08             	pushl  0x8(%ebp)
  80dc4b:	53                   	push   %ebx
  80dc4c:	ff 73 18             	pushl  0x18(%ebx)
  80dc4f:	ff d0                	call   *%eax
  80dc51:	83 c4 10             	add    $0x10,%esp
  80dc54:	84 c0                	test   %al,%al
  80dc56:	74 35                	je     80dc8d <raw_input+0x96>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80dc58:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80dc5b:	85 d2                	test   %edx,%edx
  80dc5d:	74 22                	je     80dc81 <raw_input+0x8a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80dc5f:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dc62:	89 42 0c             	mov    %eax,0xc(%edx)
            pcb->next = raw_pcbs;
  80dc65:	a1 08 b3 b3 00       	mov    0xb3b308,%eax
  80dc6a:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80dc6d:	89 1d 08 b3 b3 00    	mov    %ebx,0xb3b308
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80dc73:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dc78:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80dc7f:	eb 0c                	jmp    80dc8d <raw_input+0x96>
          eaten = 1;
  80dc81:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dc86:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dc8d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dc90:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dc93:	85 db                	test   %ebx,%ebx
  80dc95:	74 06                	je     80dc9d <raw_input+0xa6>
  80dc97:	89 f0                	mov    %esi,%eax
  80dc99:	84 c0                	test   %al,%al
  80dc9b:	74 99                	je     80dc36 <raw_input+0x3f>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80dc9d:	89 f0                	mov    %esi,%eax
  80dc9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dca2:	5b                   	pop    %ebx
  80dca3:	5e                   	pop    %esi
  80dca4:	5f                   	pop    %edi
  80dca5:	5d                   	pop    %ebp
  80dca6:	c3                   	ret    

0080dca7 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dca7:	55                   	push   %ebp
  80dca8:	89 e5                	mov    %esp,%ebp
  80dcaa:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80dcad:	85 c0                	test   %eax,%eax
  80dcaf:	74 04                	je     80dcb5 <raw_bind+0xe>
  80dcb1:	8b 10                	mov    (%eax),%edx
  80dcb3:	eb 05                	jmp    80dcba <raw_bind+0x13>
  80dcb5:	ba 00 00 00 00       	mov    $0x0,%edx
  80dcba:	8b 45 08             	mov    0x8(%ebp),%eax
  80dcbd:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80dcbf:	b8 00 00 00 00       	mov    $0x0,%eax
  80dcc4:	5d                   	pop    %ebp
  80dcc5:	c3                   	ret    

0080dcc6 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dcc6:	55                   	push   %ebp
  80dcc7:	89 e5                	mov    %esp,%ebp
  80dcc9:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80dccc:	85 c0                	test   %eax,%eax
  80dcce:	74 04                	je     80dcd4 <raw_connect+0xe>
  80dcd0:	8b 10                	mov    (%eax),%edx
  80dcd2:	eb 05                	jmp    80dcd9 <raw_connect+0x13>
  80dcd4:	ba 00 00 00 00       	mov    $0x0,%edx
  80dcd9:	8b 45 08             	mov    0x8(%ebp),%eax
  80dcdc:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80dcdf:	b8 00 00 00 00       	mov    $0x0,%eax
  80dce4:	5d                   	pop    %ebp
  80dce5:	c3                   	ret    

0080dce6 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80dce6:	55                   	push   %ebp
  80dce7:	89 e5                	mov    %esp,%ebp
  80dce9:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80dcec:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dcef:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80dcf2:	8b 55 10             	mov    0x10(%ebp),%edx
  80dcf5:	89 50 18             	mov    %edx,0x18(%eax)
}
  80dcf8:	5d                   	pop    %ebp
  80dcf9:	c3                   	ret    

0080dcfa <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80dcfa:	55                   	push   %ebp
  80dcfb:	89 e5                	mov    %esp,%ebp
  80dcfd:	57                   	push   %edi
  80dcfe:	56                   	push   %esi
  80dcff:	53                   	push   %ebx
  80dd00:	83 ec 14             	sub    $0x14,%esp
  80dd03:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dd06:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80dd09:	6a 14                	push   $0x14
  80dd0b:	57                   	push   %edi
  80dd0c:	e8 0c 6a ff ff       	call   80471d <pbuf_header>
  80dd11:	83 c4 10             	add    $0x10,%esp
  80dd14:	84 c0                	test   %al,%al
  80dd16:	74 39                	je     80dd51 <raw_sendto+0x57>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80dd18:	83 ec 04             	sub    $0x4,%esp
  80dd1b:	6a 00                	push   $0x0
  80dd1d:	6a 00                	push   $0x0
  80dd1f:	6a 01                	push   $0x1
  80dd21:	e8 8f 6b ff ff       	call   8048b5 <pbuf_alloc>
  80dd26:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80dd28:	83 c4 10             	add    $0x10,%esp
  80dd2b:	85 c0                	test   %eax,%eax
  80dd2d:	0f 84 ab 00 00 00    	je     80ddde <raw_sendto+0xe4>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80dd33:	83 ec 08             	sub    $0x8,%esp
  80dd36:	57                   	push   %edi
  80dd37:	50                   	push   %eax
  80dd38:	e8 99 6f ff ff       	call   804cd6 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dd3d:	83 c4 04             	add    $0x4,%esp
  80dd40:	ff 75 10             	pushl  0x10(%ebp)
  80dd43:	e8 30 87 ff ff       	call   806478 <ip_route>
  80dd48:	83 c4 10             	add    $0x10,%esp
  80dd4b:	85 c0                	test   %eax,%eax
  80dd4d:	75 4b                	jne    80dd9a <raw_sendto+0xa0>
  80dd4f:	eb 2d                	jmp    80dd7e <raw_sendto+0x84>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80dd51:	83 ec 08             	sub    $0x8,%esp
  80dd54:	6a ec                	push   $0xffffffec
  80dd56:	57                   	push   %edi
  80dd57:	e8 c1 69 ff ff       	call   80471d <pbuf_header>
  80dd5c:	83 c4 10             	add    $0x10,%esp
  80dd5f:	84 c0                	test   %al,%al
  80dd61:	0f 84 85 00 00 00    	je     80ddec <raw_sendto+0xf2>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80dd67:	83 ec 04             	sub    $0x4,%esp
  80dd6a:	68 14 31 81 00       	push   $0x813114
  80dd6f:	68 e3 00 00 00       	push   $0xe3
  80dd74:	68 3a 31 81 00       	push   $0x81313a
  80dd79:	e8 63 06 00 00       	call   80e3e1 <_panic>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80dd7e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80dd83:	39 f7                	cmp    %esi,%edi
  80dd85:	74 7b                	je     80de02 <raw_sendto+0x108>
      pbuf_free(q);
  80dd87:	83 ec 0c             	sub    $0xc,%esp
  80dd8a:	56                   	push   %esi
  80dd8b:	e8 5f 6a ff ff       	call   8047ef <pbuf_free>
  80dd90:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80dd93:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80dd98:	eb 68                	jmp    80de02 <raw_sendto+0x108>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80dd9a:	89 da                	mov    %ebx,%edx
  80dd9c:	85 db                	test   %ebx,%ebx
  80dd9e:	74 05                	je     80dda5 <raw_sendto+0xab>
  80dda0:	83 3b 00             	cmpl   $0x0,(%ebx)
  80dda3:	75 03                	jne    80dda8 <raw_sendto+0xae>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80dda5:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80dda8:	83 ec 04             	sub    $0x4,%esp
  80ddab:	50                   	push   %eax
  80ddac:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80ddb0:	50                   	push   %eax
  80ddb1:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80ddb5:	50                   	push   %eax
  80ddb6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80ddba:	50                   	push   %eax
  80ddbb:	ff 75 10             	pushl  0x10(%ebp)
  80ddbe:	52                   	push   %edx
  80ddbf:	56                   	push   %esi
  80ddc0:	e8 1e 8a ff ff       	call   8067e3 <ip_output_if>
  80ddc5:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80ddc7:	83 c4 20             	add    $0x20,%esp
  80ddca:	39 fe                	cmp    %edi,%esi
  80ddcc:	74 34                	je     80de02 <raw_sendto+0x108>
    /* free the header */
    pbuf_free(q);
  80ddce:	83 ec 0c             	sub    $0xc,%esp
  80ddd1:	56                   	push   %esi
  80ddd2:	e8 18 6a ff ff       	call   8047ef <pbuf_free>
  80ddd7:	83 c4 10             	add    $0x10,%esp
  }
  return err;
  80ddda:	89 d8                	mov    %ebx,%eax
  80dddc:	eb 24                	jmp    80de02 <raw_sendto+0x108>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80ddde:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dde3:	eb 1d                	jmp    80de02 <raw_sendto+0x108>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80dde5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80ddea:	eb 16                	jmp    80de02 <raw_sendto+0x108>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80ddec:	83 ec 0c             	sub    $0xc,%esp
  80ddef:	ff 75 10             	pushl  0x10(%ebp)
  80ddf2:	e8 81 86 ff ff       	call   806478 <ip_route>
  80ddf7:	83 c4 10             	add    $0x10,%esp
  80ddfa:	85 c0                	test   %eax,%eax
  80ddfc:	74 e7                	je     80dde5 <raw_sendto+0xeb>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80ddfe:	89 fe                	mov    %edi,%esi
  80de00:	eb 98                	jmp    80dd9a <raw_sendto+0xa0>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80de02:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80de05:	5b                   	pop    %ebx
  80de06:	5e                   	pop    %esi
  80de07:	5f                   	pop    %edi
  80de08:	5d                   	pop    %ebp
  80de09:	c3                   	ret    

0080de0a <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80de0a:	55                   	push   %ebp
  80de0b:	89 e5                	mov    %esp,%ebp
  80de0d:	83 ec 0c             	sub    $0xc,%esp
  80de10:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80de13:	8d 50 04             	lea    0x4(%eax),%edx
  80de16:	52                   	push   %edx
  80de17:	ff 75 0c             	pushl  0xc(%ebp)
  80de1a:	50                   	push   %eax
  80de1b:	e8 da fe ff ff       	call   80dcfa <raw_sendto>
}
  80de20:	c9                   	leave  
  80de21:	c3                   	ret    

0080de22 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80de22:	55                   	push   %ebp
  80de23:	89 e5                	mov    %esp,%ebp
  80de25:	83 ec 08             	sub    $0x8,%esp
  80de28:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80de2b:	a1 08 b3 b3 00       	mov    0xb3b308,%eax
  80de30:	39 c8                	cmp    %ecx,%eax
  80de32:	75 1e                	jne    80de52 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80de34:	8b 40 0c             	mov    0xc(%eax),%eax
  80de37:	a3 08 b3 b3 00       	mov    %eax,0xb3b308
  80de3c:	eb 18                	jmp    80de56 <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80de3e:	8b 50 0c             	mov    0xc(%eax),%edx
  80de41:	39 d1                	cmp    %edx,%ecx
  80de43:	75 0a                	jne    80de4f <raw_remove+0x2d>
  80de45:	85 d2                	test   %edx,%edx
  80de47:	74 06                	je     80de4f <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80de49:	8b 51 0c             	mov    0xc(%ecx),%edx
  80de4c:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80de4f:	8b 40 0c             	mov    0xc(%eax),%eax
  80de52:	85 c0                	test   %eax,%eax
  80de54:	75 e8                	jne    80de3e <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80de56:	83 ec 08             	sub    $0x8,%esp
  80de59:	51                   	push   %ecx
  80de5a:	6a 00                	push   $0x0
  80de5c:	e8 1b 66 ff ff       	call   80447c <memp_free>
  80de61:	83 c4 10             	add    $0x10,%esp
}
  80de64:	c9                   	leave  
  80de65:	c3                   	ret    

0080de66 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80de66:	55                   	push   %ebp
  80de67:	89 e5                	mov    %esp,%ebp
  80de69:	56                   	push   %esi
  80de6a:	53                   	push   %ebx
  80de6b:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80de6e:	83 ec 0c             	sub    $0xc,%esp
  80de71:	6a 00                	push   $0x0
  80de73:	e8 ae 65 ff ff       	call   804426 <memp_malloc>
  80de78:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80de7a:	83 c4 10             	add    $0x10,%esp
  80de7d:	85 c0                	test   %eax,%eax
  80de7f:	74 27                	je     80dea8 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80de81:	83 ec 04             	sub    $0x4,%esp
  80de84:	6a 1c                	push   $0x1c
  80de86:	6a 00                	push   $0x0
  80de88:	50                   	push   %eax
  80de89:	e8 f8 0c 00 00       	call   80eb86 <memset>
    pcb->protocol = proto;
  80de8e:	89 f0                	mov    %esi,%eax
  80de90:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80de93:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80de97:	a1 08 b3 b3 00       	mov    0xb3b308,%eax
  80de9c:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80de9f:	89 1d 08 b3 b3 00    	mov    %ebx,0xb3b308
  80dea5:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80dea8:	89 d8                	mov    %ebx,%eax
  80deaa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80dead:	5b                   	pop    %ebx
  80deae:	5e                   	pop    %esi
  80deaf:	5d                   	pop    %ebp
  80deb0:	c3                   	ret    

0080deb1 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80deb1:	55                   	push   %ebp
  80deb2:	89 e5                	mov    %esp,%ebp
  80deb4:	57                   	push   %edi
  80deb5:	56                   	push   %esi
  80deb6:	53                   	push   %ebx
  80deb7:	83 ec 28             	sub    $0x28,%esp
  80deba:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80debd:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80dec0:	0f b7 07             	movzwl (%edi),%eax
  80dec3:	50                   	push   %eax
  80dec4:	e8 91 97 ff ff       	call   80765a <ntohs>
  80dec9:	66 c1 e8 06          	shr    $0x6,%ax
  80decd:	83 e0 3c             	and    $0x3c,%eax
  80ded0:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80ded4:	89 c6                	mov    %eax,%esi
  80ded6:	f7 de                	neg    %esi
  80ded8:	0f bf f6             	movswl %si,%esi
  80dedb:	83 c4 08             	add    $0x8,%esp
  80dede:	56                   	push   %esi
  80dedf:	53                   	push   %ebx
  80dee0:	e8 38 68 ff ff       	call   80471d <pbuf_header>
  80dee5:	83 c4 10             	add    $0x10,%esp
  80dee8:	84 c0                	test   %al,%al
  80deea:	0f 85 b1 02 00 00    	jne    80e1a1 <icmp_input+0x2f0>
  80def0:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80def5:	0f 86 a6 02 00 00    	jbe    80e1a1 <icmp_input+0x2f0>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80defb:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80defe:	80 38 08             	cmpb   $0x8,(%eax)
  80df01:	0f 85 8c 02 00 00    	jne    80e193 <icmp_input+0x2e2>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80df07:	83 ec 08             	sub    $0x8,%esp
  80df0a:	ff 75 0c             	pushl  0xc(%ebp)
  80df0d:	8d 47 10             	lea    0x10(%edi),%eax
  80df10:	50                   	push   %eax
  80df11:	e8 16 85 ff ff       	call   80642c <ip_addr_isbroadcast>
  80df16:	83 c4 10             	add    $0x10,%esp
  80df19:	84 c0                	test   %al,%al
  80df1b:	75 2d                	jne    80df4a <icmp_input+0x99>
  80df1d:	8b 47 10             	mov    0x10(%edi),%eax
  80df20:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80df23:	83 ec 0c             	sub    $0xc,%esp
  80df26:	68 00 00 00 f0       	push   $0xf0000000
  80df2b:	e8 6e 99 ff ff       	call   80789e <ntohl>
  80df30:	23 45 e0             	and    -0x20(%ebp),%eax
  80df33:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80df36:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80df3d:	e8 5c 99 ff ff       	call   80789e <ntohl>
  80df42:	83 c4 10             	add    $0x10,%esp
  80df45:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80df48:	75 11                	jne    80df5b <icmp_input+0xaa>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80df4a:	83 ec 0c             	sub    $0xc,%esp
  80df4d:	53                   	push   %ebx
  80df4e:	e8 9c 68 ff ff       	call   8047ef <pbuf_free>
      return;
  80df53:	83 c4 10             	add    $0x10,%esp
  80df56:	e9 60 02 00 00       	jmp    80e1bb <icmp_input+0x30a>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80df5b:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80df60:	0f 86 3b 02 00 00    	jbe    80e1a1 <icmp_input+0x2f0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80df66:	83 ec 0c             	sub    $0xc,%esp
  80df69:	53                   	push   %ebx
  80df6a:	e8 cd 95 ff ff       	call   80753c <inet_chksum_pbuf>
  80df6f:	83 c4 10             	add    $0x10,%esp
  80df72:	66 85 c0             	test   %ax,%ax
  80df75:	74 11                	je     80df88 <icmp_input+0xd7>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80df77:	83 ec 0c             	sub    $0xc,%esp
  80df7a:	53                   	push   %ebx
  80df7b:	e8 6f 68 ff ff       	call   8047ef <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80df80:	83 c4 10             	add    $0x10,%esp
  80df83:	e9 33 02 00 00       	jmp    80e1bb <icmp_input+0x30a>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80df88:	83 ec 08             	sub    $0x8,%esp
  80df8b:	6a 22                	push   $0x22
  80df8d:	53                   	push   %ebx
  80df8e:	e8 8a 67 ff ff       	call   80471d <pbuf_header>
  80df93:	83 c4 10             	add    $0x10,%esp
  80df96:	84 c0                	test   %al,%al
  80df98:	0f 84 d7 00 00 00    	je     80e075 <icmp_input+0x1c4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80df9e:	83 ec 08             	sub    $0x8,%esp
  80dfa1:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80dfa5:	50                   	push   %eax
  80dfa6:	53                   	push   %ebx
  80dfa7:	e8 71 67 ff ff       	call   80471d <pbuf_header>
  80dfac:	83 c4 10             	add    $0x10,%esp
  80dfaf:	84 c0                	test   %al,%al
  80dfb1:	74 14                	je     80dfc7 <icmp_input+0x116>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80dfb3:	83 ec 04             	sub    $0x4,%esp
  80dfb6:	68 50 31 81 00       	push   $0x813150
  80dfbb:	6a 7b                	push   $0x7b
  80dfbd:	68 44 32 81 00       	push   $0x813244
  80dfc2:	e8 1a 04 00 00       	call   80e3e1 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80dfc7:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80dfcb:	83 ec 04             	sub    $0x4,%esp
  80dfce:	6a 00                	push   $0x0
  80dfd0:	50                   	push   %eax
  80dfd1:	6a 02                	push   $0x2
  80dfd3:	e8 dd 68 ff ff       	call   8048b5 <pbuf_alloc>
  80dfd8:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80dfdb:	83 c4 10             	add    $0x10,%esp
  80dfde:	85 c0                	test   %eax,%eax
  80dfe0:	0f 84 c9 01 00 00    	je     80e1af <icmp_input+0x2fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80dfe6:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80dfea:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80dfee:	83 c0 08             	add    $0x8,%eax
  80dff1:	39 c2                	cmp    %eax,%edx
  80dff3:	73 17                	jae    80e00c <icmp_input+0x15b>
  80dff5:	83 ec 04             	sub    $0x4,%esp
  80dff8:	68 84 31 81 00       	push   $0x813184
  80dffd:	68 85 00 00 00       	push   $0x85
  80e002:	68 44 32 81 00       	push   $0x813244
  80e007:	e8 d5 03 00 00       	call   80e3e1 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80e00c:	83 ec 08             	sub    $0x8,%esp
  80e00f:	53                   	push   %ebx
  80e010:	ff 75 e0             	pushl  -0x20(%ebp)
  80e013:	e8 8e 6d ff ff       	call   804da6 <pbuf_copy>
  80e018:	83 c4 10             	add    $0x10,%esp
  80e01b:	84 c0                	test   %al,%al
  80e01d:	74 17                	je     80e036 <icmp_input+0x185>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e01f:	83 ec 04             	sub    $0x4,%esp
  80e022:	68 bc 31 81 00       	push   $0x8131bc
  80e027:	68 88 00 00 00       	push   $0x88
  80e02c:	68 44 32 81 00       	push   $0x813244
  80e031:	e8 ab 03 00 00       	call   80e3e1 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80e036:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e039:	8b 78 04             	mov    0x4(%eax),%edi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80e03c:	83 ec 08             	sub    $0x8,%esp
  80e03f:	56                   	push   %esi
  80e040:	50                   	push   %eax
  80e041:	e8 d7 66 ff ff       	call   80471d <pbuf_header>
  80e046:	83 c4 10             	add    $0x10,%esp
  80e049:	84 c0                	test   %al,%al
  80e04b:	74 17                	je     80e064 <icmp_input+0x1b3>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e04d:	83 ec 04             	sub    $0x4,%esp
  80e050:	68 e4 31 81 00       	push   $0x8131e4
  80e055:	68 8e 00 00 00       	push   $0x8e
  80e05a:	68 44 32 81 00       	push   $0x813244
  80e05f:	e8 7d 03 00 00       	call   80e3e1 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80e064:	83 ec 0c             	sub    $0xc,%esp
  80e067:	53                   	push   %ebx
  80e068:	e8 82 67 ff ff       	call   8047ef <pbuf_free>
  80e06d:	83 c4 10             	add    $0x10,%esp
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80e070:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e073:	eb 29                	jmp    80e09e <icmp_input+0x1ed>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e075:	83 ec 08             	sub    $0x8,%esp
  80e078:	6a de                	push   $0xffffffde
  80e07a:	53                   	push   %ebx
  80e07b:	e8 9d 66 ff ff       	call   80471d <pbuf_header>
  80e080:	83 c4 10             	add    $0x10,%esp
  80e083:	84 c0                	test   %al,%al
  80e085:	74 17                	je     80e09e <icmp_input+0x1ed>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e087:	83 ec 04             	sub    $0x4,%esp
  80e08a:	68 e4 31 81 00       	push   $0x8131e4
  80e08f:	68 98 00 00 00       	push   $0x98
  80e094:	68 44 32 81 00       	push   $0x813244
  80e099:	e8 43 03 00 00       	call   80e3e1 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80e09e:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e0a1:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e0a4:	8b 57 10             	mov    0x10(%edi),%edx
  80e0a7:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e0aa:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e0ad:	83 ec 0c             	sub    $0xc,%esp
  80e0b0:	0f b7 06             	movzwl (%esi),%eax
  80e0b3:	50                   	push   %eax
  80e0b4:	e8 a1 95 ff ff       	call   80765a <ntohs>
  80e0b9:	0f b6 c0             	movzbl %al,%eax
  80e0bc:	89 04 24             	mov    %eax,(%esp)
  80e0bf:	e8 89 95 ff ff       	call   80764d <htons>
  80e0c4:	66 89 06             	mov    %ax,(%esi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e0c7:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e0cb:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e0cf:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e0d6:	e8 72 95 ff ff       	call   80764d <htons>
  80e0db:	83 c4 10             	add    $0x10,%esp
  80e0de:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e0e2:	72 1c                	jb     80e100 <icmp_input+0x24f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e0e4:	83 ec 0c             	sub    $0xc,%esp
  80e0e7:	68 00 08 00 00       	push   $0x800
  80e0ec:	e8 5c 95 ff ff       	call   80764d <htons>
  80e0f1:	0f b7 c0             	movzwl %ax,%eax
  80e0f4:	83 c0 01             	add    $0x1,%eax
  80e0f7:	66 01 46 02          	add    %ax,0x2(%esi)
  80e0fb:	83 c4 10             	add    $0x10,%esp
  80e0fe:	eb 14                	jmp    80e114 <icmp_input+0x263>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e100:	83 ec 0c             	sub    $0xc,%esp
  80e103:	68 00 08 00 00       	push   $0x800
  80e108:	e8 40 95 ff ff       	call   80764d <htons>
  80e10d:	66 01 46 02          	add    %ax,0x2(%esi)
  80e111:	83 c4 10             	add    $0x10,%esp
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e114:	83 ec 0c             	sub    $0xc,%esp
  80e117:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e11b:	50                   	push   %eax
  80e11c:	e8 39 95 ff ff       	call   80765a <ntohs>
  80e121:	66 0d 00 ff          	or     $0xff00,%ax
  80e125:	0f b7 c0             	movzwl %ax,%eax
  80e128:	89 04 24             	mov    %eax,(%esp)
  80e12b:	e8 1d 95 ff ff       	call   80764d <htons>
  80e130:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e134:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e13a:	83 c4 08             	add    $0x8,%esp
  80e13d:	6a 14                	push   $0x14
  80e13f:	57                   	push   %edi
  80e140:	e8 e1 93 ff ff       	call   807526 <inet_chksum>
  80e145:	66 89 47 0a          	mov    %ax,0xa(%edi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80e149:	83 c4 08             	add    $0x8,%esp
  80e14c:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e150:	50                   	push   %eax
  80e151:	53                   	push   %ebx
  80e152:	e8 c6 65 ff ff       	call   80471d <pbuf_header>
  80e157:	83 c4 10             	add    $0x10,%esp
  80e15a:	84 c0                	test   %al,%al
  80e15c:	74 17                	je     80e175 <icmp_input+0x2c4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e15e:	83 ec 04             	sub    $0x4,%esp
  80e161:	68 b0 22 81 00       	push   $0x8122b0
  80e166:	68 b9 00 00 00       	push   $0xb9
  80e16b:	68 44 32 81 00       	push   $0x813244
  80e170:	e8 6c 02 00 00       	call   80e3e1 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e175:	83 ec 04             	sub    $0x4,%esp
  80e178:	ff 75 0c             	pushl  0xc(%ebp)
  80e17b:	6a 01                	push   $0x1
  80e17d:	6a 00                	push   $0x0
  80e17f:	68 ff 00 00 00       	push   $0xff
  80e184:	6a 00                	push   $0x0
  80e186:	83 c7 0c             	add    $0xc,%edi
  80e189:	57                   	push   %edi
  80e18a:	53                   	push   %ebx
  80e18b:	e8 53 86 ff ff       	call   8067e3 <ip_output_if>
  80e190:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e193:	83 ec 0c             	sub    $0xc,%esp
  80e196:	53                   	push   %ebx
  80e197:	e8 53 66 ff ff       	call   8047ef <pbuf_free>
  return;
  80e19c:	83 c4 10             	add    $0x10,%esp
  80e19f:	eb 1a                	jmp    80e1bb <icmp_input+0x30a>
lenerr:
  pbuf_free(p);
  80e1a1:	83 ec 0c             	sub    $0xc,%esp
  80e1a4:	53                   	push   %ebx
  80e1a5:	e8 45 66 ff ff       	call   8047ef <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e1aa:	83 c4 10             	add    $0x10,%esp
  80e1ad:	eb 0c                	jmp    80e1bb <icmp_input+0x30a>
memerr:
  pbuf_free(p);
  80e1af:	83 ec 0c             	sub    $0xc,%esp
  80e1b2:	53                   	push   %ebx
  80e1b3:	e8 37 66 ff ff       	call   8047ef <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  80e1b8:	83 c4 10             	add    $0x10,%esp
}
  80e1bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e1be:	5b                   	pop    %ebx
  80e1bf:	5e                   	pop    %esi
  80e1c0:	5f                   	pop    %edi
  80e1c1:	5d                   	pop    %ebp
  80e1c2:	c3                   	ret    

0080e1c3 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e1c3:	55                   	push   %ebp
  80e1c4:	89 e5                	mov    %esp,%ebp
  80e1c6:	57                   	push   %edi
  80e1c7:	56                   	push   %esi
  80e1c8:	53                   	push   %ebx
  80e1c9:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e1cc:	6a 00                	push   $0x0
  80e1ce:	6a 24                	push   $0x24
  80e1d0:	6a 01                	push   $0x1
  80e1d2:	e8 de 66 ff ff       	call   8048b5 <pbuf_alloc>
  80e1d7:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80e1d9:	83 c4 10             	add    $0x10,%esp
  80e1dc:	85 c0                	test   %eax,%eax
  80e1de:	0f 84 b6 00 00 00    	je     80e29a <icmp_dest_unreach+0xd7>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e1e4:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e1e9:	77 17                	ja     80e202 <icmp_dest_unreach+0x3f>
  80e1eb:	83 ec 04             	sub    $0x4,%esp
  80e1ee:	68 18 32 81 00       	push   $0x813218
  80e1f3:	68 ef 00 00 00       	push   $0xef
  80e1f8:	68 44 32 81 00       	push   $0x813244
  80e1fd:	e8 df 01 00 00       	call   80e3e1 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e202:	8b 45 08             	mov    0x8(%ebp),%eax
  80e205:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e208:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e20b:	83 ec 0c             	sub    $0xc,%esp
  80e20e:	0f b7 06             	movzwl (%esi),%eax
  80e211:	50                   	push   %eax
  80e212:	e8 43 94 ff ff       	call   80765a <ntohs>
  80e217:	0f b6 c0             	movzbl %al,%eax
  80e21a:	80 cc 03             	or     $0x3,%ah
  80e21d:	89 04 24             	mov    %eax,(%esp)
  80e220:	e8 28 94 ff ff       	call   80764d <htons>
  80e225:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e228:	0f b7 c0             	movzwl %ax,%eax
  80e22b:	89 04 24             	mov    %eax,(%esp)
  80e22e:	e8 27 94 ff ff       	call   80765a <ntohs>
  80e233:	b0 00                	mov    $0x0,%al
  80e235:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e239:	0f b7 c0             	movzwl %ax,%eax
  80e23c:	89 04 24             	mov    %eax,(%esp)
  80e23f:	e8 09 94 ff ff       	call   80764d <htons>
  80e244:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e247:	83 c4 0c             	add    $0xc,%esp
  80e24a:	6a 1c                	push   $0x1c
  80e24c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e24f:	ff 70 04             	pushl  0x4(%eax)
  80e252:	8b 43 04             	mov    0x4(%ebx),%eax
  80e255:	83 c0 08             	add    $0x8,%eax
  80e258:	50                   	push   %eax
  80e259:	e8 dd 09 00 00       	call   80ec3b <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e25e:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e264:	83 c4 08             	add    $0x8,%esp
  80e267:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e26b:	50                   	push   %eax
  80e26c:	56                   	push   %esi
  80e26d:	e8 b4 92 ff ff       	call   807526 <inet_chksum>
  80e272:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e276:	83 c4 08             	add    $0x8,%esp
  80e279:	6a 01                	push   $0x1
  80e27b:	6a 00                	push   $0x0
  80e27d:	68 ff 00 00 00       	push   $0xff
  80e282:	83 c7 0c             	add    $0xc,%edi
  80e285:	57                   	push   %edi
  80e286:	6a 00                	push   $0x0
  80e288:	53                   	push   %ebx
  80e289:	e8 dd 86 ff ff       	call   80696b <ip_output>
  pbuf_free(q);
  80e28e:	83 c4 14             	add    $0x14,%esp
  80e291:	53                   	push   %ebx
  80e292:	e8 58 65 ff ff       	call   8047ef <pbuf_free>
  80e297:	83 c4 10             	add    $0x10,%esp
}
  80e29a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e29d:	5b                   	pop    %ebx
  80e29e:	5e                   	pop    %esi
  80e29f:	5f                   	pop    %edi
  80e2a0:	5d                   	pop    %ebp
  80e2a1:	c3                   	ret    

0080e2a2 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e2a2:	55                   	push   %ebp
  80e2a3:	89 e5                	mov    %esp,%ebp
  80e2a5:	57                   	push   %edi
  80e2a6:	56                   	push   %esi
  80e2a7:	53                   	push   %ebx
  80e2a8:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e2ab:	6a 00                	push   $0x0
  80e2ad:	6a 24                	push   $0x24
  80e2af:	6a 01                	push   $0x1
  80e2b1:	e8 ff 65 ff ff       	call   8048b5 <pbuf_alloc>
  80e2b6:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80e2b8:	83 c4 10             	add    $0x10,%esp
  80e2bb:	85 c0                	test   %eax,%eax
  80e2bd:	0f 84 b6 00 00 00    	je     80e379 <icmp_time_exceeded+0xd7>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e2c3:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e2c8:	77 17                	ja     80e2e1 <icmp_time_exceeded+0x3f>
  80e2ca:	83 ec 04             	sub    $0x4,%esp
  80e2cd:	68 18 32 81 00       	push   $0x813218
  80e2d2:	68 1e 01 00 00       	push   $0x11e
  80e2d7:	68 44 32 81 00       	push   $0x813244
  80e2dc:	e8 00 01 00 00       	call   80e3e1 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e2e1:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2e4:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e2e7:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e2ea:	83 ec 0c             	sub    $0xc,%esp
  80e2ed:	0f b7 06             	movzwl (%esi),%eax
  80e2f0:	50                   	push   %eax
  80e2f1:	e8 64 93 ff ff       	call   80765a <ntohs>
  80e2f6:	0f b6 c0             	movzbl %al,%eax
  80e2f9:	80 cc 0b             	or     $0xb,%ah
  80e2fc:	89 04 24             	mov    %eax,(%esp)
  80e2ff:	e8 49 93 ff ff       	call   80764d <htons>
  80e304:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e307:	0f b7 c0             	movzwl %ax,%eax
  80e30a:	89 04 24             	mov    %eax,(%esp)
  80e30d:	e8 48 93 ff ff       	call   80765a <ntohs>
  80e312:	b0 00                	mov    $0x0,%al
  80e314:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e318:	0f b7 c0             	movzwl %ax,%eax
  80e31b:	89 04 24             	mov    %eax,(%esp)
  80e31e:	e8 2a 93 ff ff       	call   80764d <htons>
  80e323:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e326:	83 c4 0c             	add    $0xc,%esp
  80e329:	6a 1c                	push   $0x1c
  80e32b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e32e:	ff 70 04             	pushl  0x4(%eax)
  80e331:	8b 43 04             	mov    0x4(%ebx),%eax
  80e334:	83 c0 08             	add    $0x8,%eax
  80e337:	50                   	push   %eax
  80e338:	e8 fe 08 00 00       	call   80ec3b <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e33d:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e343:	83 c4 08             	add    $0x8,%esp
  80e346:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e34a:	50                   	push   %eax
  80e34b:	56                   	push   %esi
  80e34c:	e8 d5 91 ff ff       	call   807526 <inet_chksum>
  80e351:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e355:	83 c4 08             	add    $0x8,%esp
  80e358:	6a 01                	push   $0x1
  80e35a:	6a 00                	push   $0x0
  80e35c:	68 ff 00 00 00       	push   $0xff
  80e361:	83 c7 0c             	add    $0xc,%edi
  80e364:	57                   	push   %edi
  80e365:	6a 00                	push   $0x0
  80e367:	53                   	push   %ebx
  80e368:	e8 fe 85 ff ff       	call   80696b <ip_output>
  pbuf_free(q);
  80e36d:	83 c4 14             	add    $0x14,%esp
  80e370:	53                   	push   %ebx
  80e371:	e8 79 64 ff ff       	call   8047ef <pbuf_free>
  80e376:	83 c4 10             	add    $0x10,%esp
}
  80e379:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e37c:	5b                   	pop    %ebx
  80e37d:	5e                   	pop    %esi
  80e37e:	5f                   	pop    %edi
  80e37f:	5d                   	pop    %ebp
  80e380:	c3                   	ret    

0080e381 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e381:	55                   	push   %ebp
  80e382:	89 e5                	mov    %esp,%ebp
  80e384:	56                   	push   %esi
  80e385:	53                   	push   %ebx
  80e386:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e389:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = envs+ENVX(sys_getenvid());
  80e38c:	e8 7b 0a 00 00       	call   80ee0c <sys_getenvid>
  80e391:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e396:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e399:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e39e:	a3 9c b3 b3 00       	mov    %eax,0xb3b39c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e3a3:	85 db                	test   %ebx,%ebx
  80e3a5:	7e 07                	jle    80e3ae <libmain+0x2d>
		binaryname = argv[0];
  80e3a7:	8b 06                	mov    (%esi),%eax
  80e3a9:	a3 08 43 81 00       	mov    %eax,0x814308

	// call user main routine
	umain(argc, argv);
  80e3ae:	83 ec 08             	sub    $0x8,%esp
  80e3b1:	56                   	push   %esi
  80e3b2:	53                   	push   %ebx
  80e3b3:	e8 a3 21 ff ff       	call   80055b <umain>

	// exit gracefully
	exit();
  80e3b8:	e8 0a 00 00 00       	call   80e3c7 <exit>
  80e3bd:	83 c4 10             	add    $0x10,%esp
}
  80e3c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e3c3:	5b                   	pop    %ebx
  80e3c4:	5e                   	pop    %esi
  80e3c5:	5d                   	pop    %ebp
  80e3c6:	c3                   	ret    

0080e3c7 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e3c7:	55                   	push   %ebp
  80e3c8:	89 e5                	mov    %esp,%ebp
  80e3ca:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e3cd:	e8 d5 12 00 00       	call   80f6a7 <close_all>
	sys_env_destroy(0);
  80e3d2:	83 ec 0c             	sub    $0xc,%esp
  80e3d5:	6a 00                	push   $0x0
  80e3d7:	e8 ef 09 00 00       	call   80edcb <sys_env_destroy>
  80e3dc:	83 c4 10             	add    $0x10,%esp
}
  80e3df:	c9                   	leave  
  80e3e0:	c3                   	ret    

0080e3e1 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e3e1:	55                   	push   %ebp
  80e3e2:	89 e5                	mov    %esp,%ebp
  80e3e4:	56                   	push   %esi
  80e3e5:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e3e6:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e3e9:	8b 35 08 43 81 00    	mov    0x814308,%esi
  80e3ef:	e8 18 0a 00 00       	call   80ee0c <sys_getenvid>
  80e3f4:	83 ec 0c             	sub    $0xc,%esp
  80e3f7:	ff 75 0c             	pushl  0xc(%ebp)
  80e3fa:	ff 75 08             	pushl  0x8(%ebp)
  80e3fd:	56                   	push   %esi
  80e3fe:	50                   	push   %eax
  80e3ff:	68 68 32 81 00       	push   $0x813268
  80e404:	e8 b1 00 00 00       	call   80e4ba <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e409:	83 c4 18             	add    $0x18,%esp
  80e40c:	53                   	push   %ebx
  80e40d:	ff 75 10             	pushl  0x10(%ebp)
  80e410:	e8 54 00 00 00       	call   80e469 <vcprintf>
	cprintf("\n");
  80e415:	c7 04 24 08 0e 81 00 	movl   $0x810e08,(%esp)
  80e41c:	e8 99 00 00 00       	call   80e4ba <cprintf>
  80e421:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e424:	cc                   	int3   
  80e425:	eb fd                	jmp    80e424 <_panic+0x43>

0080e427 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e427:	55                   	push   %ebp
  80e428:	89 e5                	mov    %esp,%ebp
  80e42a:	53                   	push   %ebx
  80e42b:	83 ec 04             	sub    $0x4,%esp
  80e42e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e431:	8b 13                	mov    (%ebx),%edx
  80e433:	8d 42 01             	lea    0x1(%edx),%eax
  80e436:	89 03                	mov    %eax,(%ebx)
  80e438:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e43b:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e43f:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e444:	75 1a                	jne    80e460 <putch+0x39>
		sys_cputs(b->buf, b->idx);
  80e446:	83 ec 08             	sub    $0x8,%esp
  80e449:	68 ff 00 00 00       	push   $0xff
  80e44e:	8d 43 08             	lea    0x8(%ebx),%eax
  80e451:	50                   	push   %eax
  80e452:	e8 37 09 00 00       	call   80ed8e <sys_cputs>
		b->idx = 0;
  80e457:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e45d:	83 c4 10             	add    $0x10,%esp
	}
	b->cnt++;
  80e460:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e464:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e467:	c9                   	leave  
  80e468:	c3                   	ret    

0080e469 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e469:	55                   	push   %ebp
  80e46a:	89 e5                	mov    %esp,%ebp
  80e46c:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e472:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e479:	00 00 00 
	b.cnt = 0;
  80e47c:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e483:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e486:	ff 75 0c             	pushl  0xc(%ebp)
  80e489:	ff 75 08             	pushl  0x8(%ebp)
  80e48c:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e492:	50                   	push   %eax
  80e493:	68 27 e4 80 00       	push   $0x80e427
  80e498:	e8 4f 01 00 00       	call   80e5ec <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e49d:	83 c4 08             	add    $0x8,%esp
  80e4a0:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e4a6:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e4ac:	50                   	push   %eax
  80e4ad:	e8 dc 08 00 00       	call   80ed8e <sys_cputs>

	return b.cnt;
}
  80e4b2:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e4b8:	c9                   	leave  
  80e4b9:	c3                   	ret    

0080e4ba <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e4ba:	55                   	push   %ebp
  80e4bb:	89 e5                	mov    %esp,%ebp
  80e4bd:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e4c0:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e4c3:	50                   	push   %eax
  80e4c4:	ff 75 08             	pushl  0x8(%ebp)
  80e4c7:	e8 9d ff ff ff       	call   80e469 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e4cc:	c9                   	leave  
  80e4cd:	c3                   	ret    

0080e4ce <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e4ce:	55                   	push   %ebp
  80e4cf:	89 e5                	mov    %esp,%ebp
  80e4d1:	57                   	push   %edi
  80e4d2:	56                   	push   %esi
  80e4d3:	53                   	push   %ebx
  80e4d4:	83 ec 1c             	sub    $0x1c,%esp
  80e4d7:	89 c7                	mov    %eax,%edi
  80e4d9:	89 d6                	mov    %edx,%esi
  80e4db:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4de:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e4e1:	89 d1                	mov    %edx,%ecx
  80e4e3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e4e6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e4e9:	8b 45 10             	mov    0x10(%ebp),%eax
  80e4ec:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e4ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e4f2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80e4f9:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  80e4fc:	72 05                	jb     80e503 <printnum+0x35>
  80e4fe:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  80e501:	77 3e                	ja     80e541 <printnum+0x73>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e503:	83 ec 0c             	sub    $0xc,%esp
  80e506:	ff 75 18             	pushl  0x18(%ebp)
  80e509:	83 eb 01             	sub    $0x1,%ebx
  80e50c:	53                   	push   %ebx
  80e50d:	50                   	push   %eax
  80e50e:	83 ec 08             	sub    $0x8,%esp
  80e511:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e514:	ff 75 e0             	pushl  -0x20(%ebp)
  80e517:	ff 75 dc             	pushl  -0x24(%ebp)
  80e51a:	ff 75 d8             	pushl  -0x28(%ebp)
  80e51d:	e8 7e 24 00 00       	call   8109a0 <__udivdi3>
  80e522:	83 c4 18             	add    $0x18,%esp
  80e525:	52                   	push   %edx
  80e526:	50                   	push   %eax
  80e527:	89 f2                	mov    %esi,%edx
  80e529:	89 f8                	mov    %edi,%eax
  80e52b:	e8 9e ff ff ff       	call   80e4ce <printnum>
  80e530:	83 c4 20             	add    $0x20,%esp
  80e533:	eb 13                	jmp    80e548 <printnum+0x7a>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e535:	83 ec 08             	sub    $0x8,%esp
  80e538:	56                   	push   %esi
  80e539:	ff 75 18             	pushl  0x18(%ebp)
  80e53c:	ff d7                	call   *%edi
  80e53e:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80e541:	83 eb 01             	sub    $0x1,%ebx
  80e544:	85 db                	test   %ebx,%ebx
  80e546:	7f ed                	jg     80e535 <printnum+0x67>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e548:	83 ec 08             	sub    $0x8,%esp
  80e54b:	56                   	push   %esi
  80e54c:	83 ec 04             	sub    $0x4,%esp
  80e54f:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e552:	ff 75 e0             	pushl  -0x20(%ebp)
  80e555:	ff 75 dc             	pushl  -0x24(%ebp)
  80e558:	ff 75 d8             	pushl  -0x28(%ebp)
  80e55b:	e8 70 25 00 00       	call   810ad0 <__umoddi3>
  80e560:	83 c4 14             	add    $0x14,%esp
  80e563:	0f be 80 8b 32 81 00 	movsbl 0x81328b(%eax),%eax
  80e56a:	50                   	push   %eax
  80e56b:	ff d7                	call   *%edi
  80e56d:	83 c4 10             	add    $0x10,%esp
}
  80e570:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e573:	5b                   	pop    %ebx
  80e574:	5e                   	pop    %esi
  80e575:	5f                   	pop    %edi
  80e576:	5d                   	pop    %ebp
  80e577:	c3                   	ret    

0080e578 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80e578:	55                   	push   %ebp
  80e579:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80e57b:	83 fa 01             	cmp    $0x1,%edx
  80e57e:	7e 0e                	jle    80e58e <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80e580:	8b 10                	mov    (%eax),%edx
  80e582:	8d 4a 08             	lea    0x8(%edx),%ecx
  80e585:	89 08                	mov    %ecx,(%eax)
  80e587:	8b 02                	mov    (%edx),%eax
  80e589:	8b 52 04             	mov    0x4(%edx),%edx
  80e58c:	eb 22                	jmp    80e5b0 <getuint+0x38>
	else if (lflag)
  80e58e:	85 d2                	test   %edx,%edx
  80e590:	74 10                	je     80e5a2 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80e592:	8b 10                	mov    (%eax),%edx
  80e594:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e597:	89 08                	mov    %ecx,(%eax)
  80e599:	8b 02                	mov    (%edx),%eax
  80e59b:	ba 00 00 00 00       	mov    $0x0,%edx
  80e5a0:	eb 0e                	jmp    80e5b0 <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80e5a2:	8b 10                	mov    (%eax),%edx
  80e5a4:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e5a7:	89 08                	mov    %ecx,(%eax)
  80e5a9:	8b 02                	mov    (%edx),%eax
  80e5ab:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80e5b0:	5d                   	pop    %ebp
  80e5b1:	c3                   	ret    

0080e5b2 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e5b2:	55                   	push   %ebp
  80e5b3:	89 e5                	mov    %esp,%ebp
  80e5b5:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e5b8:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e5bc:	8b 10                	mov    (%eax),%edx
  80e5be:	3b 50 04             	cmp    0x4(%eax),%edx
  80e5c1:	73 0a                	jae    80e5cd <sprintputch+0x1b>
		*b->buf++ = ch;
  80e5c3:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e5c6:	89 08                	mov    %ecx,(%eax)
  80e5c8:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5cb:	88 02                	mov    %al,(%edx)
}
  80e5cd:	5d                   	pop    %ebp
  80e5ce:	c3                   	ret    

0080e5cf <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80e5cf:	55                   	push   %ebp
  80e5d0:	89 e5                	mov    %esp,%ebp
  80e5d2:	83 ec 08             	sub    $0x8,%esp
	va_list ap;

	va_start(ap, fmt);
  80e5d5:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e5d8:	50                   	push   %eax
  80e5d9:	ff 75 10             	pushl  0x10(%ebp)
  80e5dc:	ff 75 0c             	pushl  0xc(%ebp)
  80e5df:	ff 75 08             	pushl  0x8(%ebp)
  80e5e2:	e8 05 00 00 00       	call   80e5ec <vprintfmt>
	va_end(ap);
  80e5e7:	83 c4 10             	add    $0x10,%esp
}
  80e5ea:	c9                   	leave  
  80e5eb:	c3                   	ret    

0080e5ec <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80e5ec:	55                   	push   %ebp
  80e5ed:	89 e5                	mov    %esp,%ebp
  80e5ef:	57                   	push   %edi
  80e5f0:	56                   	push   %esi
  80e5f1:	53                   	push   %ebx
  80e5f2:	83 ec 2c             	sub    $0x2c,%esp
  80e5f5:	8b 75 08             	mov    0x8(%ebp),%esi
  80e5f8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e5fb:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e5fe:	eb 12                	jmp    80e612 <vprintfmt+0x26>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80e600:	85 c0                	test   %eax,%eax
  80e602:	0f 84 90 03 00 00    	je     80e998 <vprintfmt+0x3ac>
				return;
			putch(ch, putdat);
  80e608:	83 ec 08             	sub    $0x8,%esp
  80e60b:	53                   	push   %ebx
  80e60c:	50                   	push   %eax
  80e60d:	ff d6                	call   *%esi
  80e60f:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80e612:	83 c7 01             	add    $0x1,%edi
  80e615:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e619:	83 f8 25             	cmp    $0x25,%eax
  80e61c:	75 e2                	jne    80e600 <vprintfmt+0x14>
  80e61e:	c6 45 d4 20          	movb   $0x20,-0x2c(%ebp)
  80e622:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80e629:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e630:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
  80e637:	ba 00 00 00 00       	mov    $0x0,%edx
  80e63c:	eb 07                	jmp    80e645 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e63e:	8b 7d e4             	mov    -0x1c(%ebp),%edi

		// flag to pad on the right
		case '-':
			padc = '-';
  80e641:	c6 45 d4 2d          	movb   $0x2d,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e645:	8d 47 01             	lea    0x1(%edi),%eax
  80e648:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e64b:	0f b6 07             	movzbl (%edi),%eax
  80e64e:	0f b6 c8             	movzbl %al,%ecx
  80e651:	83 e8 23             	sub    $0x23,%eax
  80e654:	3c 55                	cmp    $0x55,%al
  80e656:	0f 87 21 03 00 00    	ja     80e97d <vprintfmt+0x391>
  80e65c:	0f b6 c0             	movzbl %al,%eax
  80e65f:	ff 24 85 c0 33 81 00 	jmp    *0x8133c0(,%eax,4)
  80e666:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80e669:	c6 45 d4 30          	movb   $0x30,-0x2c(%ebp)
  80e66d:	eb d6                	jmp    80e645 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e66f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e672:	b8 00 00 00 00       	mov    $0x0,%eax
  80e677:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80e67a:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e67d:	8d 44 41 d0          	lea    -0x30(%ecx,%eax,2),%eax
				ch = *fmt;
  80e681:	0f be 0f             	movsbl (%edi),%ecx
				if (ch < '0' || ch > '9')
  80e684:	8d 51 d0             	lea    -0x30(%ecx),%edx
  80e687:	83 fa 09             	cmp    $0x9,%edx
  80e68a:	77 39                	ja     80e6c5 <vprintfmt+0xd9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80e68c:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80e68f:	eb e9                	jmp    80e67a <vprintfmt+0x8e>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80e691:	8b 45 14             	mov    0x14(%ebp),%eax
  80e694:	8d 48 04             	lea    0x4(%eax),%ecx
  80e697:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80e69a:	8b 00                	mov    (%eax),%eax
  80e69c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e69f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80e6a2:	eb 27                	jmp    80e6cb <vprintfmt+0xdf>
  80e6a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e6a7:	85 c0                	test   %eax,%eax
  80e6a9:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e6ae:	0f 49 c8             	cmovns %eax,%ecx
  80e6b1:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6b4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e6b7:	eb 8c                	jmp    80e645 <vprintfmt+0x59>
  80e6b9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80e6bc:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
			goto reswitch;
  80e6c3:	eb 80                	jmp    80e645 <vprintfmt+0x59>
  80e6c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e6c8:	89 45 d0             	mov    %eax,-0x30(%ebp)

		process_precision:
			if (width < 0)
  80e6cb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e6cf:	0f 89 70 ff ff ff    	jns    80e645 <vprintfmt+0x59>
				width = precision, precision = -1;
  80e6d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80e6d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e6db:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e6e2:	e9 5e ff ff ff       	jmp    80e645 <vprintfmt+0x59>
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80e6e7:	83 c2 01             	add    $0x1,%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6ea:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80e6ed:	e9 53 ff ff ff       	jmp    80e645 <vprintfmt+0x59>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80e6f2:	8b 45 14             	mov    0x14(%ebp),%eax
  80e6f5:	8d 50 04             	lea    0x4(%eax),%edx
  80e6f8:	89 55 14             	mov    %edx,0x14(%ebp)
  80e6fb:	83 ec 08             	sub    $0x8,%esp
  80e6fe:	53                   	push   %ebx
  80e6ff:	ff 30                	pushl  (%eax)
  80e701:	ff d6                	call   *%esi
			break;
  80e703:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e706:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
			break;
  80e709:	e9 04 ff ff ff       	jmp    80e612 <vprintfmt+0x26>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80e70e:	8b 45 14             	mov    0x14(%ebp),%eax
  80e711:	8d 50 04             	lea    0x4(%eax),%edx
  80e714:	89 55 14             	mov    %edx,0x14(%ebp)
  80e717:	8b 00                	mov    (%eax),%eax
  80e719:	99                   	cltd   
  80e71a:	31 d0                	xor    %edx,%eax
  80e71c:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e71e:	83 f8 0f             	cmp    $0xf,%eax
  80e721:	7f 0b                	jg     80e72e <vprintfmt+0x142>
  80e723:	8b 14 85 40 35 81 00 	mov    0x813540(,%eax,4),%edx
  80e72a:	85 d2                	test   %edx,%edx
  80e72c:	75 18                	jne    80e746 <vprintfmt+0x15a>
				printfmt(putch, putdat, "error %d", err);
  80e72e:	50                   	push   %eax
  80e72f:	68 a3 32 81 00       	push   $0x8132a3
  80e734:	53                   	push   %ebx
  80e735:	56                   	push   %esi
  80e736:	e8 94 fe ff ff       	call   80e5cf <printfmt>
  80e73b:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e73e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80e741:	e9 cc fe ff ff       	jmp    80e612 <vprintfmt+0x26>
			else
				printfmt(putch, putdat, "%s", p);
  80e746:	52                   	push   %edx
  80e747:	68 71 24 81 00       	push   $0x812471
  80e74c:	53                   	push   %ebx
  80e74d:	56                   	push   %esi
  80e74e:	e8 7c fe ff ff       	call   80e5cf <printfmt>
  80e753:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e756:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e759:	e9 b4 fe ff ff       	jmp    80e612 <vprintfmt+0x26>
  80e75e:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80e761:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e764:	89 45 cc             	mov    %eax,-0x34(%ebp)
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80e767:	8b 45 14             	mov    0x14(%ebp),%eax
  80e76a:	8d 50 04             	lea    0x4(%eax),%edx
  80e76d:	89 55 14             	mov    %edx,0x14(%ebp)
  80e770:	8b 38                	mov    (%eax),%edi
				p = "(null)";
  80e772:	85 ff                	test   %edi,%edi
  80e774:	ba 9c 32 81 00       	mov    $0x81329c,%edx
  80e779:	0f 44 fa             	cmove  %edx,%edi
			if (width > 0 && padc != '-')
  80e77c:	80 7d d4 2d          	cmpb   $0x2d,-0x2c(%ebp)
  80e780:	0f 84 92 00 00 00    	je     80e818 <vprintfmt+0x22c>
  80e786:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  80e78a:	0f 8e 96 00 00 00    	jle    80e826 <vprintfmt+0x23a>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e790:	83 ec 08             	sub    $0x8,%esp
  80e793:	51                   	push   %ecx
  80e794:	57                   	push   %edi
  80e795:	e8 86 02 00 00       	call   80ea20 <strnlen>
  80e79a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80e79d:	29 c1                	sub    %eax,%ecx
  80e79f:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  80e7a2:	83 c4 10             	add    $0x10,%esp
					putch(padc, putdat);
  80e7a5:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
  80e7a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e7ac:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80e7af:	89 cf                	mov    %ecx,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e7b1:	eb 0f                	jmp    80e7c2 <vprintfmt+0x1d6>
					putch(padc, putdat);
  80e7b3:	83 ec 08             	sub    $0x8,%esp
  80e7b6:	53                   	push   %ebx
  80e7b7:	ff 75 e0             	pushl  -0x20(%ebp)
  80e7ba:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e7bc:	83 ef 01             	sub    $0x1,%edi
  80e7bf:	83 c4 10             	add    $0x10,%esp
  80e7c2:	85 ff                	test   %edi,%edi
  80e7c4:	7f ed                	jg     80e7b3 <vprintfmt+0x1c7>
  80e7c6:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80e7c9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80e7cc:	85 c9                	test   %ecx,%ecx
  80e7ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80e7d3:	0f 49 c1             	cmovns %ecx,%eax
  80e7d6:	29 c1                	sub    %eax,%ecx
  80e7d8:	89 75 08             	mov    %esi,0x8(%ebp)
  80e7db:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e7de:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e7e1:	89 cb                	mov    %ecx,%ebx
  80e7e3:	eb 4d                	jmp    80e832 <vprintfmt+0x246>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80e7e5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e7e9:	74 1b                	je     80e806 <vprintfmt+0x21a>
  80e7eb:	0f be c0             	movsbl %al,%eax
  80e7ee:	83 e8 20             	sub    $0x20,%eax
  80e7f1:	83 f8 5e             	cmp    $0x5e,%eax
  80e7f4:	76 10                	jbe    80e806 <vprintfmt+0x21a>
					putch('?', putdat);
  80e7f6:	83 ec 08             	sub    $0x8,%esp
  80e7f9:	ff 75 0c             	pushl  0xc(%ebp)
  80e7fc:	6a 3f                	push   $0x3f
  80e7fe:	ff 55 08             	call   *0x8(%ebp)
  80e801:	83 c4 10             	add    $0x10,%esp
  80e804:	eb 0d                	jmp    80e813 <vprintfmt+0x227>
				else
					putch(ch, putdat);
  80e806:	83 ec 08             	sub    $0x8,%esp
  80e809:	ff 75 0c             	pushl  0xc(%ebp)
  80e80c:	52                   	push   %edx
  80e80d:	ff 55 08             	call   *0x8(%ebp)
  80e810:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e813:	83 eb 01             	sub    $0x1,%ebx
  80e816:	eb 1a                	jmp    80e832 <vprintfmt+0x246>
  80e818:	89 75 08             	mov    %esi,0x8(%ebp)
  80e81b:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e81e:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e821:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e824:	eb 0c                	jmp    80e832 <vprintfmt+0x246>
  80e826:	89 75 08             	mov    %esi,0x8(%ebp)
  80e829:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e82c:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e82f:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e832:	83 c7 01             	add    $0x1,%edi
  80e835:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e839:	0f be d0             	movsbl %al,%edx
  80e83c:	85 d2                	test   %edx,%edx
  80e83e:	74 23                	je     80e863 <vprintfmt+0x277>
  80e840:	85 f6                	test   %esi,%esi
  80e842:	78 a1                	js     80e7e5 <vprintfmt+0x1f9>
  80e844:	83 ee 01             	sub    $0x1,%esi
  80e847:	79 9c                	jns    80e7e5 <vprintfmt+0x1f9>
  80e849:	89 df                	mov    %ebx,%edi
  80e84b:	8b 75 08             	mov    0x8(%ebp),%esi
  80e84e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e851:	eb 18                	jmp    80e86b <vprintfmt+0x27f>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80e853:	83 ec 08             	sub    $0x8,%esp
  80e856:	53                   	push   %ebx
  80e857:	6a 20                	push   $0x20
  80e859:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80e85b:	83 ef 01             	sub    $0x1,%edi
  80e85e:	83 c4 10             	add    $0x10,%esp
  80e861:	eb 08                	jmp    80e86b <vprintfmt+0x27f>
  80e863:	89 df                	mov    %ebx,%edi
  80e865:	8b 75 08             	mov    0x8(%ebp),%esi
  80e868:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e86b:	85 ff                	test   %edi,%edi
  80e86d:	7f e4                	jg     80e853 <vprintfmt+0x267>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e86f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e872:	e9 9b fd ff ff       	jmp    80e612 <vprintfmt+0x26>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80e877:	83 fa 01             	cmp    $0x1,%edx
  80e87a:	7e 16                	jle    80e892 <vprintfmt+0x2a6>
		return va_arg(*ap, long long);
  80e87c:	8b 45 14             	mov    0x14(%ebp),%eax
  80e87f:	8d 50 08             	lea    0x8(%eax),%edx
  80e882:	89 55 14             	mov    %edx,0x14(%ebp)
  80e885:	8b 50 04             	mov    0x4(%eax),%edx
  80e888:	8b 00                	mov    (%eax),%eax
  80e88a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e88d:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e890:	eb 32                	jmp    80e8c4 <vprintfmt+0x2d8>
	else if (lflag)
  80e892:	85 d2                	test   %edx,%edx
  80e894:	74 18                	je     80e8ae <vprintfmt+0x2c2>
		return va_arg(*ap, long);
  80e896:	8b 45 14             	mov    0x14(%ebp),%eax
  80e899:	8d 50 04             	lea    0x4(%eax),%edx
  80e89c:	89 55 14             	mov    %edx,0x14(%ebp)
  80e89f:	8b 00                	mov    (%eax),%eax
  80e8a1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e8a4:	89 c1                	mov    %eax,%ecx
  80e8a6:	c1 f9 1f             	sar    $0x1f,%ecx
  80e8a9:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e8ac:	eb 16                	jmp    80e8c4 <vprintfmt+0x2d8>
	else
		return va_arg(*ap, int);
  80e8ae:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8b1:	8d 50 04             	lea    0x4(%eax),%edx
  80e8b4:	89 55 14             	mov    %edx,0x14(%ebp)
  80e8b7:	8b 00                	mov    (%eax),%eax
  80e8b9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e8bc:	89 c1                	mov    %eax,%ecx
  80e8be:	c1 f9 1f             	sar    $0x1f,%ecx
  80e8c1:	89 4d dc             	mov    %ecx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80e8c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e8c7:	8b 55 dc             	mov    -0x24(%ebp),%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80e8ca:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80e8cf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80e8d3:	79 74                	jns    80e949 <vprintfmt+0x35d>
				putch('-', putdat);
  80e8d5:	83 ec 08             	sub    $0x8,%esp
  80e8d8:	53                   	push   %ebx
  80e8d9:	6a 2d                	push   $0x2d
  80e8db:	ff d6                	call   *%esi
				num = -(long long) num;
  80e8dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e8e0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e8e3:	f7 d8                	neg    %eax
  80e8e5:	83 d2 00             	adc    $0x0,%edx
  80e8e8:	f7 da                	neg    %edx
  80e8ea:	83 c4 10             	add    $0x10,%esp
			}
			base = 10;
  80e8ed:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80e8f2:	eb 55                	jmp    80e949 <vprintfmt+0x35d>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80e8f4:	8d 45 14             	lea    0x14(%ebp),%eax
  80e8f7:	e8 7c fc ff ff       	call   80e578 <getuint>
			base = 10;
  80e8fc:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80e901:	eb 46                	jmp    80e949 <vprintfmt+0x35d>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getuint(&ap, lflag);
  80e903:	8d 45 14             	lea    0x14(%ebp),%eax
  80e906:	e8 6d fc ff ff       	call   80e578 <getuint>
                        base = 8;
  80e90b:	b9 08 00 00 00       	mov    $0x8,%ecx
                        goto number;
  80e910:	eb 37                	jmp    80e949 <vprintfmt+0x35d>

		// pointer
		case 'p':
			putch('0', putdat);
  80e912:	83 ec 08             	sub    $0x8,%esp
  80e915:	53                   	push   %ebx
  80e916:	6a 30                	push   $0x30
  80e918:	ff d6                	call   *%esi
			putch('x', putdat);
  80e91a:	83 c4 08             	add    $0x8,%esp
  80e91d:	53                   	push   %ebx
  80e91e:	6a 78                	push   $0x78
  80e920:	ff d6                	call   *%esi
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80e922:	8b 45 14             	mov    0x14(%ebp),%eax
  80e925:	8d 50 04             	lea    0x4(%eax),%edx
  80e928:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80e92b:	8b 00                	mov    (%eax),%eax
  80e92d:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  80e932:	83 c4 10             	add    $0x10,%esp
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80e935:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80e93a:	eb 0d                	jmp    80e949 <vprintfmt+0x35d>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80e93c:	8d 45 14             	lea    0x14(%ebp),%eax
  80e93f:	e8 34 fc ff ff       	call   80e578 <getuint>
			base = 16;
  80e944:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80e949:	83 ec 0c             	sub    $0xc,%esp
  80e94c:	0f be 7d d4          	movsbl -0x2c(%ebp),%edi
  80e950:	57                   	push   %edi
  80e951:	ff 75 e0             	pushl  -0x20(%ebp)
  80e954:	51                   	push   %ecx
  80e955:	52                   	push   %edx
  80e956:	50                   	push   %eax
  80e957:	89 da                	mov    %ebx,%edx
  80e959:	89 f0                	mov    %esi,%eax
  80e95b:	e8 6e fb ff ff       	call   80e4ce <printnum>
			break;
  80e960:	83 c4 20             	add    $0x20,%esp
  80e963:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e966:	e9 a7 fc ff ff       	jmp    80e612 <vprintfmt+0x26>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80e96b:	83 ec 08             	sub    $0x8,%esp
  80e96e:	53                   	push   %ebx
  80e96f:	51                   	push   %ecx
  80e970:	ff d6                	call   *%esi
			break;
  80e972:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e975:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
			break;
  80e978:	e9 95 fc ff ff       	jmp    80e612 <vprintfmt+0x26>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80e97d:	83 ec 08             	sub    $0x8,%esp
  80e980:	53                   	push   %ebx
  80e981:	6a 25                	push   $0x25
  80e983:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80e985:	83 c4 10             	add    $0x10,%esp
  80e988:	eb 03                	jmp    80e98d <vprintfmt+0x3a1>
  80e98a:	83 ef 01             	sub    $0x1,%edi
  80e98d:	80 7f ff 25          	cmpb   $0x25,-0x1(%edi)
  80e991:	75 f7                	jne    80e98a <vprintfmt+0x39e>
  80e993:	e9 7a fc ff ff       	jmp    80e612 <vprintfmt+0x26>
				/* do nothing */;
			break;
		}
	}
}
  80e998:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e99b:	5b                   	pop    %ebx
  80e99c:	5e                   	pop    %esi
  80e99d:	5f                   	pop    %edi
  80e99e:	5d                   	pop    %ebp
  80e99f:	c3                   	ret    

0080e9a0 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80e9a0:	55                   	push   %ebp
  80e9a1:	89 e5                	mov    %esp,%ebp
  80e9a3:	83 ec 18             	sub    $0x18,%esp
  80e9a6:	8b 45 08             	mov    0x8(%ebp),%eax
  80e9a9:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80e9ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80e9af:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80e9b3:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80e9b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80e9bd:	85 c0                	test   %eax,%eax
  80e9bf:	74 26                	je     80e9e7 <vsnprintf+0x47>
  80e9c1:	85 d2                	test   %edx,%edx
  80e9c3:	7e 22                	jle    80e9e7 <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80e9c5:	ff 75 14             	pushl  0x14(%ebp)
  80e9c8:	ff 75 10             	pushl  0x10(%ebp)
  80e9cb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80e9ce:	50                   	push   %eax
  80e9cf:	68 b2 e5 80 00       	push   $0x80e5b2
  80e9d4:	e8 13 fc ff ff       	call   80e5ec <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80e9d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80e9dc:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80e9df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e9e2:	83 c4 10             	add    $0x10,%esp
  80e9e5:	eb 05                	jmp    80e9ec <vsnprintf+0x4c>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80e9e7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80e9ec:	c9                   	leave  
  80e9ed:	c3                   	ret    

0080e9ee <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80e9ee:	55                   	push   %ebp
  80e9ef:	89 e5                	mov    %esp,%ebp
  80e9f1:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80e9f4:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80e9f7:	50                   	push   %eax
  80e9f8:	ff 75 10             	pushl  0x10(%ebp)
  80e9fb:	ff 75 0c             	pushl  0xc(%ebp)
  80e9fe:	ff 75 08             	pushl  0x8(%ebp)
  80ea01:	e8 9a ff ff ff       	call   80e9a0 <vsnprintf>
	va_end(ap);

	return rc;
}
  80ea06:	c9                   	leave  
  80ea07:	c3                   	ret    

0080ea08 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80ea08:	55                   	push   %ebp
  80ea09:	89 e5                	mov    %esp,%ebp
  80ea0b:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80ea0e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea13:	eb 03                	jmp    80ea18 <strlen+0x10>
		n++;
  80ea15:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80ea18:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80ea1c:	75 f7                	jne    80ea15 <strlen+0xd>
		n++;
	return n;
}
  80ea1e:	5d                   	pop    %ebp
  80ea1f:	c3                   	ret    

0080ea20 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80ea20:	55                   	push   %ebp
  80ea21:	89 e5                	mov    %esp,%ebp
  80ea23:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ea26:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ea29:	ba 00 00 00 00       	mov    $0x0,%edx
  80ea2e:	eb 03                	jmp    80ea33 <strnlen+0x13>
		n++;
  80ea30:	83 c2 01             	add    $0x1,%edx
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ea33:	39 c2                	cmp    %eax,%edx
  80ea35:	74 08                	je     80ea3f <strnlen+0x1f>
  80ea37:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80ea3b:	75 f3                	jne    80ea30 <strnlen+0x10>
  80ea3d:	89 d0                	mov    %edx,%eax
		n++;
	return n;
}
  80ea3f:	5d                   	pop    %ebp
  80ea40:	c3                   	ret    

0080ea41 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80ea41:	55                   	push   %ebp
  80ea42:	89 e5                	mov    %esp,%ebp
  80ea44:	53                   	push   %ebx
  80ea45:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea48:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80ea4b:	89 c2                	mov    %eax,%edx
  80ea4d:	83 c2 01             	add    $0x1,%edx
  80ea50:	83 c1 01             	add    $0x1,%ecx
  80ea53:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80ea57:	88 5a ff             	mov    %bl,-0x1(%edx)
  80ea5a:	84 db                	test   %bl,%bl
  80ea5c:	75 ef                	jne    80ea4d <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80ea5e:	5b                   	pop    %ebx
  80ea5f:	5d                   	pop    %ebp
  80ea60:	c3                   	ret    

0080ea61 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80ea61:	55                   	push   %ebp
  80ea62:	89 e5                	mov    %esp,%ebp
  80ea64:	53                   	push   %ebx
  80ea65:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ea68:	53                   	push   %ebx
  80ea69:	e8 9a ff ff ff       	call   80ea08 <strlen>
  80ea6e:	83 c4 04             	add    $0x4,%esp
	strcpy(dst + len, src);
  80ea71:	ff 75 0c             	pushl  0xc(%ebp)
  80ea74:	01 d8                	add    %ebx,%eax
  80ea76:	50                   	push   %eax
  80ea77:	e8 c5 ff ff ff       	call   80ea41 <strcpy>
	return dst;
}
  80ea7c:	89 d8                	mov    %ebx,%eax
  80ea7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ea81:	c9                   	leave  
  80ea82:	c3                   	ret    

0080ea83 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ea83:	55                   	push   %ebp
  80ea84:	89 e5                	mov    %esp,%ebp
  80ea86:	56                   	push   %esi
  80ea87:	53                   	push   %ebx
  80ea88:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea8b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ea8e:	89 f3                	mov    %esi,%ebx
  80ea90:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ea93:	89 f2                	mov    %esi,%edx
  80ea95:	eb 0f                	jmp    80eaa6 <strncpy+0x23>
		*dst++ = *src;
  80ea97:	83 c2 01             	add    $0x1,%edx
  80ea9a:	0f b6 01             	movzbl (%ecx),%eax
  80ea9d:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80eaa0:	80 39 01             	cmpb   $0x1,(%ecx)
  80eaa3:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80eaa6:	39 da                	cmp    %ebx,%edx
  80eaa8:	75 ed                	jne    80ea97 <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80eaaa:	89 f0                	mov    %esi,%eax
  80eaac:	5b                   	pop    %ebx
  80eaad:	5e                   	pop    %esi
  80eaae:	5d                   	pop    %ebp
  80eaaf:	c3                   	ret    

0080eab0 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80eab0:	55                   	push   %ebp
  80eab1:	89 e5                	mov    %esp,%ebp
  80eab3:	56                   	push   %esi
  80eab4:	53                   	push   %ebx
  80eab5:	8b 75 08             	mov    0x8(%ebp),%esi
  80eab8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eabb:	8b 55 10             	mov    0x10(%ebp),%edx
  80eabe:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80eac0:	85 d2                	test   %edx,%edx
  80eac2:	74 21                	je     80eae5 <strlcpy+0x35>
  80eac4:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80eac8:	89 f2                	mov    %esi,%edx
  80eaca:	eb 09                	jmp    80ead5 <strlcpy+0x25>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80eacc:	83 c2 01             	add    $0x1,%edx
  80eacf:	83 c1 01             	add    $0x1,%ecx
  80ead2:	88 5a ff             	mov    %bl,-0x1(%edx)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80ead5:	39 c2                	cmp    %eax,%edx
  80ead7:	74 09                	je     80eae2 <strlcpy+0x32>
  80ead9:	0f b6 19             	movzbl (%ecx),%ebx
  80eadc:	84 db                	test   %bl,%bl
  80eade:	75 ec                	jne    80eacc <strlcpy+0x1c>
  80eae0:	89 d0                	mov    %edx,%eax
			*dst++ = *src++;
		*dst = '\0';
  80eae2:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80eae5:	29 f0                	sub    %esi,%eax
}
  80eae7:	5b                   	pop    %ebx
  80eae8:	5e                   	pop    %esi
  80eae9:	5d                   	pop    %ebp
  80eaea:	c3                   	ret    

0080eaeb <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80eaeb:	55                   	push   %ebp
  80eaec:	89 e5                	mov    %esp,%ebp
  80eaee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80eaf1:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80eaf4:	eb 06                	jmp    80eafc <strcmp+0x11>
		p++, q++;
  80eaf6:	83 c1 01             	add    $0x1,%ecx
  80eaf9:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80eafc:	0f b6 01             	movzbl (%ecx),%eax
  80eaff:	84 c0                	test   %al,%al
  80eb01:	74 04                	je     80eb07 <strcmp+0x1c>
  80eb03:	3a 02                	cmp    (%edx),%al
  80eb05:	74 ef                	je     80eaf6 <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80eb07:	0f b6 c0             	movzbl %al,%eax
  80eb0a:	0f b6 12             	movzbl (%edx),%edx
  80eb0d:	29 d0                	sub    %edx,%eax
}
  80eb0f:	5d                   	pop    %ebp
  80eb10:	c3                   	ret    

0080eb11 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80eb11:	55                   	push   %ebp
  80eb12:	89 e5                	mov    %esp,%ebp
  80eb14:	53                   	push   %ebx
  80eb15:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb18:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eb1b:	89 c3                	mov    %eax,%ebx
  80eb1d:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80eb20:	eb 06                	jmp    80eb28 <strncmp+0x17>
		n--, p++, q++;
  80eb22:	83 c0 01             	add    $0x1,%eax
  80eb25:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80eb28:	39 d8                	cmp    %ebx,%eax
  80eb2a:	74 15                	je     80eb41 <strncmp+0x30>
  80eb2c:	0f b6 08             	movzbl (%eax),%ecx
  80eb2f:	84 c9                	test   %cl,%cl
  80eb31:	74 04                	je     80eb37 <strncmp+0x26>
  80eb33:	3a 0a                	cmp    (%edx),%cl
  80eb35:	74 eb                	je     80eb22 <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80eb37:	0f b6 00             	movzbl (%eax),%eax
  80eb3a:	0f b6 12             	movzbl (%edx),%edx
  80eb3d:	29 d0                	sub    %edx,%eax
  80eb3f:	eb 05                	jmp    80eb46 <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80eb41:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80eb46:	5b                   	pop    %ebx
  80eb47:	5d                   	pop    %ebp
  80eb48:	c3                   	ret    

0080eb49 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80eb49:	55                   	push   %ebp
  80eb4a:	89 e5                	mov    %esp,%ebp
  80eb4c:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb4f:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eb53:	eb 07                	jmp    80eb5c <strchr+0x13>
		if (*s == c)
  80eb55:	38 ca                	cmp    %cl,%dl
  80eb57:	74 0f                	je     80eb68 <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80eb59:	83 c0 01             	add    $0x1,%eax
  80eb5c:	0f b6 10             	movzbl (%eax),%edx
  80eb5f:	84 d2                	test   %dl,%dl
  80eb61:	75 f2                	jne    80eb55 <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80eb63:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80eb68:	5d                   	pop    %ebp
  80eb69:	c3                   	ret    

0080eb6a <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80eb6a:	55                   	push   %ebp
  80eb6b:	89 e5                	mov    %esp,%ebp
  80eb6d:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb70:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eb74:	eb 03                	jmp    80eb79 <strfind+0xf>
  80eb76:	83 c0 01             	add    $0x1,%eax
  80eb79:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80eb7c:	84 d2                	test   %dl,%dl
  80eb7e:	74 04                	je     80eb84 <strfind+0x1a>
  80eb80:	38 ca                	cmp    %cl,%dl
  80eb82:	75 f2                	jne    80eb76 <strfind+0xc>
			break;
	return (char *) s;
}
  80eb84:	5d                   	pop    %ebp
  80eb85:	c3                   	ret    

0080eb86 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80eb86:	55                   	push   %ebp
  80eb87:	89 e5                	mov    %esp,%ebp
  80eb89:	57                   	push   %edi
  80eb8a:	56                   	push   %esi
  80eb8b:	53                   	push   %ebx
  80eb8c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80eb8f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80eb92:	85 c9                	test   %ecx,%ecx
  80eb94:	74 36                	je     80ebcc <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80eb96:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80eb9c:	75 28                	jne    80ebc6 <memset+0x40>
  80eb9e:	f6 c1 03             	test   $0x3,%cl
  80eba1:	75 23                	jne    80ebc6 <memset+0x40>
		c &= 0xFF;
  80eba3:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80eba7:	89 d3                	mov    %edx,%ebx
  80eba9:	c1 e3 08             	shl    $0x8,%ebx
  80ebac:	89 d6                	mov    %edx,%esi
  80ebae:	c1 e6 18             	shl    $0x18,%esi
  80ebb1:	89 d0                	mov    %edx,%eax
  80ebb3:	c1 e0 10             	shl    $0x10,%eax
  80ebb6:	09 f0                	or     %esi,%eax
  80ebb8:	09 c2                	or     %eax,%edx
  80ebba:	89 d0                	mov    %edx,%eax
  80ebbc:	09 d8                	or     %ebx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80ebbe:	c1 e9 02             	shr    $0x2,%ecx
	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80ebc1:	fc                   	cld    
  80ebc2:	f3 ab                	rep stos %eax,%es:(%edi)
  80ebc4:	eb 06                	jmp    80ebcc <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80ebc6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ebc9:	fc                   	cld    
  80ebca:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80ebcc:	89 f8                	mov    %edi,%eax
  80ebce:	5b                   	pop    %ebx
  80ebcf:	5e                   	pop    %esi
  80ebd0:	5f                   	pop    %edi
  80ebd1:	5d                   	pop    %ebp
  80ebd2:	c3                   	ret    

0080ebd3 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80ebd3:	55                   	push   %ebp
  80ebd4:	89 e5                	mov    %esp,%ebp
  80ebd6:	57                   	push   %edi
  80ebd7:	56                   	push   %esi
  80ebd8:	8b 45 08             	mov    0x8(%ebp),%eax
  80ebdb:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ebde:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80ebe1:	39 c6                	cmp    %eax,%esi
  80ebe3:	73 35                	jae    80ec1a <memmove+0x47>
  80ebe5:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80ebe8:	39 d0                	cmp    %edx,%eax
  80ebea:	73 2e                	jae    80ec1a <memmove+0x47>
		s += n;
		d += n;
  80ebec:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
  80ebef:	89 d6                	mov    %edx,%esi
  80ebf1:	09 fe                	or     %edi,%esi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ebf3:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80ebf9:	75 13                	jne    80ec0e <memmove+0x3b>
  80ebfb:	f6 c1 03             	test   $0x3,%cl
  80ebfe:	75 0e                	jne    80ec0e <memmove+0x3b>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80ec00:	83 ef 04             	sub    $0x4,%edi
  80ec03:	8d 72 fc             	lea    -0x4(%edx),%esi
  80ec06:	c1 e9 02             	shr    $0x2,%ecx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80ec09:	fd                   	std    
  80ec0a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ec0c:	eb 09                	jmp    80ec17 <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80ec0e:	83 ef 01             	sub    $0x1,%edi
  80ec11:	8d 72 ff             	lea    -0x1(%edx),%esi
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80ec14:	fd                   	std    
  80ec15:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80ec17:	fc                   	cld    
  80ec18:	eb 1d                	jmp    80ec37 <memmove+0x64>
  80ec1a:	89 f2                	mov    %esi,%edx
  80ec1c:	09 c2                	or     %eax,%edx
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80ec1e:	f6 c2 03             	test   $0x3,%dl
  80ec21:	75 0f                	jne    80ec32 <memmove+0x5f>
  80ec23:	f6 c1 03             	test   $0x3,%cl
  80ec26:	75 0a                	jne    80ec32 <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80ec28:	c1 e9 02             	shr    $0x2,%ecx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80ec2b:	89 c7                	mov    %eax,%edi
  80ec2d:	fc                   	cld    
  80ec2e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80ec30:	eb 05                	jmp    80ec37 <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80ec32:	89 c7                	mov    %eax,%edi
  80ec34:	fc                   	cld    
  80ec35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80ec37:	5e                   	pop    %esi
  80ec38:	5f                   	pop    %edi
  80ec39:	5d                   	pop    %ebp
  80ec3a:	c3                   	ret    

0080ec3b <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80ec3b:	55                   	push   %ebp
  80ec3c:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  80ec3e:	ff 75 10             	pushl  0x10(%ebp)
  80ec41:	ff 75 0c             	pushl  0xc(%ebp)
  80ec44:	ff 75 08             	pushl  0x8(%ebp)
  80ec47:	e8 87 ff ff ff       	call   80ebd3 <memmove>
}
  80ec4c:	c9                   	leave  
  80ec4d:	c3                   	ret    

0080ec4e <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80ec4e:	55                   	push   %ebp
  80ec4f:	89 e5                	mov    %esp,%ebp
  80ec51:	56                   	push   %esi
  80ec52:	53                   	push   %ebx
  80ec53:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec56:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ec59:	89 c6                	mov    %eax,%esi
  80ec5b:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ec5e:	eb 1a                	jmp    80ec7a <memcmp+0x2c>
		if (*s1 != *s2)
  80ec60:	0f b6 08             	movzbl (%eax),%ecx
  80ec63:	0f b6 1a             	movzbl (%edx),%ebx
  80ec66:	38 d9                	cmp    %bl,%cl
  80ec68:	74 0a                	je     80ec74 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80ec6a:	0f b6 c1             	movzbl %cl,%eax
  80ec6d:	0f b6 db             	movzbl %bl,%ebx
  80ec70:	29 d8                	sub    %ebx,%eax
  80ec72:	eb 0f                	jmp    80ec83 <memcmp+0x35>
		s1++, s2++;
  80ec74:	83 c0 01             	add    $0x1,%eax
  80ec77:	83 c2 01             	add    $0x1,%edx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ec7a:	39 f0                	cmp    %esi,%eax
  80ec7c:	75 e2                	jne    80ec60 <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80ec7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ec83:	5b                   	pop    %ebx
  80ec84:	5e                   	pop    %esi
  80ec85:	5d                   	pop    %ebp
  80ec86:	c3                   	ret    

0080ec87 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80ec87:	55                   	push   %ebp
  80ec88:	89 e5                	mov    %esp,%ebp
  80ec8a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ec8d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80ec90:	89 c2                	mov    %eax,%edx
  80ec92:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80ec95:	eb 07                	jmp    80ec9e <memfind+0x17>
		if (*(const unsigned char *) s == (unsigned char) c)
  80ec97:	38 08                	cmp    %cl,(%eax)
  80ec99:	74 07                	je     80eca2 <memfind+0x1b>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ec9b:	83 c0 01             	add    $0x1,%eax
  80ec9e:	39 d0                	cmp    %edx,%eax
  80eca0:	72 f5                	jb     80ec97 <memfind+0x10>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80eca2:	5d                   	pop    %ebp
  80eca3:	c3                   	ret    

0080eca4 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80eca4:	55                   	push   %ebp
  80eca5:	89 e5                	mov    %esp,%ebp
  80eca7:	57                   	push   %edi
  80eca8:	56                   	push   %esi
  80eca9:	53                   	push   %ebx
  80ecaa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ecad:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ecb0:	eb 03                	jmp    80ecb5 <strtol+0x11>
		s++;
  80ecb2:	83 c1 01             	add    $0x1,%ecx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ecb5:	0f b6 01             	movzbl (%ecx),%eax
  80ecb8:	3c 09                	cmp    $0x9,%al
  80ecba:	74 f6                	je     80ecb2 <strtol+0xe>
  80ecbc:	3c 20                	cmp    $0x20,%al
  80ecbe:	74 f2                	je     80ecb2 <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80ecc0:	3c 2b                	cmp    $0x2b,%al
  80ecc2:	75 0a                	jne    80ecce <strtol+0x2a>
		s++;
  80ecc4:	83 c1 01             	add    $0x1,%ecx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80ecc7:	bf 00 00 00 00       	mov    $0x0,%edi
  80eccc:	eb 10                	jmp    80ecde <strtol+0x3a>
  80ecce:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80ecd3:	3c 2d                	cmp    $0x2d,%al
  80ecd5:	75 07                	jne    80ecde <strtol+0x3a>
		s++, neg = 1;
  80ecd7:	8d 49 01             	lea    0x1(%ecx),%ecx
  80ecda:	66 bf 01 00          	mov    $0x1,%di

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80ecde:	85 db                	test   %ebx,%ebx
  80ece0:	0f 94 c0             	sete   %al
  80ece3:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80ece9:	75 19                	jne    80ed04 <strtol+0x60>
  80eceb:	80 39 30             	cmpb   $0x30,(%ecx)
  80ecee:	75 14                	jne    80ed04 <strtol+0x60>
  80ecf0:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80ecf4:	0f 85 82 00 00 00    	jne    80ed7c <strtol+0xd8>
		s += 2, base = 16;
  80ecfa:	83 c1 02             	add    $0x2,%ecx
  80ecfd:	bb 10 00 00 00       	mov    $0x10,%ebx
  80ed02:	eb 16                	jmp    80ed1a <strtol+0x76>
	else if (base == 0 && s[0] == '0')
  80ed04:	84 c0                	test   %al,%al
  80ed06:	74 12                	je     80ed1a <strtol+0x76>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80ed08:	bb 0a 00 00 00       	mov    $0xa,%ebx
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ed0d:	80 39 30             	cmpb   $0x30,(%ecx)
  80ed10:	75 08                	jne    80ed1a <strtol+0x76>
		s++, base = 8;
  80ed12:	83 c1 01             	add    $0x1,%ecx
  80ed15:	bb 08 00 00 00       	mov    $0x8,%ebx
	else if (base == 0)
		base = 10;
  80ed1a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed1f:	89 5d 10             	mov    %ebx,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80ed22:	0f b6 11             	movzbl (%ecx),%edx
  80ed25:	8d 72 d0             	lea    -0x30(%edx),%esi
  80ed28:	89 f3                	mov    %esi,%ebx
  80ed2a:	80 fb 09             	cmp    $0x9,%bl
  80ed2d:	77 08                	ja     80ed37 <strtol+0x93>
			dig = *s - '0';
  80ed2f:	0f be d2             	movsbl %dl,%edx
  80ed32:	83 ea 30             	sub    $0x30,%edx
  80ed35:	eb 22                	jmp    80ed59 <strtol+0xb5>
		else if (*s >= 'a' && *s <= 'z')
  80ed37:	8d 72 9f             	lea    -0x61(%edx),%esi
  80ed3a:	89 f3                	mov    %esi,%ebx
  80ed3c:	80 fb 19             	cmp    $0x19,%bl
  80ed3f:	77 08                	ja     80ed49 <strtol+0xa5>
			dig = *s - 'a' + 10;
  80ed41:	0f be d2             	movsbl %dl,%edx
  80ed44:	83 ea 57             	sub    $0x57,%edx
  80ed47:	eb 10                	jmp    80ed59 <strtol+0xb5>
		else if (*s >= 'A' && *s <= 'Z')
  80ed49:	8d 72 bf             	lea    -0x41(%edx),%esi
  80ed4c:	89 f3                	mov    %esi,%ebx
  80ed4e:	80 fb 19             	cmp    $0x19,%bl
  80ed51:	77 16                	ja     80ed69 <strtol+0xc5>
			dig = *s - 'A' + 10;
  80ed53:	0f be d2             	movsbl %dl,%edx
  80ed56:	83 ea 37             	sub    $0x37,%edx
		else
			break;
		if (dig >= base)
  80ed59:	3b 55 10             	cmp    0x10(%ebp),%edx
  80ed5c:	7d 0f                	jge    80ed6d <strtol+0xc9>
			break;
		s++, val = (val * base) + dig;
  80ed5e:	83 c1 01             	add    $0x1,%ecx
  80ed61:	0f af 45 10          	imul   0x10(%ebp),%eax
  80ed65:	01 d0                	add    %edx,%eax
		// we don't properly detect overflow!
	}
  80ed67:	eb b9                	jmp    80ed22 <strtol+0x7e>
  80ed69:	89 c2                	mov    %eax,%edx
  80ed6b:	eb 02                	jmp    80ed6f <strtol+0xcb>
  80ed6d:	89 c2                	mov    %eax,%edx

	if (endptr)
  80ed6f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80ed73:	74 0d                	je     80ed82 <strtol+0xde>
		*endptr = (char *) s;
  80ed75:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ed78:	89 0e                	mov    %ecx,(%esi)
  80ed7a:	eb 06                	jmp    80ed82 <strtol+0xde>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ed7c:	84 c0                	test   %al,%al
  80ed7e:	75 92                	jne    80ed12 <strtol+0x6e>
  80ed80:	eb 98                	jmp    80ed1a <strtol+0x76>
		// we don't properly detect overflow!
	}

	if (endptr)
		*endptr = (char *) s;
	return (neg ? -val : val);
  80ed82:	f7 da                	neg    %edx
  80ed84:	85 ff                	test   %edi,%edi
  80ed86:	0f 45 c2             	cmovne %edx,%eax
}
  80ed89:	5b                   	pop    %ebx
  80ed8a:	5e                   	pop    %esi
  80ed8b:	5f                   	pop    %edi
  80ed8c:	5d                   	pop    %ebp
  80ed8d:	c3                   	ret    

0080ed8e <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{    
  80ed8e:	55                   	push   %ebp
  80ed8f:	89 e5                	mov    %esp,%ebp
  80ed91:	57                   	push   %edi
  80ed92:	56                   	push   %esi
  80ed93:	53                   	push   %ebx
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ed94:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed99:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ed9c:	8b 55 08             	mov    0x8(%ebp),%edx
  80ed9f:	89 c3                	mov    %eax,%ebx
  80eda1:	89 c7                	mov    %eax,%edi
  80eda3:	89 c6                	mov    %eax,%esi
  80eda5:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{    
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80eda7:	5b                   	pop    %ebx
  80eda8:	5e                   	pop    %esi
  80eda9:	5f                   	pop    %edi
  80edaa:	5d                   	pop    %ebp
  80edab:	c3                   	ret    

0080edac <sys_cgetc>:

int
sys_cgetc(void)
{
  80edac:	55                   	push   %ebp
  80edad:	89 e5                	mov    %esp,%ebp
  80edaf:	57                   	push   %edi
  80edb0:	56                   	push   %esi
  80edb1:	53                   	push   %ebx
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80edb2:	ba 00 00 00 00       	mov    $0x0,%edx
  80edb7:	b8 01 00 00 00       	mov    $0x1,%eax
  80edbc:	89 d1                	mov    %edx,%ecx
  80edbe:	89 d3                	mov    %edx,%ebx
  80edc0:	89 d7                	mov    %edx,%edi
  80edc2:	89 d6                	mov    %edx,%esi
  80edc4:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80edc6:	5b                   	pop    %ebx
  80edc7:	5e                   	pop    %esi
  80edc8:	5f                   	pop    %edi
  80edc9:	5d                   	pop    %ebp
  80edca:	c3                   	ret    

0080edcb <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80edcb:	55                   	push   %ebp
  80edcc:	89 e5                	mov    %esp,%ebp
  80edce:	57                   	push   %edi
  80edcf:	56                   	push   %esi
  80edd0:	53                   	push   %ebx
  80edd1:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80edd4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80edd9:	b8 03 00 00 00       	mov    $0x3,%eax
  80edde:	8b 55 08             	mov    0x8(%ebp),%edx
  80ede1:	89 cb                	mov    %ecx,%ebx
  80ede3:	89 cf                	mov    %ecx,%edi
  80ede5:	89 ce                	mov    %ecx,%esi
  80ede7:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ede9:	85 c0                	test   %eax,%eax
  80edeb:	7e 17                	jle    80ee04 <sys_env_destroy+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eded:	83 ec 0c             	sub    $0xc,%esp
  80edf0:	50                   	push   %eax
  80edf1:	6a 03                	push   $0x3
  80edf3:	68 9f 35 81 00       	push   $0x81359f
  80edf8:	6a 22                	push   $0x22
  80edfa:	68 bc 35 81 00       	push   $0x8135bc
  80edff:	e8 dd f5 ff ff       	call   80e3e1 <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80ee04:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee07:	5b                   	pop    %ebx
  80ee08:	5e                   	pop    %esi
  80ee09:	5f                   	pop    %edi
  80ee0a:	5d                   	pop    %ebp
  80ee0b:	c3                   	ret    

0080ee0c <sys_getenvid>:

envid_t
sys_getenvid(void)
{                 
  80ee0c:	55                   	push   %ebp
  80ee0d:	89 e5                	mov    %esp,%ebp
  80ee0f:	57                   	push   %edi
  80ee10:	56                   	push   %esi
  80ee11:	53                   	push   %ebx
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ee12:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee17:	b8 02 00 00 00       	mov    $0x2,%eax
  80ee1c:	89 d1                	mov    %edx,%ecx
  80ee1e:	89 d3                	mov    %edx,%ebx
  80ee20:	89 d7                	mov    %edx,%edi
  80ee22:	89 d6                	mov    %edx,%esi
  80ee24:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{                 
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80ee26:	5b                   	pop    %ebx
  80ee27:	5e                   	pop    %esi
  80ee28:	5f                   	pop    %edi
  80ee29:	5d                   	pop    %ebp
  80ee2a:	c3                   	ret    

0080ee2b <sys_yield>:

void
sys_yield(void)
{      
  80ee2b:	55                   	push   %ebp
  80ee2c:	89 e5                	mov    %esp,%ebp
  80ee2e:	57                   	push   %edi
  80ee2f:	56                   	push   %esi
  80ee30:	53                   	push   %ebx
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ee31:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee36:	b8 0b 00 00 00       	mov    $0xb,%eax
  80ee3b:	89 d1                	mov    %edx,%ecx
  80ee3d:	89 d3                	mov    %edx,%ebx
  80ee3f:	89 d7                	mov    %edx,%edi
  80ee41:	89 d6                	mov    %edx,%esi
  80ee43:	cd 30                	int    $0x30

void
sys_yield(void)
{      
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80ee45:	5b                   	pop    %ebx
  80ee46:	5e                   	pop    %esi
  80ee47:	5f                   	pop    %edi
  80ee48:	5d                   	pop    %ebp
  80ee49:	c3                   	ret    

0080ee4a <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80ee4a:	55                   	push   %ebp
  80ee4b:	89 e5                	mov    %esp,%ebp
  80ee4d:	57                   	push   %edi
  80ee4e:	56                   	push   %esi
  80ee4f:	53                   	push   %ebx
  80ee50:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ee53:	be 00 00 00 00       	mov    $0x0,%esi
  80ee58:	b8 04 00 00 00       	mov    $0x4,%eax
  80ee5d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee60:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee63:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ee66:	89 f7                	mov    %esi,%edi
  80ee68:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ee6a:	85 c0                	test   %eax,%eax
  80ee6c:	7e 17                	jle    80ee85 <sys_page_alloc+0x3b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee6e:	83 ec 0c             	sub    $0xc,%esp
  80ee71:	50                   	push   %eax
  80ee72:	6a 04                	push   $0x4
  80ee74:	68 9f 35 81 00       	push   $0x81359f
  80ee79:	6a 22                	push   $0x22
  80ee7b:	68 bc 35 81 00       	push   $0x8135bc
  80ee80:	e8 5c f5 ff ff       	call   80e3e1 <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80ee85:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee88:	5b                   	pop    %ebx
  80ee89:	5e                   	pop    %esi
  80ee8a:	5f                   	pop    %edi
  80ee8b:	5d                   	pop    %ebp
  80ee8c:	c3                   	ret    

0080ee8d <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80ee8d:	55                   	push   %ebp
  80ee8e:	89 e5                	mov    %esp,%ebp
  80ee90:	57                   	push   %edi
  80ee91:	56                   	push   %esi
  80ee92:	53                   	push   %ebx
  80ee93:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ee96:	b8 05 00 00 00       	mov    $0x5,%eax
  80ee9b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee9e:	8b 55 08             	mov    0x8(%ebp),%edx
  80eea1:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80eea4:	8b 7d 14             	mov    0x14(%ebp),%edi
  80eea7:	8b 75 18             	mov    0x18(%ebp),%esi
  80eeaa:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80eeac:	85 c0                	test   %eax,%eax
  80eeae:	7e 17                	jle    80eec7 <sys_page_map+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eeb0:	83 ec 0c             	sub    $0xc,%esp
  80eeb3:	50                   	push   %eax
  80eeb4:	6a 05                	push   $0x5
  80eeb6:	68 9f 35 81 00       	push   $0x81359f
  80eebb:	6a 22                	push   $0x22
  80eebd:	68 bc 35 81 00       	push   $0x8135bc
  80eec2:	e8 1a f5 ff ff       	call   80e3e1 <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80eec7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eeca:	5b                   	pop    %ebx
  80eecb:	5e                   	pop    %esi
  80eecc:	5f                   	pop    %edi
  80eecd:	5d                   	pop    %ebp
  80eece:	c3                   	ret    

0080eecf <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80eecf:	55                   	push   %ebp
  80eed0:	89 e5                	mov    %esp,%ebp
  80eed2:	57                   	push   %edi
  80eed3:	56                   	push   %esi
  80eed4:	53                   	push   %ebx
  80eed5:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80eed8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80eedd:	b8 06 00 00 00       	mov    $0x6,%eax
  80eee2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eee5:	8b 55 08             	mov    0x8(%ebp),%edx
  80eee8:	89 df                	mov    %ebx,%edi
  80eeea:	89 de                	mov    %ebx,%esi
  80eeec:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80eeee:	85 c0                	test   %eax,%eax
  80eef0:	7e 17                	jle    80ef09 <sys_page_unmap+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eef2:	83 ec 0c             	sub    $0xc,%esp
  80eef5:	50                   	push   %eax
  80eef6:	6a 06                	push   $0x6
  80eef8:	68 9f 35 81 00       	push   $0x81359f
  80eefd:	6a 22                	push   $0x22
  80eeff:	68 bc 35 81 00       	push   $0x8135bc
  80ef04:	e8 d8 f4 ff ff       	call   80e3e1 <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80ef09:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef0c:	5b                   	pop    %ebx
  80ef0d:	5e                   	pop    %esi
  80ef0e:	5f                   	pop    %edi
  80ef0f:	5d                   	pop    %ebp
  80ef10:	c3                   	ret    

0080ef11 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80ef11:	55                   	push   %ebp
  80ef12:	89 e5                	mov    %esp,%ebp
  80ef14:	57                   	push   %edi
  80ef15:	56                   	push   %esi
  80ef16:	53                   	push   %ebx
  80ef17:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ef1a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef1f:	b8 08 00 00 00       	mov    $0x8,%eax
  80ef24:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef27:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef2a:	89 df                	mov    %ebx,%edi
  80ef2c:	89 de                	mov    %ebx,%esi
  80ef2e:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ef30:	85 c0                	test   %eax,%eax
  80ef32:	7e 17                	jle    80ef4b <sys_env_set_status+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef34:	83 ec 0c             	sub    $0xc,%esp
  80ef37:	50                   	push   %eax
  80ef38:	6a 08                	push   $0x8
  80ef3a:	68 9f 35 81 00       	push   $0x81359f
  80ef3f:	6a 22                	push   $0x22
  80ef41:	68 bc 35 81 00       	push   $0x8135bc
  80ef46:	e8 96 f4 ff ff       	call   80e3e1 <_panic>
sys_env_set_status(envid_t envid, int status)
{

	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
             
}
  80ef4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef4e:	5b                   	pop    %ebx
  80ef4f:	5e                   	pop    %esi
  80ef50:	5f                   	pop    %edi
  80ef51:	5d                   	pop    %ebp
  80ef52:	c3                   	ret    

0080ef53 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80ef53:	55                   	push   %ebp
  80ef54:	89 e5                	mov    %esp,%ebp
  80ef56:	57                   	push   %edi
  80ef57:	56                   	push   %esi
  80ef58:	53                   	push   %ebx
  80ef59:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ef5c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef61:	b8 09 00 00 00       	mov    $0x9,%eax
  80ef66:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef69:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef6c:	89 df                	mov    %ebx,%edi
  80ef6e:	89 de                	mov    %ebx,%esi
  80ef70:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ef72:	85 c0                	test   %eax,%eax
  80ef74:	7e 17                	jle    80ef8d <sys_env_set_trapframe+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef76:	83 ec 0c             	sub    $0xc,%esp
  80ef79:	50                   	push   %eax
  80ef7a:	6a 09                	push   $0x9
  80ef7c:	68 9f 35 81 00       	push   $0x81359f
  80ef81:	6a 22                	push   $0x22
  80ef83:	68 bc 35 81 00       	push   $0x8135bc
  80ef88:	e8 54 f4 ff ff       	call   80e3e1 <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80ef8d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef90:	5b                   	pop    %ebx
  80ef91:	5e                   	pop    %esi
  80ef92:	5f                   	pop    %edi
  80ef93:	5d                   	pop    %ebp
  80ef94:	c3                   	ret    

0080ef95 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80ef95:	55                   	push   %ebp
  80ef96:	89 e5                	mov    %esp,%ebp
  80ef98:	57                   	push   %edi
  80ef99:	56                   	push   %esi
  80ef9a:	53                   	push   %ebx
  80ef9b:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80ef9e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80efa3:	b8 0a 00 00 00       	mov    $0xa,%eax
  80efa8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80efab:	8b 55 08             	mov    0x8(%ebp),%edx
  80efae:	89 df                	mov    %ebx,%edi
  80efb0:	89 de                	mov    %ebx,%esi
  80efb2:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80efb4:	85 c0                	test   %eax,%eax
  80efb6:	7e 17                	jle    80efcf <sys_env_set_pgfault_upcall+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80efb8:	83 ec 0c             	sub    $0xc,%esp
  80efbb:	50                   	push   %eax
  80efbc:	6a 0a                	push   $0xa
  80efbe:	68 9f 35 81 00       	push   $0x81359f
  80efc3:	6a 22                	push   $0x22
  80efc5:	68 bc 35 81 00       	push   $0x8135bc
  80efca:	e8 12 f4 ff ff       	call   80e3e1 <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80efcf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efd2:	5b                   	pop    %ebx
  80efd3:	5e                   	pop    %esi
  80efd4:	5f                   	pop    %edi
  80efd5:	5d                   	pop    %ebp
  80efd6:	c3                   	ret    

0080efd7 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80efd7:	55                   	push   %ebp
  80efd8:	89 e5                	mov    %esp,%ebp
  80efda:	57                   	push   %edi
  80efdb:	56                   	push   %esi
  80efdc:	53                   	push   %ebx
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80efdd:	be 00 00 00 00       	mov    $0x0,%esi
  80efe2:	b8 0c 00 00 00       	mov    $0xc,%eax
  80efe7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80efea:	8b 55 08             	mov    0x8(%ebp),%edx
  80efed:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80eff0:	8b 7d 14             	mov    0x14(%ebp),%edi
  80eff3:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80eff5:	5b                   	pop    %ebx
  80eff6:	5e                   	pop    %esi
  80eff7:	5f                   	pop    %edi
  80eff8:	5d                   	pop    %ebp
  80eff9:	c3                   	ret    

0080effa <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{  
  80effa:	55                   	push   %ebp
  80effb:	89 e5                	mov    %esp,%ebp
  80effd:	57                   	push   %edi
  80effe:	56                   	push   %esi
  80efff:	53                   	push   %ebx
  80f000:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80f003:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f008:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f00d:	8b 55 08             	mov    0x8(%ebp),%edx
  80f010:	89 cb                	mov    %ecx,%ebx
  80f012:	89 cf                	mov    %ecx,%edi
  80f014:	89 ce                	mov    %ecx,%esi
  80f016:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f018:	85 c0                	test   %eax,%eax
  80f01a:	7e 17                	jle    80f033 <sys_ipc_recv+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f01c:	83 ec 0c             	sub    $0xc,%esp
  80f01f:	50                   	push   %eax
  80f020:	6a 0d                	push   $0xd
  80f022:	68 9f 35 81 00       	push   $0x81359f
  80f027:	6a 22                	push   $0x22
  80f029:	68 bc 35 81 00       	push   $0x8135bc
  80f02e:	e8 ae f3 ff ff       	call   80e3e1 <_panic>

int
sys_ipc_recv(void *dstva)
{  
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f033:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f036:	5b                   	pop    %ebx
  80f037:	5e                   	pop    %esi
  80f038:	5f                   	pop    %edi
  80f039:	5d                   	pop    %ebp
  80f03a:	c3                   	ret    

0080f03b <sys_time_msec>:

unsigned int
sys_time_msec(void)
{       
  80f03b:	55                   	push   %ebp
  80f03c:	89 e5                	mov    %esp,%ebp
  80f03e:	57                   	push   %edi
  80f03f:	56                   	push   %esi
  80f040:	53                   	push   %ebx
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80f041:	ba 00 00 00 00       	mov    $0x0,%edx
  80f046:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f04b:	89 d1                	mov    %edx,%ecx
  80f04d:	89 d3                	mov    %edx,%ebx
  80f04f:	89 d7                	mov    %edx,%edi
  80f051:	89 d6                	mov    %edx,%esi
  80f053:	cd 30                	int    $0x30
sys_time_msec(void)
{       
         
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
        
}
  80f055:	5b                   	pop    %ebx
  80f056:	5e                   	pop    %esi
  80f057:	5f                   	pop    %edi
  80f058:	5d                   	pop    %ebp
  80f059:	c3                   	ret    

0080f05a <sys_transmit>:

int
sys_transmit(void *addr)
{
  80f05a:	55                   	push   %ebp
  80f05b:	89 e5                	mov    %esp,%ebp
  80f05d:	57                   	push   %edi
  80f05e:	56                   	push   %esi
  80f05f:	53                   	push   %ebx
  80f060:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80f063:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f068:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f06d:	8b 55 08             	mov    0x8(%ebp),%edx
  80f070:	89 cb                	mov    %ecx,%ebx
  80f072:	89 cf                	mov    %ecx,%edi
  80f074:	89 ce                	mov    %ecx,%esi
  80f076:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f078:	85 c0                	test   %eax,%eax
  80f07a:	7e 17                	jle    80f093 <sys_transmit+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f07c:	83 ec 0c             	sub    $0xc,%esp
  80f07f:	50                   	push   %eax
  80f080:	6a 0f                	push   $0xf
  80f082:	68 9f 35 81 00       	push   $0x81359f
  80f087:	6a 22                	push   $0x22
  80f089:	68 bc 35 81 00       	push   $0x8135bc
  80f08e:	e8 4e f3 ff ff       	call   80e3e1 <_panic>

int
sys_transmit(void *addr)
{
        return syscall(SYS_transmit, 1, (uint32_t)addr, 0, 0, 0, 0);
}
  80f093:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f096:	5b                   	pop    %ebx
  80f097:	5e                   	pop    %esi
  80f098:	5f                   	pop    %edi
  80f099:	5d                   	pop    %ebp
  80f09a:	c3                   	ret    

0080f09b <sys_recv>:

int
sys_recv(void *addr)
{
  80f09b:	55                   	push   %ebp
  80f09c:	89 e5                	mov    %esp,%ebp
  80f09e:	57                   	push   %edi
  80f09f:	56                   	push   %esi
  80f0a0:	53                   	push   %ebx
  80f0a1:	83 ec 0c             	sub    $0xc,%esp
	// return value.
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.
	asm volatile("int %1\n"
  80f0a4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f0a9:	b8 10 00 00 00       	mov    $0x10,%eax
  80f0ae:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0b1:	89 cb                	mov    %ecx,%ebx
  80f0b3:	89 cf                	mov    %ecx,%edi
  80f0b5:	89 ce                	mov    %ecx,%esi
  80f0b7:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80f0b9:	85 c0                	test   %eax,%eax
  80f0bb:	7e 17                	jle    80f0d4 <sys_recv+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80f0bd:	83 ec 0c             	sub    $0xc,%esp
  80f0c0:	50                   	push   %eax
  80f0c1:	6a 10                	push   $0x10
  80f0c3:	68 9f 35 81 00       	push   $0x81359f
  80f0c8:	6a 22                	push   $0x22
  80f0ca:	68 bc 35 81 00       	push   $0x8135bc
  80f0cf:	e8 0d f3 ff ff       	call   80e3e1 <_panic>

int
sys_recv(void *addr)
{
        return syscall(SYS_recv, 1, (uint32_t)addr, 0, 0, 0, 0);
}
  80f0d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f0d7:	5b                   	pop    %ebx
  80f0d8:	5e                   	pop    %esi
  80f0d9:	5f                   	pop    %edi
  80f0da:	5d                   	pop    %ebp
  80f0db:	c3                   	ret    

0080f0dc <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f0dc:	55                   	push   %ebp
  80f0dd:	89 e5                	mov    %esp,%ebp
  80f0df:	53                   	push   %ebx
  80f0e0:	83 ec 04             	sub    $0x4,%esp
  80f0e3:	8b 55 08             	mov    0x8(%ebp),%edx
	void *addr = (void *) utf->utf_fault_va;
  80f0e6:	8b 02                	mov    (%edx),%eax
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
        if(!(
  80f0e8:	f6 42 04 02          	testb  $0x2,0x4(%edx)
  80f0ec:	74 2e                	je     80f11c <pgfault+0x40>
             ((err & FEC_WR) == FEC_WR) && (uvpd[PDX(addr)] & PTE_P) && 
  80f0ee:	89 c2                	mov    %eax,%edx
  80f0f0:	c1 ea 16             	shr    $0x16,%edx
  80f0f3:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f0fa:	f6 c2 01             	test   $0x1,%dl
  80f0fd:	74 1d                	je     80f11c <pgfault+0x40>
             (uvpt[PGNUM(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_COW)
  80f0ff:	89 c2                	mov    %eax,%edx
  80f101:	c1 ea 0c             	shr    $0xc,%edx
  80f104:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
        if(!(
             ((err & FEC_WR) == FEC_WR) && (uvpd[PDX(addr)] & PTE_P) && 
  80f10b:	f6 c1 01             	test   $0x1,%cl
  80f10e:	74 0c                	je     80f11c <pgfault+0x40>
             (uvpt[PGNUM(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_COW)
  80f110:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
        if(!(
  80f117:	f6 c6 08             	test   $0x8,%dh
  80f11a:	75 14                	jne    80f130 <pgfault+0x54>
             ((err & FEC_WR) == FEC_WR) && (uvpd[PDX(addr)] & PTE_P) && 
             (uvpt[PGNUM(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_COW)
            )
           )
                panic("err isn't caused by write or cow\n"); 
  80f11c:	83 ec 04             	sub    $0x4,%esp
  80f11f:	68 cc 35 81 00       	push   $0x8135cc
  80f124:	6a 21                	push   $0x21
  80f126:	68 5f 36 81 00       	push   $0x81365f
  80f12b:	e8 b1 f2 ff ff       	call   80e3e1 <_panic>
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.

	// LAB 4: Your code here.
        void *radd = ROUNDDOWN(addr, PGSIZE);
  80f130:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f135:	89 c3                	mov    %eax,%ebx
        if(sys_page_alloc(0, PFTEMP, PTE_U | PTE_W | PTE_P) < 0)
  80f137:	83 ec 04             	sub    $0x4,%esp
  80f13a:	6a 07                	push   $0x7
  80f13c:	68 00 f0 7f 00       	push   $0x7ff000
  80f141:	6a 00                	push   $0x0
  80f143:	e8 02 fd ff ff       	call   80ee4a <sys_page_alloc>
  80f148:	83 c4 10             	add    $0x10,%esp
  80f14b:	85 c0                	test   %eax,%eax
  80f14d:	79 14                	jns    80f163 <pgfault+0x87>
                panic("sys_page_alloc fails\n");
  80f14f:	83 ec 04             	sub    $0x4,%esp
  80f152:	68 6a 36 81 00       	push   $0x81366a
  80f157:	6a 2b                	push   $0x2b
  80f159:	68 5f 36 81 00       	push   $0x81365f
  80f15e:	e8 7e f2 ff ff       	call   80e3e1 <_panic>
        memmove(PFTEMP, radd, PGSIZE);
  80f163:	83 ec 04             	sub    $0x4,%esp
  80f166:	68 00 10 00 00       	push   $0x1000
  80f16b:	53                   	push   %ebx
  80f16c:	68 00 f0 7f 00       	push   $0x7ff000
  80f171:	e8 5d fa ff ff       	call   80ebd3 <memmove>
        if(sys_page_map(0, PFTEMP, 0, radd, PTE_U | PTE_W | PTE_P) < 0)
  80f176:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f17d:	53                   	push   %ebx
  80f17e:	6a 00                	push   $0x0
  80f180:	68 00 f0 7f 00       	push   $0x7ff000
  80f185:	6a 00                	push   $0x0
  80f187:	e8 01 fd ff ff       	call   80ee8d <sys_page_map>
  80f18c:	83 c4 20             	add    $0x20,%esp
  80f18f:	85 c0                	test   %eax,%eax
  80f191:	79 14                	jns    80f1a7 <pgfault+0xcb>
                panic("sys_page_map fails\n");
  80f193:	83 ec 04             	sub    $0x4,%esp
  80f196:	68 80 36 81 00       	push   $0x813680
  80f19b:	6a 2e                	push   $0x2e
  80f19d:	68 5f 36 81 00       	push   $0x81365f
  80f1a2:	e8 3a f2 ff ff       	call   80e3e1 <_panic>
        sys_page_unmap(0, PFTEMP); 
  80f1a7:	83 ec 08             	sub    $0x8,%esp
  80f1aa:	68 00 f0 7f 00       	push   $0x7ff000
  80f1af:	6a 00                	push   $0x0
  80f1b1:	e8 19 fd ff ff       	call   80eecf <sys_page_unmap>
  80f1b6:	83 c4 10             	add    $0x10,%esp
               
	//panic("pgfault not implemented");
}
  80f1b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f1bc:	c9                   	leave  
  80f1bd:	c3                   	ret    

0080f1be <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f1be:	55                   	push   %ebp
  80f1bf:	89 e5                	mov    %esp,%ebp
  80f1c1:	57                   	push   %edi
  80f1c2:	56                   	push   %esi
  80f1c3:	53                   	push   %ebx
  80f1c4:	83 ec 28             	sub    $0x28,%esp
	// LAB 4: Your code here.
	//panic("fork not implemented");
        void *addr;
        set_pgfault_handler(pgfault);
  80f1c7:	68 dc f0 80 00       	push   $0x80f0dc
  80f1cc:	e8 f4 16 00 00       	call   8108c5 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  80f1d1:	b8 07 00 00 00       	mov    $0x7,%eax
  80f1d6:	cd 30                	int    $0x30
  80f1d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        envid_t forkid = sys_exofork();
        if (forkid < 0)
  80f1db:	83 c4 10             	add    $0x10,%esp
  80f1de:	85 c0                	test   %eax,%eax
  80f1e0:	79 12                	jns    80f1f4 <fork+0x36>
		panic("sys_exofork: %e", forkid);
  80f1e2:	50                   	push   %eax
  80f1e3:	68 94 36 81 00       	push   $0x813694
  80f1e8:	6a 6d                	push   $0x6d
  80f1ea:	68 5f 36 81 00       	push   $0x81365f
  80f1ef:	e8 ed f1 ff ff       	call   80e3e1 <_panic>
  80f1f4:	89 c7                	mov    %eax,%edi
  80f1f6:	bb 00 00 80 00       	mov    $0x800000,%ebx
        if(forkid == 0) {
  80f1fb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f1ff:	75 21                	jne    80f222 <fork+0x64>
                thisenv = &envs[ENVX(sys_getenvid())];
  80f201:	e8 06 fc ff ff       	call   80ee0c <sys_getenvid>
  80f206:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f20b:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f20e:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f213:	a3 9c b3 b3 00       	mov    %eax,0xb3b39c
		return 0;
  80f218:	b8 00 00 00 00       	mov    $0x0,%eax
  80f21d:	e9 9c 01 00 00       	jmp    80f3be <fork+0x200>
        }
        for (addr = (uint8_t*) UTEXT; addr < (void *) USTACKTOP; addr += PGSIZE)
		if( (uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P) )
  80f222:	89 d8                	mov    %ebx,%eax
  80f224:	c1 e8 16             	shr    $0x16,%eax
  80f227:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f22e:	a8 01                	test   $0x1,%al
  80f230:	0f 84 f3 00 00 00    	je     80f329 <fork+0x16b>
  80f236:	89 d8                	mov    %ebx,%eax
  80f238:	c1 e8 0c             	shr    $0xc,%eax
  80f23b:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f242:	f6 c2 01             	test   $0x1,%dl
  80f245:	0f 84 de 00 00 00    	je     80f329 <fork+0x16b>
{
	int r;

	// LAB 4: Your code here.
	//panic("duppage not implemented");
        void *add = (void *)(pn * PGSIZE);
  80f24b:	89 c6                	mov    %eax,%esi
  80f24d:	c1 e6 0c             	shl    $0xc,%esi
        if(uvpt[pn] & PTE_SHARE) {
  80f250:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f257:	f6 c6 04             	test   $0x4,%dh
  80f25a:	74 37                	je     80f293 <fork+0xd5>
                 if((r = sys_page_map(0, add, envid, add, uvpt[pn]&PTE_SYSCALL)) < 0)
  80f25c:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f263:	83 ec 0c             	sub    $0xc,%esp
  80f266:	25 07 0e 00 00       	and    $0xe07,%eax
  80f26b:	50                   	push   %eax
  80f26c:	56                   	push   %esi
  80f26d:	57                   	push   %edi
  80f26e:	56                   	push   %esi
  80f26f:	6a 00                	push   $0x0
  80f271:	e8 17 fc ff ff       	call   80ee8d <sys_page_map>
  80f276:	83 c4 20             	add    $0x20,%esp
  80f279:	85 c0                	test   %eax,%eax
  80f27b:	0f 89 a8 00 00 00    	jns    80f329 <fork+0x16b>
                        panic("sys_page_map on new page fails %e \n", r);
  80f281:	50                   	push   %eax
  80f282:	68 f0 35 81 00       	push   $0x8135f0
  80f287:	6a 49                	push   $0x49
  80f289:	68 5f 36 81 00       	push   $0x81365f
  80f28e:	e8 4e f1 ff ff       	call   80e3e1 <_panic>
        } else if( (uvpt[pn] & PTE_COW) || (uvpt[pn] & PTE_W)) {
  80f293:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f29a:	f6 c6 08             	test   $0x8,%dh
  80f29d:	75 0b                	jne    80f2aa <fork+0xec>
  80f29f:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f2a6:	a8 02                	test   $0x2,%al
  80f2a8:	74 57                	je     80f301 <fork+0x143>
                if((r = sys_page_map(0, add, envid, add, PTE_COW | PTE_P | PTE_U)) < 0)
  80f2aa:	83 ec 0c             	sub    $0xc,%esp
  80f2ad:	68 05 08 00 00       	push   $0x805
  80f2b2:	56                   	push   %esi
  80f2b3:	57                   	push   %edi
  80f2b4:	56                   	push   %esi
  80f2b5:	6a 00                	push   $0x0
  80f2b7:	e8 d1 fb ff ff       	call   80ee8d <sys_page_map>
  80f2bc:	83 c4 20             	add    $0x20,%esp
  80f2bf:	85 c0                	test   %eax,%eax
  80f2c1:	79 12                	jns    80f2d5 <fork+0x117>
                        panic("sys_page_map on new page fails %e \n", r);
  80f2c3:	50                   	push   %eax
  80f2c4:	68 f0 35 81 00       	push   $0x8135f0
  80f2c9:	6a 4c                	push   $0x4c
  80f2cb:	68 5f 36 81 00       	push   $0x81365f
  80f2d0:	e8 0c f1 ff ff       	call   80e3e1 <_panic>
                if((r = sys_page_map(0, add, 0, add, PTE_COW | PTE_P | PTE_U)) < 0)
  80f2d5:	83 ec 0c             	sub    $0xc,%esp
  80f2d8:	68 05 08 00 00       	push   $0x805
  80f2dd:	56                   	push   %esi
  80f2de:	6a 00                	push   $0x0
  80f2e0:	56                   	push   %esi
  80f2e1:	6a 00                	push   $0x0
  80f2e3:	e8 a5 fb ff ff       	call   80ee8d <sys_page_map>
  80f2e8:	83 c4 20             	add    $0x20,%esp
  80f2eb:	85 c0                	test   %eax,%eax
  80f2ed:	79 3a                	jns    80f329 <fork+0x16b>
                        panic("sys_page_map on current page fails %e\n", r);
  80f2ef:	50                   	push   %eax
  80f2f0:	68 14 36 81 00       	push   $0x813614
  80f2f5:	6a 4e                	push   $0x4e
  80f2f7:	68 5f 36 81 00       	push   $0x81365f
  80f2fc:	e8 e0 f0 ff ff       	call   80e3e1 <_panic>
        } else if((r = sys_page_map(0, add, envid, add, PTE_P | PTE_U)) < 0)
  80f301:	83 ec 0c             	sub    $0xc,%esp
  80f304:	6a 05                	push   $0x5
  80f306:	56                   	push   %esi
  80f307:	57                   	push   %edi
  80f308:	56                   	push   %esi
  80f309:	6a 00                	push   $0x0
  80f30b:	e8 7d fb ff ff       	call   80ee8d <sys_page_map>
  80f310:	83 c4 20             	add    $0x20,%esp
  80f313:	85 c0                	test   %eax,%eax
  80f315:	79 12                	jns    80f329 <fork+0x16b>
                        panic("sys_page_map on new page fails %e\n", r);
  80f317:	50                   	push   %eax
  80f318:	68 3c 36 81 00       	push   $0x81363c
  80f31d:	6a 50                	push   $0x50
  80f31f:	68 5f 36 81 00       	push   $0x81365f
  80f324:	e8 b8 f0 ff ff       	call   80e3e1 <_panic>
		panic("sys_exofork: %e", forkid);
        if(forkid == 0) {
                thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
        }
        for (addr = (uint8_t*) UTEXT; addr < (void *) USTACKTOP; addr += PGSIZE)
  80f329:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f32f:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f335:	0f 85 e7 fe ff ff    	jne    80f222 <fork+0x64>
		if( (uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P) )
                        duppage(forkid, PGNUM(addr));
        if (sys_page_alloc(forkid, (void *)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P) < 0)
  80f33b:	83 ec 04             	sub    $0x4,%esp
  80f33e:	6a 07                	push   $0x7
  80f340:	68 00 f0 bf ee       	push   $0xeebff000
  80f345:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f348:	e8 fd fa ff ff       	call   80ee4a <sys_page_alloc>
  80f34d:	83 c4 10             	add    $0x10,%esp
  80f350:	85 c0                	test   %eax,%eax
  80f352:	79 14                	jns    80f368 <fork+0x1aa>
                panic("user stack alloc failure\n");	
  80f354:	83 ec 04             	sub    $0x4,%esp
  80f357:	68 a4 36 81 00       	push   $0x8136a4
  80f35c:	6a 76                	push   $0x76
  80f35e:	68 5f 36 81 00       	push   $0x81365f
  80f363:	e8 79 f0 ff ff       	call   80e3e1 <_panic>
        extern void _pgfault_upcall(); 
        if(sys_env_set_pgfault_upcall(forkid, _pgfault_upcall) < 0)
  80f368:	83 ec 08             	sub    $0x8,%esp
  80f36b:	68 34 09 81 00       	push   $0x810934
  80f370:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f373:	e8 1d fc ff ff       	call   80ef95 <sys_env_set_pgfault_upcall>
  80f378:	83 c4 10             	add    $0x10,%esp
  80f37b:	85 c0                	test   %eax,%eax
  80f37d:	79 14                	jns    80f393 <fork+0x1d5>
                panic("set pgfault upcall fails %d\n", forkid);
  80f37f:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f382:	68 be 36 81 00       	push   $0x8136be
  80f387:	6a 79                	push   $0x79
  80f389:	68 5f 36 81 00       	push   $0x81365f
  80f38e:	e8 4e f0 ff ff       	call   80e3e1 <_panic>
        if(sys_env_set_status(forkid, ENV_RUNNABLE) < 0)
  80f393:	83 ec 08             	sub    $0x8,%esp
  80f396:	6a 02                	push   $0x2
  80f398:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f39b:	e8 71 fb ff ff       	call   80ef11 <sys_env_set_status>
  80f3a0:	83 c4 10             	add    $0x10,%esp
  80f3a3:	85 c0                	test   %eax,%eax
  80f3a5:	79 14                	jns    80f3bb <fork+0x1fd>
                panic("set %d runnable fails\n", forkid);
  80f3a7:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f3aa:	68 db 36 81 00       	push   $0x8136db
  80f3af:	6a 7b                	push   $0x7b
  80f3b1:	68 5f 36 81 00       	push   $0x81365f
  80f3b6:	e8 26 f0 ff ff       	call   80e3e1 <_panic>
        return forkid;
  80f3bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
  80f3be:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3c1:	5b                   	pop    %ebx
  80f3c2:	5e                   	pop    %esi
  80f3c3:	5f                   	pop    %edi
  80f3c4:	5d                   	pop    %ebp
  80f3c5:	c3                   	ret    

0080f3c6 <sfork>:

// Challenge!
int
sfork(void)
{
  80f3c6:	55                   	push   %ebp
  80f3c7:	89 e5                	mov    %esp,%ebp
  80f3c9:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f3cc:	68 f2 36 81 00       	push   $0x8136f2
  80f3d1:	68 83 00 00 00       	push   $0x83
  80f3d6:	68 5f 36 81 00       	push   $0x81365f
  80f3db:	e8 01 f0 ff ff       	call   80e3e1 <_panic>

0080f3e0 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f3e0:	55                   	push   %ebp
  80f3e1:	89 e5                	mov    %esp,%ebp
  80f3e3:	56                   	push   %esi
  80f3e4:	53                   	push   %ebx
  80f3e5:	8b 75 08             	mov    0x8(%ebp),%esi
  80f3e8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f3eb:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	//panic("ipc_recv not implemented");
        if(!pg) pg = (void *)UTOP;
  80f3ee:	85 c0                	test   %eax,%eax
  80f3f0:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80f3f5:	0f 44 c2             	cmove  %edx,%eax
        int r;
        if((r = sys_ipc_recv(pg)) < 0) {
  80f3f8:	83 ec 0c             	sub    $0xc,%esp
  80f3fb:	50                   	push   %eax
  80f3fc:	e8 f9 fb ff ff       	call   80effa <sys_ipc_recv>
  80f401:	83 c4 10             	add    $0x10,%esp
  80f404:	85 c0                	test   %eax,%eax
  80f406:	79 16                	jns    80f41e <ipc_recv+0x3e>
                if(from_env_store) *from_env_store = 0;
  80f408:	85 f6                	test   %esi,%esi
  80f40a:	74 06                	je     80f412 <ipc_recv+0x32>
  80f40c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
                if(perm_store) *perm_store = 0;
  80f412:	85 db                	test   %ebx,%ebx
  80f414:	74 2c                	je     80f442 <ipc_recv+0x62>
  80f416:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80f41c:	eb 24                	jmp    80f442 <ipc_recv+0x62>
                return r;
        }
        if(from_env_store) *from_env_store = thisenv->env_ipc_from;
  80f41e:	85 f6                	test   %esi,%esi
  80f420:	74 0a                	je     80f42c <ipc_recv+0x4c>
  80f422:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
  80f427:	8b 40 74             	mov    0x74(%eax),%eax
  80f42a:	89 06                	mov    %eax,(%esi)
        if(perm_store) *perm_store = thisenv->env_ipc_perm;
  80f42c:	85 db                	test   %ebx,%ebx
  80f42e:	74 0a                	je     80f43a <ipc_recv+0x5a>
  80f430:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
  80f435:	8b 40 78             	mov    0x78(%eax),%eax
  80f438:	89 03                	mov    %eax,(%ebx)
         
	return thisenv->env_ipc_value;
  80f43a:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
  80f43f:	8b 40 70             	mov    0x70(%eax),%eax
}
  80f442:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f445:	5b                   	pop    %ebx
  80f446:	5e                   	pop    %esi
  80f447:	5d                   	pop    %ebp
  80f448:	c3                   	ret    

0080f449 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f449:	55                   	push   %ebp
  80f44a:	89 e5                	mov    %esp,%ebp
  80f44c:	57                   	push   %edi
  80f44d:	56                   	push   %esi
  80f44e:	53                   	push   %ebx
  80f44f:	83 ec 0c             	sub    $0xc,%esp
  80f452:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f455:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f458:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
        if(!pg) pg = (void *)UTOP;
  80f45b:	85 db                	test   %ebx,%ebx
  80f45d:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f462:	0f 44 d8             	cmove  %eax,%ebx
  80f465:	eb 1c                	jmp    80f483 <ipc_send+0x3a>
        int r;
        while((r = sys_ipc_try_send(to_env, val, pg, perm)) < 0) {
                 if(r != -E_IPC_NOT_RECV)
  80f467:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f46a:	74 12                	je     80f47e <ipc_send+0x35>
                         panic("sys_ipc_try_send fails %e\n", r);
  80f46c:	50                   	push   %eax
  80f46d:	68 08 37 81 00       	push   $0x813708
  80f472:	6a 39                	push   $0x39
  80f474:	68 23 37 81 00       	push   $0x813723
  80f479:	e8 63 ef ff ff       	call   80e3e1 <_panic>
                 sys_yield();
  80f47e:	e8 a8 f9 ff ff       	call   80ee2b <sys_yield>
{
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
        if(!pg) pg = (void *)UTOP;
        int r;
        while((r = sys_ipc_try_send(to_env, val, pg, perm)) < 0) {
  80f483:	ff 75 14             	pushl  0x14(%ebp)
  80f486:	53                   	push   %ebx
  80f487:	56                   	push   %esi
  80f488:	57                   	push   %edi
  80f489:	e8 49 fb ff ff       	call   80efd7 <sys_ipc_try_send>
  80f48e:	83 c4 10             	add    $0x10,%esp
  80f491:	85 c0                	test   %eax,%eax
  80f493:	78 d2                	js     80f467 <ipc_send+0x1e>
                 if(r != -E_IPC_NOT_RECV)
                         panic("sys_ipc_try_send fails %e\n", r);
                 sys_yield();
        }
                
}
  80f495:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f498:	5b                   	pop    %ebx
  80f499:	5e                   	pop    %esi
  80f49a:	5f                   	pop    %edi
  80f49b:	5d                   	pop    %ebp
  80f49c:	c3                   	ret    

0080f49d <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f49d:	55                   	push   %ebp
  80f49e:	89 e5                	mov    %esp,%ebp
  80f4a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f4a3:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f4a8:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f4ab:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f4b1:	8b 52 50             	mov    0x50(%edx),%edx
  80f4b4:	39 ca                	cmp    %ecx,%edx
  80f4b6:	75 0d                	jne    80f4c5 <ipc_find_env+0x28>
			return envs[i].env_id;
  80f4b8:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f4bb:	05 40 00 c0 ee       	add    $0xeec00040,%eax
  80f4c0:	8b 40 08             	mov    0x8(%eax),%eax
  80f4c3:	eb 0e                	jmp    80f4d3 <ipc_find_env+0x36>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  80f4c5:	83 c0 01             	add    $0x1,%eax
  80f4c8:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f4cd:	75 d9                	jne    80f4a8 <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  80f4cf:	66 b8 00 00          	mov    $0x0,%ax
}
  80f4d3:	5d                   	pop    %ebp
  80f4d4:	c3                   	ret    

0080f4d5 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f4d5:	55                   	push   %ebp
  80f4d6:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f4d8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f4db:	05 00 00 00 30       	add    $0x30000000,%eax
  80f4e0:	c1 e8 0c             	shr    $0xc,%eax
}
  80f4e3:	5d                   	pop    %ebp
  80f4e4:	c3                   	ret    

0080f4e5 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f4e5:	55                   	push   %ebp
  80f4e6:	89 e5                	mov    %esp,%ebp
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f4e8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f4eb:	05 00 00 00 30       	add    $0x30000000,%eax
}

char*
fd2data(struct Fd *fd)
{
	return INDEX2DATA(fd2num(fd));
  80f4f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f4f5:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f4fa:	5d                   	pop    %ebp
  80f4fb:	c3                   	ret    

0080f4fc <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f4fc:	55                   	push   %ebp
  80f4fd:	89 e5                	mov    %esp,%ebp
  80f4ff:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f502:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f507:	89 c2                	mov    %eax,%edx
  80f509:	c1 ea 16             	shr    $0x16,%edx
  80f50c:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f513:	f6 c2 01             	test   $0x1,%dl
  80f516:	74 11                	je     80f529 <fd_alloc+0x2d>
  80f518:	89 c2                	mov    %eax,%edx
  80f51a:	c1 ea 0c             	shr    $0xc,%edx
  80f51d:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f524:	f6 c2 01             	test   $0x1,%dl
  80f527:	75 09                	jne    80f532 <fd_alloc+0x36>
			*fd_store = fd;
  80f529:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f52b:	b8 00 00 00 00       	mov    $0x0,%eax
  80f530:	eb 17                	jmp    80f549 <fd_alloc+0x4d>
  80f532:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  80f537:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f53c:	75 c9                	jne    80f507 <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80f53e:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  80f544:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  80f549:	5d                   	pop    %ebp
  80f54a:	c3                   	ret    

0080f54b <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f54b:	55                   	push   %ebp
  80f54c:	89 e5                	mov    %esp,%ebp
  80f54e:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f551:	83 f8 1f             	cmp    $0x1f,%eax
  80f554:	77 36                	ja     80f58c <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f556:	c1 e0 0c             	shl    $0xc,%eax
  80f559:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f55e:	89 c2                	mov    %eax,%edx
  80f560:	c1 ea 16             	shr    $0x16,%edx
  80f563:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f56a:	f6 c2 01             	test   $0x1,%dl
  80f56d:	74 24                	je     80f593 <fd_lookup+0x48>
  80f56f:	89 c2                	mov    %eax,%edx
  80f571:	c1 ea 0c             	shr    $0xc,%edx
  80f574:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f57b:	f6 c2 01             	test   $0x1,%dl
  80f57e:	74 1a                	je     80f59a <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f580:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f583:	89 02                	mov    %eax,(%edx)
	return 0;
  80f585:	b8 00 00 00 00       	mov    $0x0,%eax
  80f58a:	eb 13                	jmp    80f59f <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f58c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f591:	eb 0c                	jmp    80f59f <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f593:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f598:	eb 05                	jmp    80f59f <fd_lookup+0x54>
  80f59a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  80f59f:	5d                   	pop    %ebp
  80f5a0:	c3                   	ret    

0080f5a1 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f5a1:	55                   	push   %ebp
  80f5a2:	89 e5                	mov    %esp,%ebp
  80f5a4:	83 ec 08             	sub    $0x8,%esp
  80f5a7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80f5aa:	ba 00 00 00 00       	mov    $0x0,%edx
  80f5af:	eb 13                	jmp    80f5c4 <dev_lookup+0x23>
		if (devtab[i]->dev_id == dev_id) {
  80f5b1:	39 08                	cmp    %ecx,(%eax)
  80f5b3:	75 0c                	jne    80f5c1 <dev_lookup+0x20>
			*dev = devtab[i];
  80f5b5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5b8:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f5ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80f5bf:	eb 36                	jmp    80f5f7 <dev_lookup+0x56>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  80f5c1:	83 c2 01             	add    $0x1,%edx
  80f5c4:	8b 04 95 ac 37 81 00 	mov    0x8137ac(,%edx,4),%eax
  80f5cb:	85 c0                	test   %eax,%eax
  80f5cd:	75 e2                	jne    80f5b1 <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f5cf:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
  80f5d4:	8b 40 48             	mov    0x48(%eax),%eax
  80f5d7:	83 ec 04             	sub    $0x4,%esp
  80f5da:	51                   	push   %ecx
  80f5db:	50                   	push   %eax
  80f5dc:	68 30 37 81 00       	push   $0x813730
  80f5e1:	e8 d4 ee ff ff       	call   80e4ba <cprintf>
	*dev = 0;
  80f5e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f5e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80f5ef:	83 c4 10             	add    $0x10,%esp
  80f5f2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80f5f7:	c9                   	leave  
  80f5f8:	c3                   	ret    

0080f5f9 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80f5f9:	55                   	push   %ebp
  80f5fa:	89 e5                	mov    %esp,%ebp
  80f5fc:	56                   	push   %esi
  80f5fd:	53                   	push   %ebx
  80f5fe:	83 ec 10             	sub    $0x10,%esp
  80f601:	8b 75 08             	mov    0x8(%ebp),%esi
  80f604:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f607:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f60a:	50                   	push   %eax
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f60b:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f611:	c1 e8 0c             	shr    $0xc,%eax
fd_close(struct Fd *fd, bool must_exist)
{
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f614:	50                   	push   %eax
  80f615:	e8 31 ff ff ff       	call   80f54b <fd_lookup>
  80f61a:	83 c4 08             	add    $0x8,%esp
  80f61d:	85 c0                	test   %eax,%eax
  80f61f:	78 05                	js     80f626 <fd_close+0x2d>
	    || fd != fd2)
  80f621:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80f624:	74 0c                	je     80f632 <fd_close+0x39>
		return (must_exist ? r : 0);
  80f626:	84 db                	test   %bl,%bl
  80f628:	ba 00 00 00 00       	mov    $0x0,%edx
  80f62d:	0f 44 c2             	cmove  %edx,%eax
  80f630:	eb 41                	jmp    80f673 <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f632:	83 ec 08             	sub    $0x8,%esp
  80f635:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f638:	50                   	push   %eax
  80f639:	ff 36                	pushl  (%esi)
  80f63b:	e8 61 ff ff ff       	call   80f5a1 <dev_lookup>
  80f640:	89 c3                	mov    %eax,%ebx
  80f642:	83 c4 10             	add    $0x10,%esp
  80f645:	85 c0                	test   %eax,%eax
  80f647:	78 1a                	js     80f663 <fd_close+0x6a>
		if (dev->dev_close)
  80f649:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f64c:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  80f64f:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  80f654:	85 c0                	test   %eax,%eax
  80f656:	74 0b                	je     80f663 <fd_close+0x6a>
			r = (*dev->dev_close)(fd);
  80f658:	83 ec 0c             	sub    $0xc,%esp
  80f65b:	56                   	push   %esi
  80f65c:	ff d0                	call   *%eax
  80f65e:	89 c3                	mov    %eax,%ebx
  80f660:	83 c4 10             	add    $0x10,%esp
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80f663:	83 ec 08             	sub    $0x8,%esp
  80f666:	56                   	push   %esi
  80f667:	6a 00                	push   $0x0
  80f669:	e8 61 f8 ff ff       	call   80eecf <sys_page_unmap>
	return r;
  80f66e:	83 c4 10             	add    $0x10,%esp
  80f671:	89 d8                	mov    %ebx,%eax
}
  80f673:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f676:	5b                   	pop    %ebx
  80f677:	5e                   	pop    %esi
  80f678:	5d                   	pop    %ebp
  80f679:	c3                   	ret    

0080f67a <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80f67a:	55                   	push   %ebp
  80f67b:	89 e5                	mov    %esp,%ebp
  80f67d:	83 ec 18             	sub    $0x18,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f680:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f683:	50                   	push   %eax
  80f684:	ff 75 08             	pushl  0x8(%ebp)
  80f687:	e8 bf fe ff ff       	call   80f54b <fd_lookup>
  80f68c:	89 c2                	mov    %eax,%edx
  80f68e:	83 c4 08             	add    $0x8,%esp
  80f691:	85 d2                	test   %edx,%edx
  80f693:	78 10                	js     80f6a5 <close+0x2b>
		return r;
	else
		return fd_close(fd, 1);
  80f695:	83 ec 08             	sub    $0x8,%esp
  80f698:	6a 01                	push   $0x1
  80f69a:	ff 75 f4             	pushl  -0xc(%ebp)
  80f69d:	e8 57 ff ff ff       	call   80f5f9 <fd_close>
  80f6a2:	83 c4 10             	add    $0x10,%esp
}
  80f6a5:	c9                   	leave  
  80f6a6:	c3                   	ret    

0080f6a7 <close_all>:

void
close_all(void)
{
  80f6a7:	55                   	push   %ebp
  80f6a8:	89 e5                	mov    %esp,%ebp
  80f6aa:	53                   	push   %ebx
  80f6ab:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f6ae:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f6b3:	83 ec 0c             	sub    $0xc,%esp
  80f6b6:	53                   	push   %ebx
  80f6b7:	e8 be ff ff ff       	call   80f67a <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80f6bc:	83 c3 01             	add    $0x1,%ebx
  80f6bf:	83 c4 10             	add    $0x10,%esp
  80f6c2:	83 fb 20             	cmp    $0x20,%ebx
  80f6c5:	75 ec                	jne    80f6b3 <close_all+0xc>
		close(i);
}
  80f6c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f6ca:	c9                   	leave  
  80f6cb:	c3                   	ret    

0080f6cc <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f6cc:	55                   	push   %ebp
  80f6cd:	89 e5                	mov    %esp,%ebp
  80f6cf:	57                   	push   %edi
  80f6d0:	56                   	push   %esi
  80f6d1:	53                   	push   %ebx
  80f6d2:	83 ec 2c             	sub    $0x2c,%esp
  80f6d5:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f6d8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f6db:	50                   	push   %eax
  80f6dc:	ff 75 08             	pushl  0x8(%ebp)
  80f6df:	e8 67 fe ff ff       	call   80f54b <fd_lookup>
  80f6e4:	89 c2                	mov    %eax,%edx
  80f6e6:	83 c4 08             	add    $0x8,%esp
  80f6e9:	85 d2                	test   %edx,%edx
  80f6eb:	0f 88 c1 00 00 00    	js     80f7b2 <dup+0xe6>
		return r;
	close(newfdnum);
  80f6f1:	83 ec 0c             	sub    $0xc,%esp
  80f6f4:	56                   	push   %esi
  80f6f5:	e8 80 ff ff ff       	call   80f67a <close>

	newfd = INDEX2FD(newfdnum);
  80f6fa:	89 f3                	mov    %esi,%ebx
  80f6fc:	c1 e3 0c             	shl    $0xc,%ebx
  80f6ff:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  80f705:	83 c4 04             	add    $0x4,%esp
  80f708:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f70b:	e8 d5 fd ff ff       	call   80f4e5 <fd2data>
  80f710:	89 c7                	mov    %eax,%edi
	nva = fd2data(newfd);
  80f712:	89 1c 24             	mov    %ebx,(%esp)
  80f715:	e8 cb fd ff ff       	call   80f4e5 <fd2data>
  80f71a:	83 c4 10             	add    $0x10,%esp
  80f71d:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80f720:	89 f8                	mov    %edi,%eax
  80f722:	c1 e8 16             	shr    $0x16,%eax
  80f725:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f72c:	a8 01                	test   $0x1,%al
  80f72e:	74 37                	je     80f767 <dup+0x9b>
  80f730:	89 f8                	mov    %edi,%eax
  80f732:	c1 e8 0c             	shr    $0xc,%eax
  80f735:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f73c:	f6 c2 01             	test   $0x1,%dl
  80f73f:	74 26                	je     80f767 <dup+0x9b>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80f741:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f748:	83 ec 0c             	sub    $0xc,%esp
  80f74b:	25 07 0e 00 00       	and    $0xe07,%eax
  80f750:	50                   	push   %eax
  80f751:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f754:	6a 00                	push   $0x0
  80f756:	57                   	push   %edi
  80f757:	6a 00                	push   $0x0
  80f759:	e8 2f f7 ff ff       	call   80ee8d <sys_page_map>
  80f75e:	89 c7                	mov    %eax,%edi
  80f760:	83 c4 20             	add    $0x20,%esp
  80f763:	85 c0                	test   %eax,%eax
  80f765:	78 2e                	js     80f795 <dup+0xc9>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f767:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f76a:	89 d0                	mov    %edx,%eax
  80f76c:	c1 e8 0c             	shr    $0xc,%eax
  80f76f:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f776:	83 ec 0c             	sub    $0xc,%esp
  80f779:	25 07 0e 00 00       	and    $0xe07,%eax
  80f77e:	50                   	push   %eax
  80f77f:	53                   	push   %ebx
  80f780:	6a 00                	push   $0x0
  80f782:	52                   	push   %edx
  80f783:	6a 00                	push   $0x0
  80f785:	e8 03 f7 ff ff       	call   80ee8d <sys_page_map>
  80f78a:	89 c7                	mov    %eax,%edi
  80f78c:	83 c4 20             	add    $0x20,%esp
		goto err;

	return newfdnum;
  80f78f:	89 f0                	mov    %esi,%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f791:	85 ff                	test   %edi,%edi
  80f793:	79 1d                	jns    80f7b2 <dup+0xe6>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  80f795:	83 ec 08             	sub    $0x8,%esp
  80f798:	53                   	push   %ebx
  80f799:	6a 00                	push   $0x0
  80f79b:	e8 2f f7 ff ff       	call   80eecf <sys_page_unmap>
	sys_page_unmap(0, nva);
  80f7a0:	83 c4 08             	add    $0x8,%esp
  80f7a3:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f7a6:	6a 00                	push   $0x0
  80f7a8:	e8 22 f7 ff ff       	call   80eecf <sys_page_unmap>
	return r;
  80f7ad:	83 c4 10             	add    $0x10,%esp
  80f7b0:	89 f8                	mov    %edi,%eax
}
  80f7b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f7b5:	5b                   	pop    %ebx
  80f7b6:	5e                   	pop    %esi
  80f7b7:	5f                   	pop    %edi
  80f7b8:	5d                   	pop    %ebp
  80f7b9:	c3                   	ret    

0080f7ba <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80f7ba:	55                   	push   %ebp
  80f7bb:	89 e5                	mov    %esp,%ebp
  80f7bd:	53                   	push   %ebx
  80f7be:	83 ec 14             	sub    $0x14,%esp
  80f7c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f7c4:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f7c7:	50                   	push   %eax
  80f7c8:	53                   	push   %ebx
  80f7c9:	e8 7d fd ff ff       	call   80f54b <fd_lookup>
  80f7ce:	83 c4 08             	add    $0x8,%esp
  80f7d1:	89 c2                	mov    %eax,%edx
  80f7d3:	85 c0                	test   %eax,%eax
  80f7d5:	78 6d                	js     80f844 <read+0x8a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f7d7:	83 ec 08             	sub    $0x8,%esp
  80f7da:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f7dd:	50                   	push   %eax
  80f7de:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f7e1:	ff 30                	pushl  (%eax)
  80f7e3:	e8 b9 fd ff ff       	call   80f5a1 <dev_lookup>
  80f7e8:	83 c4 10             	add    $0x10,%esp
  80f7eb:	85 c0                	test   %eax,%eax
  80f7ed:	78 4c                	js     80f83b <read+0x81>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80f7ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80f7f2:	8b 42 08             	mov    0x8(%edx),%eax
  80f7f5:	83 e0 03             	and    $0x3,%eax
  80f7f8:	83 f8 01             	cmp    $0x1,%eax
  80f7fb:	75 21                	jne    80f81e <read+0x64>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80f7fd:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
  80f802:	8b 40 48             	mov    0x48(%eax),%eax
  80f805:	83 ec 04             	sub    $0x4,%esp
  80f808:	53                   	push   %ebx
  80f809:	50                   	push   %eax
  80f80a:	68 71 37 81 00       	push   $0x813771
  80f80f:	e8 a6 ec ff ff       	call   80e4ba <cprintf>
		return -E_INVAL;
  80f814:	83 c4 10             	add    $0x10,%esp
  80f817:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f81c:	eb 26                	jmp    80f844 <read+0x8a>
	}
	if (!dev->dev_read)
  80f81e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f821:	8b 40 08             	mov    0x8(%eax),%eax
  80f824:	85 c0                	test   %eax,%eax
  80f826:	74 17                	je     80f83f <read+0x85>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80f828:	83 ec 04             	sub    $0x4,%esp
  80f82b:	ff 75 10             	pushl  0x10(%ebp)
  80f82e:	ff 75 0c             	pushl  0xc(%ebp)
  80f831:	52                   	push   %edx
  80f832:	ff d0                	call   *%eax
  80f834:	89 c2                	mov    %eax,%edx
  80f836:	83 c4 10             	add    $0x10,%esp
  80f839:	eb 09                	jmp    80f844 <read+0x8a>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f83b:	89 c2                	mov    %eax,%edx
  80f83d:	eb 05                	jmp    80f844 <read+0x8a>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  80f83f:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_read)(fd, buf, n);
}
  80f844:	89 d0                	mov    %edx,%eax
  80f846:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f849:	c9                   	leave  
  80f84a:	c3                   	ret    

0080f84b <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80f84b:	55                   	push   %ebp
  80f84c:	89 e5                	mov    %esp,%ebp
  80f84e:	57                   	push   %edi
  80f84f:	56                   	push   %esi
  80f850:	53                   	push   %ebx
  80f851:	83 ec 0c             	sub    $0xc,%esp
  80f854:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f857:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f85a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f85f:	eb 21                	jmp    80f882 <readn+0x37>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80f861:	83 ec 04             	sub    $0x4,%esp
  80f864:	89 f0                	mov    %esi,%eax
  80f866:	29 d8                	sub    %ebx,%eax
  80f868:	50                   	push   %eax
  80f869:	89 d8                	mov    %ebx,%eax
  80f86b:	03 45 0c             	add    0xc(%ebp),%eax
  80f86e:	50                   	push   %eax
  80f86f:	57                   	push   %edi
  80f870:	e8 45 ff ff ff       	call   80f7ba <read>
		if (m < 0)
  80f875:	83 c4 10             	add    $0x10,%esp
  80f878:	85 c0                	test   %eax,%eax
  80f87a:	78 0c                	js     80f888 <readn+0x3d>
			return m;
		if (m == 0)
  80f87c:	85 c0                	test   %eax,%eax
  80f87e:	74 06                	je     80f886 <readn+0x3b>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f880:	01 c3                	add    %eax,%ebx
  80f882:	39 f3                	cmp    %esi,%ebx
  80f884:	72 db                	jb     80f861 <readn+0x16>
		if (m < 0)
			return m;
		if (m == 0)
			break;
	}
	return tot;
  80f886:	89 d8                	mov    %ebx,%eax
}
  80f888:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f88b:	5b                   	pop    %ebx
  80f88c:	5e                   	pop    %esi
  80f88d:	5f                   	pop    %edi
  80f88e:	5d                   	pop    %ebp
  80f88f:	c3                   	ret    

0080f890 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80f890:	55                   	push   %ebp
  80f891:	89 e5                	mov    %esp,%ebp
  80f893:	53                   	push   %ebx
  80f894:	83 ec 14             	sub    $0x14,%esp
  80f897:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f89a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f89d:	50                   	push   %eax
  80f89e:	53                   	push   %ebx
  80f89f:	e8 a7 fc ff ff       	call   80f54b <fd_lookup>
  80f8a4:	83 c4 08             	add    $0x8,%esp
  80f8a7:	89 c2                	mov    %eax,%edx
  80f8a9:	85 c0                	test   %eax,%eax
  80f8ab:	78 68                	js     80f915 <write+0x85>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f8ad:	83 ec 08             	sub    $0x8,%esp
  80f8b0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f8b3:	50                   	push   %eax
  80f8b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f8b7:	ff 30                	pushl  (%eax)
  80f8b9:	e8 e3 fc ff ff       	call   80f5a1 <dev_lookup>
  80f8be:	83 c4 10             	add    $0x10,%esp
  80f8c1:	85 c0                	test   %eax,%eax
  80f8c3:	78 47                	js     80f90c <write+0x7c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f8c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f8c8:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f8cc:	75 21                	jne    80f8ef <write+0x5f>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80f8ce:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
  80f8d3:	8b 40 48             	mov    0x48(%eax),%eax
  80f8d6:	83 ec 04             	sub    $0x4,%esp
  80f8d9:	53                   	push   %ebx
  80f8da:	50                   	push   %eax
  80f8db:	68 8d 37 81 00       	push   $0x81378d
  80f8e0:	e8 d5 eb ff ff       	call   80e4ba <cprintf>
		return -E_INVAL;
  80f8e5:	83 c4 10             	add    $0x10,%esp
  80f8e8:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f8ed:	eb 26                	jmp    80f915 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80f8ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f8f2:	8b 52 0c             	mov    0xc(%edx),%edx
  80f8f5:	85 d2                	test   %edx,%edx
  80f8f7:	74 17                	je     80f910 <write+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80f8f9:	83 ec 04             	sub    $0x4,%esp
  80f8fc:	ff 75 10             	pushl  0x10(%ebp)
  80f8ff:	ff 75 0c             	pushl  0xc(%ebp)
  80f902:	50                   	push   %eax
  80f903:	ff d2                	call   *%edx
  80f905:	89 c2                	mov    %eax,%edx
  80f907:	83 c4 10             	add    $0x10,%esp
  80f90a:	eb 09                	jmp    80f915 <write+0x85>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f90c:	89 c2                	mov    %eax,%edx
  80f90e:	eb 05                	jmp    80f915 <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  80f910:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_write)(fd, buf, n);
}
  80f915:	89 d0                	mov    %edx,%eax
  80f917:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f91a:	c9                   	leave  
  80f91b:	c3                   	ret    

0080f91c <seek>:

int
seek(int fdnum, off_t offset)
{
  80f91c:	55                   	push   %ebp
  80f91d:	89 e5                	mov    %esp,%ebp
  80f91f:	83 ec 10             	sub    $0x10,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f922:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80f925:	50                   	push   %eax
  80f926:	ff 75 08             	pushl  0x8(%ebp)
  80f929:	e8 1d fc ff ff       	call   80f54b <fd_lookup>
  80f92e:	83 c4 08             	add    $0x8,%esp
  80f931:	85 c0                	test   %eax,%eax
  80f933:	78 0e                	js     80f943 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80f935:	8b 45 fc             	mov    -0x4(%ebp),%eax
  80f938:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f93b:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80f93e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f943:	c9                   	leave  
  80f944:	c3                   	ret    

0080f945 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80f945:	55                   	push   %ebp
  80f946:	89 e5                	mov    %esp,%ebp
  80f948:	53                   	push   %ebx
  80f949:	83 ec 14             	sub    $0x14,%esp
  80f94c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f94f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f952:	50                   	push   %eax
  80f953:	53                   	push   %ebx
  80f954:	e8 f2 fb ff ff       	call   80f54b <fd_lookup>
  80f959:	83 c4 08             	add    $0x8,%esp
  80f95c:	89 c2                	mov    %eax,%edx
  80f95e:	85 c0                	test   %eax,%eax
  80f960:	78 65                	js     80f9c7 <ftruncate+0x82>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f962:	83 ec 08             	sub    $0x8,%esp
  80f965:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f968:	50                   	push   %eax
  80f969:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f96c:	ff 30                	pushl  (%eax)
  80f96e:	e8 2e fc ff ff       	call   80f5a1 <dev_lookup>
  80f973:	83 c4 10             	add    $0x10,%esp
  80f976:	85 c0                	test   %eax,%eax
  80f978:	78 44                	js     80f9be <ftruncate+0x79>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f97a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f97d:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f981:	75 21                	jne    80f9a4 <ftruncate+0x5f>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  80f983:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80f988:	8b 40 48             	mov    0x48(%eax),%eax
  80f98b:	83 ec 04             	sub    $0x4,%esp
  80f98e:	53                   	push   %ebx
  80f98f:	50                   	push   %eax
  80f990:	68 50 37 81 00       	push   $0x813750
  80f995:	e8 20 eb ff ff       	call   80e4ba <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  80f99a:	83 c4 10             	add    $0x10,%esp
  80f99d:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f9a2:	eb 23                	jmp    80f9c7 <ftruncate+0x82>
	}
	if (!dev->dev_trunc)
  80f9a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f9a7:	8b 52 18             	mov    0x18(%edx),%edx
  80f9aa:	85 d2                	test   %edx,%edx
  80f9ac:	74 14                	je     80f9c2 <ftruncate+0x7d>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80f9ae:	83 ec 08             	sub    $0x8,%esp
  80f9b1:	ff 75 0c             	pushl  0xc(%ebp)
  80f9b4:	50                   	push   %eax
  80f9b5:	ff d2                	call   *%edx
  80f9b7:	89 c2                	mov    %eax,%edx
  80f9b9:	83 c4 10             	add    $0x10,%esp
  80f9bc:	eb 09                	jmp    80f9c7 <ftruncate+0x82>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f9be:	89 c2                	mov    %eax,%edx
  80f9c0:	eb 05                	jmp    80f9c7 <ftruncate+0x82>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  80f9c2:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_trunc)(fd, newsize);
}
  80f9c7:	89 d0                	mov    %edx,%eax
  80f9c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f9cc:	c9                   	leave  
  80f9cd:	c3                   	ret    

0080f9ce <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80f9ce:	55                   	push   %ebp
  80f9cf:	89 e5                	mov    %esp,%ebp
  80f9d1:	53                   	push   %ebx
  80f9d2:	83 ec 14             	sub    $0x14,%esp
  80f9d5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f9d8:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f9db:	50                   	push   %eax
  80f9dc:	ff 75 08             	pushl  0x8(%ebp)
  80f9df:	e8 67 fb ff ff       	call   80f54b <fd_lookup>
  80f9e4:	83 c4 08             	add    $0x8,%esp
  80f9e7:	89 c2                	mov    %eax,%edx
  80f9e9:	85 c0                	test   %eax,%eax
  80f9eb:	78 58                	js     80fa45 <fstat+0x77>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f9ed:	83 ec 08             	sub    $0x8,%esp
  80f9f0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f9f3:	50                   	push   %eax
  80f9f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f9f7:	ff 30                	pushl  (%eax)
  80f9f9:	e8 a3 fb ff ff       	call   80f5a1 <dev_lookup>
  80f9fe:	83 c4 10             	add    $0x10,%esp
  80fa01:	85 c0                	test   %eax,%eax
  80fa03:	78 37                	js     80fa3c <fstat+0x6e>
		return r;
	if (!dev->dev_stat)
  80fa05:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fa08:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80fa0c:	74 32                	je     80fa40 <fstat+0x72>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80fa0e:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80fa11:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80fa18:	00 00 00 
	stat->st_isdir = 0;
  80fa1b:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80fa22:	00 00 00 
	stat->st_dev = dev;
  80fa25:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80fa2b:	83 ec 08             	sub    $0x8,%esp
  80fa2e:	53                   	push   %ebx
  80fa2f:	ff 75 f0             	pushl  -0x10(%ebp)
  80fa32:	ff 50 14             	call   *0x14(%eax)
  80fa35:	89 c2                	mov    %eax,%edx
  80fa37:	83 c4 10             	add    $0x10,%esp
  80fa3a:	eb 09                	jmp    80fa45 <fstat+0x77>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fa3c:	89 c2                	mov    %eax,%edx
  80fa3e:	eb 05                	jmp    80fa45 <fstat+0x77>
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  80fa40:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  80fa45:	89 d0                	mov    %edx,%eax
  80fa47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fa4a:	c9                   	leave  
  80fa4b:	c3                   	ret    

0080fa4c <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80fa4c:	55                   	push   %ebp
  80fa4d:	89 e5                	mov    %esp,%ebp
  80fa4f:	56                   	push   %esi
  80fa50:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80fa51:	83 ec 08             	sub    $0x8,%esp
  80fa54:	6a 00                	push   $0x0
  80fa56:	ff 75 08             	pushl  0x8(%ebp)
  80fa59:	e8 09 02 00 00       	call   80fc67 <open>
  80fa5e:	89 c3                	mov    %eax,%ebx
  80fa60:	83 c4 10             	add    $0x10,%esp
  80fa63:	85 db                	test   %ebx,%ebx
  80fa65:	78 1b                	js     80fa82 <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80fa67:	83 ec 08             	sub    $0x8,%esp
  80fa6a:	ff 75 0c             	pushl  0xc(%ebp)
  80fa6d:	53                   	push   %ebx
  80fa6e:	e8 5b ff ff ff       	call   80f9ce <fstat>
  80fa73:	89 c6                	mov    %eax,%esi
	close(fd);
  80fa75:	89 1c 24             	mov    %ebx,(%esp)
  80fa78:	e8 fd fb ff ff       	call   80f67a <close>
	return r;
  80fa7d:	83 c4 10             	add    $0x10,%esp
  80fa80:	89 f0                	mov    %esi,%eax
}
  80fa82:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fa85:	5b                   	pop    %ebx
  80fa86:	5e                   	pop    %esi
  80fa87:	5d                   	pop    %ebp
  80fa88:	c3                   	ret    

0080fa89 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80fa89:	55                   	push   %ebp
  80fa8a:	89 e5                	mov    %esp,%ebp
  80fa8c:	56                   	push   %esi
  80fa8d:	53                   	push   %ebx
  80fa8e:	89 c6                	mov    %eax,%esi
  80fa90:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80fa92:	83 3d 0c b3 b3 00 00 	cmpl   $0x0,0xb3b30c
  80fa99:	75 12                	jne    80faad <fsipc+0x24>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80fa9b:	83 ec 0c             	sub    $0xc,%esp
  80fa9e:	6a 01                	push   $0x1
  80faa0:	e8 f8 f9 ff ff       	call   80f49d <ipc_find_env>
  80faa5:	a3 0c b3 b3 00       	mov    %eax,0xb3b30c
  80faaa:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80faad:	6a 07                	push   $0x7
  80faaf:	68 00 c0 b3 00       	push   $0xb3c000
  80fab4:	56                   	push   %esi
  80fab5:	ff 35 0c b3 b3 00    	pushl  0xb3b30c
  80fabb:	e8 89 f9 ff ff       	call   80f449 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80fac0:	83 c4 0c             	add    $0xc,%esp
  80fac3:	6a 00                	push   $0x0
  80fac5:	53                   	push   %ebx
  80fac6:	6a 00                	push   $0x0
  80fac8:	e8 13 f9 ff ff       	call   80f3e0 <ipc_recv>
}
  80facd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fad0:	5b                   	pop    %ebx
  80fad1:	5e                   	pop    %esi
  80fad2:	5d                   	pop    %ebp
  80fad3:	c3                   	ret    

0080fad4 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80fad4:	55                   	push   %ebp
  80fad5:	89 e5                	mov    %esp,%ebp
  80fad7:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80fada:	8b 45 08             	mov    0x8(%ebp),%eax
  80fadd:	8b 40 0c             	mov    0xc(%eax),%eax
  80fae0:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80fae5:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fae8:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80faed:	ba 00 00 00 00       	mov    $0x0,%edx
  80faf2:	b8 02 00 00 00       	mov    $0x2,%eax
  80faf7:	e8 8d ff ff ff       	call   80fa89 <fsipc>
}
  80fafc:	c9                   	leave  
  80fafd:	c3                   	ret    

0080fafe <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80fafe:	55                   	push   %ebp
  80faff:	89 e5                	mov    %esp,%ebp
  80fb01:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80fb04:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb07:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb0a:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80fb0f:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb14:	b8 06 00 00 00       	mov    $0x6,%eax
  80fb19:	e8 6b ff ff ff       	call   80fa89 <fsipc>
}
  80fb1e:	c9                   	leave  
  80fb1f:	c3                   	ret    

0080fb20 <devfile_stat>:
        return src_buf - buf;
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  80fb20:	55                   	push   %ebp
  80fb21:	89 e5                	mov    %esp,%ebp
  80fb23:	53                   	push   %ebx
  80fb24:	83 ec 04             	sub    $0x4,%esp
  80fb27:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fb2a:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb2d:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb30:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fb35:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb3a:	b8 05 00 00 00       	mov    $0x5,%eax
  80fb3f:	e8 45 ff ff ff       	call   80fa89 <fsipc>
  80fb44:	89 c2                	mov    %eax,%edx
  80fb46:	85 d2                	test   %edx,%edx
  80fb48:	78 2c                	js     80fb76 <devfile_stat+0x56>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fb4a:	83 ec 08             	sub    $0x8,%esp
  80fb4d:	68 00 c0 b3 00       	push   $0xb3c000
  80fb52:	53                   	push   %ebx
  80fb53:	e8 e9 ee ff ff       	call   80ea41 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fb58:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fb5d:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fb63:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fb68:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fb6e:	83 c4 10             	add    $0x10,%esp
  80fb71:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fb76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fb79:	c9                   	leave  
  80fb7a:	c3                   	ret    

0080fb7b <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80fb7b:	55                   	push   %ebp
  80fb7c:	89 e5                	mov    %esp,%ebp
  80fb7e:	57                   	push   %edi
  80fb7f:	56                   	push   %esi
  80fb80:	53                   	push   %ebx
  80fb81:	83 ec 0c             	sub    $0xc,%esp
  80fb84:	8b 75 10             	mov    0x10(%ebp),%esi
	//panic("devfile_write not implemented");
        int r;
        const void *src_buf = buf;
        size_t ipc_buf_size = PGSIZE - (sizeof(int) + sizeof(size_t));
 
        fsipcbuf.write.req_fileid = fd->fd_file.id;       
  80fb87:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb8a:	8b 40 0c             	mov    0xc(%eax),%eax
  80fb8d:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	//panic("devfile_write not implemented");
        int r;
        const void *src_buf = buf;
  80fb92:	8b 5d 0c             	mov    0xc(%ebp),%ebx
        size_t ipc_buf_size = PGSIZE - (sizeof(int) + sizeof(size_t));
 
        fsipcbuf.write.req_fileid = fd->fd_file.id;       
        while( n > 0) {
  80fb95:	eb 3d                	jmp    80fbd4 <devfile_write+0x59>
                size_t tmp = MIN(ipc_buf_size, n);
  80fb97:	81 fe f8 0f 00 00    	cmp    $0xff8,%esi
  80fb9d:	bf f8 0f 00 00       	mov    $0xff8,%edi
  80fba2:	0f 46 fe             	cmovbe %esi,%edi
                memmove(fsipcbuf.write.req_buf, src_buf, tmp);
  80fba5:	83 ec 04             	sub    $0x4,%esp
  80fba8:	57                   	push   %edi
  80fba9:	53                   	push   %ebx
  80fbaa:	68 08 c0 b3 00       	push   $0xb3c008
  80fbaf:	e8 1f f0 ff ff       	call   80ebd3 <memmove>
                fsipcbuf.write.req_n = tmp; 
  80fbb4:	89 3d 04 c0 b3 00    	mov    %edi,0xb3c004
                if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  80fbba:	ba 00 00 00 00       	mov    $0x0,%edx
  80fbbf:	b8 04 00 00 00       	mov    $0x4,%eax
  80fbc4:	e8 c0 fe ff ff       	call   80fa89 <fsipc>
  80fbc9:	83 c4 10             	add    $0x10,%esp
  80fbcc:	85 c0                	test   %eax,%eax
  80fbce:	78 0d                	js     80fbdd <devfile_write+0x62>
		        return r;
                n -= tmp;
  80fbd0:	29 fe                	sub    %edi,%esi
                src_buf += tmp;
  80fbd2:	01 fb                	add    %edi,%ebx
        int r;
        const void *src_buf = buf;
        size_t ipc_buf_size = PGSIZE - (sizeof(int) + sizeof(size_t));
 
        fsipcbuf.write.req_fileid = fd->fd_file.id;       
        while( n > 0) {
  80fbd4:	85 f6                	test   %esi,%esi
  80fbd6:	75 bf                	jne    80fb97 <devfile_write+0x1c>
                if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
		        return r;
                n -= tmp;
                src_buf += tmp;
        } 
        return src_buf - buf;
  80fbd8:	89 d8                	mov    %ebx,%eax
  80fbda:	2b 45 0c             	sub    0xc(%ebp),%eax
}
  80fbdd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fbe0:	5b                   	pop    %ebx
  80fbe1:	5e                   	pop    %esi
  80fbe2:	5f                   	pop    %edi
  80fbe3:	5d                   	pop    %ebp
  80fbe4:	c3                   	ret    

0080fbe5 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80fbe5:	55                   	push   %ebp
  80fbe6:	89 e5                	mov    %esp,%ebp
  80fbe8:	56                   	push   %esi
  80fbe9:	53                   	push   %ebx
  80fbea:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80fbed:	8b 45 08             	mov    0x8(%ebp),%eax
  80fbf0:	8b 40 0c             	mov    0xc(%eax),%eax
  80fbf3:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80fbf8:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80fbfe:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc03:	b8 03 00 00 00       	mov    $0x3,%eax
  80fc08:	e8 7c fe ff ff       	call   80fa89 <fsipc>
  80fc0d:	89 c3                	mov    %eax,%ebx
  80fc0f:	85 c0                	test   %eax,%eax
  80fc11:	78 4b                	js     80fc5e <devfile_read+0x79>
		return r;
	assert(r <= n);
  80fc13:	39 c6                	cmp    %eax,%esi
  80fc15:	73 16                	jae    80fc2d <devfile_read+0x48>
  80fc17:	68 c0 37 81 00       	push   $0x8137c0
  80fc1c:	68 5f 24 81 00       	push   $0x81245f
  80fc21:	6a 7c                	push   $0x7c
  80fc23:	68 c7 37 81 00       	push   $0x8137c7
  80fc28:	e8 b4 e7 ff ff       	call   80e3e1 <_panic>
	assert(r <= PGSIZE);
  80fc2d:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80fc32:	7e 16                	jle    80fc4a <devfile_read+0x65>
  80fc34:	68 d2 37 81 00       	push   $0x8137d2
  80fc39:	68 5f 24 81 00       	push   $0x81245f
  80fc3e:	6a 7d                	push   $0x7d
  80fc40:	68 c7 37 81 00       	push   $0x8137c7
  80fc45:	e8 97 e7 ff ff       	call   80e3e1 <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80fc4a:	83 ec 04             	sub    $0x4,%esp
  80fc4d:	50                   	push   %eax
  80fc4e:	68 00 c0 b3 00       	push   $0xb3c000
  80fc53:	ff 75 0c             	pushl  0xc(%ebp)
  80fc56:	e8 78 ef ff ff       	call   80ebd3 <memmove>
	return r;
  80fc5b:	83 c4 10             	add    $0x10,%esp
}
  80fc5e:	89 d8                	mov    %ebx,%eax
  80fc60:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fc63:	5b                   	pop    %ebx
  80fc64:	5e                   	pop    %esi
  80fc65:	5d                   	pop    %ebp
  80fc66:	c3                   	ret    

0080fc67 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  80fc67:	55                   	push   %ebp
  80fc68:	89 e5                	mov    %esp,%ebp
  80fc6a:	53                   	push   %ebx
  80fc6b:	83 ec 20             	sub    $0x20,%esp
  80fc6e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  80fc71:	53                   	push   %ebx
  80fc72:	e8 91 ed ff ff       	call   80ea08 <strlen>
  80fc77:	83 c4 10             	add    $0x10,%esp
  80fc7a:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80fc7f:	7f 67                	jg     80fce8 <open+0x81>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fc81:	83 ec 0c             	sub    $0xc,%esp
  80fc84:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fc87:	50                   	push   %eax
  80fc88:	e8 6f f8 ff ff       	call   80f4fc <fd_alloc>
  80fc8d:	83 c4 10             	add    $0x10,%esp
		return r;
  80fc90:	89 c2                	mov    %eax,%edx
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fc92:	85 c0                	test   %eax,%eax
  80fc94:	78 57                	js     80fced <open+0x86>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  80fc96:	83 ec 08             	sub    $0x8,%esp
  80fc99:	53                   	push   %ebx
  80fc9a:	68 00 c0 b3 00       	push   $0xb3c000
  80fc9f:	e8 9d ed ff ff       	call   80ea41 <strcpy>
	fsipcbuf.open.req_omode = mode;
  80fca4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fca7:	a3 00 c4 b3 00       	mov    %eax,0xb3c400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80fcac:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fcaf:	b8 01 00 00 00       	mov    $0x1,%eax
  80fcb4:	e8 d0 fd ff ff       	call   80fa89 <fsipc>
  80fcb9:	89 c3                	mov    %eax,%ebx
  80fcbb:	83 c4 10             	add    $0x10,%esp
  80fcbe:	85 c0                	test   %eax,%eax
  80fcc0:	79 14                	jns    80fcd6 <open+0x6f>
		fd_close(fd, 0);
  80fcc2:	83 ec 08             	sub    $0x8,%esp
  80fcc5:	6a 00                	push   $0x0
  80fcc7:	ff 75 f4             	pushl  -0xc(%ebp)
  80fcca:	e8 2a f9 ff ff       	call   80f5f9 <fd_close>
		return r;
  80fccf:	83 c4 10             	add    $0x10,%esp
  80fcd2:	89 da                	mov    %ebx,%edx
  80fcd4:	eb 17                	jmp    80fced <open+0x86>
	}

	return fd2num(fd);
  80fcd6:	83 ec 0c             	sub    $0xc,%esp
  80fcd9:	ff 75 f4             	pushl  -0xc(%ebp)
  80fcdc:	e8 f4 f7 ff ff       	call   80f4d5 <fd2num>
  80fce1:	89 c2                	mov    %eax,%edx
  80fce3:	83 c4 10             	add    $0x10,%esp
  80fce6:	eb 05                	jmp    80fced <open+0x86>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  80fce8:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  80fced:	89 d0                	mov    %edx,%eax
  80fcef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fcf2:	c9                   	leave  
  80fcf3:	c3                   	ret    

0080fcf4 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  80fcf4:	55                   	push   %ebp
  80fcf5:	89 e5                	mov    %esp,%ebp
  80fcf7:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80fcfa:	ba 00 00 00 00       	mov    $0x0,%edx
  80fcff:	b8 08 00 00 00       	mov    $0x8,%eax
  80fd04:	e8 80 fd ff ff       	call   80fa89 <fsipc>
}
  80fd09:	c9                   	leave  
  80fd0a:	c3                   	ret    

0080fd0b <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80fd0b:	55                   	push   %ebp
  80fd0c:	89 e5                	mov    %esp,%ebp
  80fd0e:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  80fd11:	68 de 37 81 00       	push   $0x8137de
  80fd16:	ff 75 0c             	pushl  0xc(%ebp)
  80fd19:	e8 23 ed ff ff       	call   80ea41 <strcpy>
	return 0;
}
  80fd1e:	b8 00 00 00 00       	mov    $0x0,%eax
  80fd23:	c9                   	leave  
  80fd24:	c3                   	ret    

0080fd25 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  80fd25:	55                   	push   %ebp
  80fd26:	89 e5                	mov    %esp,%ebp
  80fd28:	53                   	push   %ebx
  80fd29:	83 ec 10             	sub    $0x10,%esp
  80fd2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  80fd2f:	53                   	push   %ebx
  80fd30:	e8 23 0c 00 00       	call   810958 <pageref>
  80fd35:	83 c4 10             	add    $0x10,%esp
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  80fd38:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  80fd3d:	83 f8 01             	cmp    $0x1,%eax
  80fd40:	75 10                	jne    80fd52 <devsock_close+0x2d>
		return nsipc_close(fd->fd_sock.sockid);
  80fd42:	83 ec 0c             	sub    $0xc,%esp
  80fd45:	ff 73 0c             	pushl  0xc(%ebx)
  80fd48:	e8 ca 02 00 00       	call   810017 <nsipc_close>
  80fd4d:	89 c2                	mov    %eax,%edx
  80fd4f:	83 c4 10             	add    $0x10,%esp
	else
		return 0;
}
  80fd52:	89 d0                	mov    %edx,%eax
  80fd54:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd57:	c9                   	leave  
  80fd58:	c3                   	ret    

0080fd59 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80fd59:	55                   	push   %ebp
  80fd5a:	89 e5                	mov    %esp,%ebp
  80fd5c:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80fd5f:	6a 00                	push   $0x0
  80fd61:	ff 75 10             	pushl  0x10(%ebp)
  80fd64:	ff 75 0c             	pushl  0xc(%ebp)
  80fd67:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd6a:	ff 70 0c             	pushl  0xc(%eax)
  80fd6d:	e8 82 03 00 00       	call   8100f4 <nsipc_send>
}
  80fd72:	c9                   	leave  
  80fd73:	c3                   	ret    

0080fd74 <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80fd74:	55                   	push   %ebp
  80fd75:	89 e5                	mov    %esp,%ebp
  80fd77:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80fd7a:	6a 00                	push   $0x0
  80fd7c:	ff 75 10             	pushl  0x10(%ebp)
  80fd7f:	ff 75 0c             	pushl  0xc(%ebp)
  80fd82:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd85:	ff 70 0c             	pushl  0xc(%eax)
  80fd88:	e8 fb 02 00 00       	call   810088 <nsipc_recv>
}
  80fd8d:	c9                   	leave  
  80fd8e:	c3                   	ret    

0080fd8f <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80fd8f:	55                   	push   %ebp
  80fd90:	89 e5                	mov    %esp,%ebp
  80fd92:	83 ec 20             	sub    $0x20,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  80fd95:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80fd98:	52                   	push   %edx
  80fd99:	50                   	push   %eax
  80fd9a:	e8 ac f7 ff ff       	call   80f54b <fd_lookup>
  80fd9f:	83 c4 10             	add    $0x10,%esp
  80fda2:	85 c0                	test   %eax,%eax
  80fda4:	78 17                	js     80fdbd <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  80fda6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fda9:	8b 0d 28 43 81 00    	mov    0x814328,%ecx
  80fdaf:	39 08                	cmp    %ecx,(%eax)
  80fdb1:	75 05                	jne    80fdb8 <fd2sockid+0x29>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  80fdb3:	8b 40 0c             	mov    0xc(%eax),%eax
  80fdb6:	eb 05                	jmp    80fdbd <fd2sockid+0x2e>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  80fdb8:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  80fdbd:	c9                   	leave  
  80fdbe:	c3                   	ret    

0080fdbf <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  80fdbf:	55                   	push   %ebp
  80fdc0:	89 e5                	mov    %esp,%ebp
  80fdc2:	56                   	push   %esi
  80fdc3:	53                   	push   %ebx
  80fdc4:	83 ec 1c             	sub    $0x1c,%esp
  80fdc7:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80fdc9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fdcc:	50                   	push   %eax
  80fdcd:	e8 2a f7 ff ff       	call   80f4fc <fd_alloc>
  80fdd2:	89 c3                	mov    %eax,%ebx
  80fdd4:	83 c4 10             	add    $0x10,%esp
  80fdd7:	85 c0                	test   %eax,%eax
  80fdd9:	78 1b                	js     80fdf6 <alloc_sockfd+0x37>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80fddb:	83 ec 04             	sub    $0x4,%esp
  80fdde:	68 07 04 00 00       	push   $0x407
  80fde3:	ff 75 f4             	pushl  -0xc(%ebp)
  80fde6:	6a 00                	push   $0x0
  80fde8:	e8 5d f0 ff ff       	call   80ee4a <sys_page_alloc>
  80fded:	89 c3                	mov    %eax,%ebx
  80fdef:	83 c4 10             	add    $0x10,%esp
  80fdf2:	85 c0                	test   %eax,%eax
  80fdf4:	79 10                	jns    80fe06 <alloc_sockfd+0x47>
		nsipc_close(sockid);
  80fdf6:	83 ec 0c             	sub    $0xc,%esp
  80fdf9:	56                   	push   %esi
  80fdfa:	e8 18 02 00 00       	call   810017 <nsipc_close>
		return r;
  80fdff:	83 c4 10             	add    $0x10,%esp
  80fe02:	89 d8                	mov    %ebx,%eax
  80fe04:	eb 24                	jmp    80fe2a <alloc_sockfd+0x6b>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80fe06:	8b 15 28 43 81 00    	mov    0x814328,%edx
  80fe0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fe0f:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80fe11:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fe14:	c7 42 08 02 00 00 00 	movl   $0x2,0x8(%edx)
	sfd->fd_sock.sockid = sockid;
  80fe1b:	89 72 0c             	mov    %esi,0xc(%edx)
	return fd2num(sfd);
  80fe1e:	83 ec 0c             	sub    $0xc,%esp
  80fe21:	52                   	push   %edx
  80fe22:	e8 ae f6 ff ff       	call   80f4d5 <fd2num>
  80fe27:	83 c4 10             	add    $0x10,%esp
}
  80fe2a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fe2d:	5b                   	pop    %ebx
  80fe2e:	5e                   	pop    %esi
  80fe2f:	5d                   	pop    %ebp
  80fe30:	c3                   	ret    

0080fe31 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80fe31:	55                   	push   %ebp
  80fe32:	89 e5                	mov    %esp,%ebp
  80fe34:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe37:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe3a:	e8 50 ff ff ff       	call   80fd8f <fd2sockid>
		return r;
  80fe3f:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe41:	85 c0                	test   %eax,%eax
  80fe43:	78 1f                	js     80fe64 <accept+0x33>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fe45:	83 ec 04             	sub    $0x4,%esp
  80fe48:	ff 75 10             	pushl  0x10(%ebp)
  80fe4b:	ff 75 0c             	pushl  0xc(%ebp)
  80fe4e:	50                   	push   %eax
  80fe4f:	e8 1c 01 00 00       	call   80ff70 <nsipc_accept>
  80fe54:	83 c4 10             	add    $0x10,%esp
		return r;
  80fe57:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fe59:	85 c0                	test   %eax,%eax
  80fe5b:	78 07                	js     80fe64 <accept+0x33>
		return r;
	return alloc_sockfd(r);
  80fe5d:	e8 5d ff ff ff       	call   80fdbf <alloc_sockfd>
  80fe62:	89 c1                	mov    %eax,%ecx
}
  80fe64:	89 c8                	mov    %ecx,%eax
  80fe66:	c9                   	leave  
  80fe67:	c3                   	ret    

0080fe68 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80fe68:	55                   	push   %ebp
  80fe69:	89 e5                	mov    %esp,%ebp
  80fe6b:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe6e:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe71:	e8 19 ff ff ff       	call   80fd8f <fd2sockid>
  80fe76:	89 c2                	mov    %eax,%edx
  80fe78:	85 d2                	test   %edx,%edx
  80fe7a:	78 12                	js     80fe8e <bind+0x26>
		return r;
	return nsipc_bind(r, name, namelen);
  80fe7c:	83 ec 04             	sub    $0x4,%esp
  80fe7f:	ff 75 10             	pushl  0x10(%ebp)
  80fe82:	ff 75 0c             	pushl  0xc(%ebp)
  80fe85:	52                   	push   %edx
  80fe86:	e8 35 01 00 00       	call   80ffc0 <nsipc_bind>
  80fe8b:	83 c4 10             	add    $0x10,%esp
}
  80fe8e:	c9                   	leave  
  80fe8f:	c3                   	ret    

0080fe90 <shutdown>:

int
shutdown(int s, int how)
{
  80fe90:	55                   	push   %ebp
  80fe91:	89 e5                	mov    %esp,%ebp
  80fe93:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fe96:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe99:	e8 f1 fe ff ff       	call   80fd8f <fd2sockid>
  80fe9e:	89 c2                	mov    %eax,%edx
  80fea0:	85 d2                	test   %edx,%edx
  80fea2:	78 0f                	js     80feb3 <shutdown+0x23>
		return r;
	return nsipc_shutdown(r, how);
  80fea4:	83 ec 08             	sub    $0x8,%esp
  80fea7:	ff 75 0c             	pushl  0xc(%ebp)
  80feaa:	52                   	push   %edx
  80feab:	e8 45 01 00 00       	call   80fff5 <nsipc_shutdown>
  80feb0:	83 c4 10             	add    $0x10,%esp
}
  80feb3:	c9                   	leave  
  80feb4:	c3                   	ret    

0080feb5 <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80feb5:	55                   	push   %ebp
  80feb6:	89 e5                	mov    %esp,%ebp
  80feb8:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80febb:	8b 45 08             	mov    0x8(%ebp),%eax
  80febe:	e8 cc fe ff ff       	call   80fd8f <fd2sockid>
  80fec3:	89 c2                	mov    %eax,%edx
  80fec5:	85 d2                	test   %edx,%edx
  80fec7:	78 12                	js     80fedb <connect+0x26>
		return r;
	return nsipc_connect(r, name, namelen);
  80fec9:	83 ec 04             	sub    $0x4,%esp
  80fecc:	ff 75 10             	pushl  0x10(%ebp)
  80fecf:	ff 75 0c             	pushl  0xc(%ebp)
  80fed2:	52                   	push   %edx
  80fed3:	e8 59 01 00 00       	call   810031 <nsipc_connect>
  80fed8:	83 c4 10             	add    $0x10,%esp
}
  80fedb:	c9                   	leave  
  80fedc:	c3                   	ret    

0080fedd <listen>:

int
listen(int s, int backlog)
{
  80fedd:	55                   	push   %ebp
  80fede:	89 e5                	mov    %esp,%ebp
  80fee0:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fee3:	8b 45 08             	mov    0x8(%ebp),%eax
  80fee6:	e8 a4 fe ff ff       	call   80fd8f <fd2sockid>
  80feeb:	89 c2                	mov    %eax,%edx
  80feed:	85 d2                	test   %edx,%edx
  80feef:	78 0f                	js     80ff00 <listen+0x23>
		return r;
	return nsipc_listen(r, backlog);
  80fef1:	83 ec 08             	sub    $0x8,%esp
  80fef4:	ff 75 0c             	pushl  0xc(%ebp)
  80fef7:	52                   	push   %edx
  80fef8:	e8 69 01 00 00       	call   810066 <nsipc_listen>
  80fefd:	83 c4 10             	add    $0x10,%esp
}
  80ff00:	c9                   	leave  
  80ff01:	c3                   	ret    

0080ff02 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  80ff02:	55                   	push   %ebp
  80ff03:	89 e5                	mov    %esp,%ebp
  80ff05:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80ff08:	ff 75 10             	pushl  0x10(%ebp)
  80ff0b:	ff 75 0c             	pushl  0xc(%ebp)
  80ff0e:	ff 75 08             	pushl  0x8(%ebp)
  80ff11:	e8 3c 02 00 00       	call   810152 <nsipc_socket>
  80ff16:	89 c2                	mov    %eax,%edx
  80ff18:	83 c4 10             	add    $0x10,%esp
  80ff1b:	85 d2                	test   %edx,%edx
  80ff1d:	78 05                	js     80ff24 <socket+0x22>
		return r;
	return alloc_sockfd(r);
  80ff1f:	e8 9b fe ff ff       	call   80fdbf <alloc_sockfd>
}
  80ff24:	c9                   	leave  
  80ff25:	c3                   	ret    

0080ff26 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  80ff26:	55                   	push   %ebp
  80ff27:	89 e5                	mov    %esp,%ebp
  80ff29:	53                   	push   %ebx
  80ff2a:	83 ec 04             	sub    $0x4,%esp
  80ff2d:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  80ff2f:	83 3d 10 b3 b3 00 00 	cmpl   $0x0,0xb3b310
  80ff36:	75 12                	jne    80ff4a <nsipc+0x24>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  80ff38:	83 ec 0c             	sub    $0xc,%esp
  80ff3b:	6a 02                	push   $0x2
  80ff3d:	e8 5b f5 ff ff       	call   80f49d <ipc_find_env>
  80ff42:	a3 10 b3 b3 00       	mov    %eax,0xb3b310
  80ff47:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80ff4a:	6a 07                	push   $0x7
  80ff4c:	68 00 d0 b3 00       	push   $0xb3d000
  80ff51:	53                   	push   %ebx
  80ff52:	ff 35 10 b3 b3 00    	pushl  0xb3b310
  80ff58:	e8 ec f4 ff ff       	call   80f449 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  80ff5d:	83 c4 0c             	add    $0xc,%esp
  80ff60:	6a 00                	push   $0x0
  80ff62:	6a 00                	push   $0x0
  80ff64:	6a 00                	push   $0x0
  80ff66:	e8 75 f4 ff ff       	call   80f3e0 <ipc_recv>
}
  80ff6b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff6e:	c9                   	leave  
  80ff6f:	c3                   	ret    

0080ff70 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80ff70:	55                   	push   %ebp
  80ff71:	89 e5                	mov    %esp,%ebp
  80ff73:	56                   	push   %esi
  80ff74:	53                   	push   %ebx
  80ff75:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  80ff78:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff7b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  80ff80:	8b 06                	mov    (%esi),%eax
  80ff82:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80ff87:	b8 01 00 00 00       	mov    $0x1,%eax
  80ff8c:	e8 95 ff ff ff       	call   80ff26 <nsipc>
  80ff91:	89 c3                	mov    %eax,%ebx
  80ff93:	85 c0                	test   %eax,%eax
  80ff95:	78 20                	js     80ffb7 <nsipc_accept+0x47>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80ff97:	83 ec 04             	sub    $0x4,%esp
  80ff9a:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  80ffa0:	68 00 d0 b3 00       	push   $0xb3d000
  80ffa5:	ff 75 0c             	pushl  0xc(%ebp)
  80ffa8:	e8 26 ec ff ff       	call   80ebd3 <memmove>
		*addrlen = ret->ret_addrlen;
  80ffad:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  80ffb2:	89 06                	mov    %eax,(%esi)
  80ffb4:	83 c4 10             	add    $0x10,%esp
	}
	return r;
}
  80ffb7:	89 d8                	mov    %ebx,%eax
  80ffb9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ffbc:	5b                   	pop    %ebx
  80ffbd:	5e                   	pop    %esi
  80ffbe:	5d                   	pop    %ebp
  80ffbf:	c3                   	ret    

0080ffc0 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80ffc0:	55                   	push   %ebp
  80ffc1:	89 e5                	mov    %esp,%ebp
  80ffc3:	53                   	push   %ebx
  80ffc4:	83 ec 08             	sub    $0x8,%esp
  80ffc7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  80ffca:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffcd:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  80ffd2:	53                   	push   %ebx
  80ffd3:	ff 75 0c             	pushl  0xc(%ebp)
  80ffd6:	68 04 d0 b3 00       	push   $0xb3d004
  80ffdb:	e8 f3 eb ff ff       	call   80ebd3 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  80ffe0:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  80ffe6:	b8 02 00 00 00       	mov    $0x2,%eax
  80ffeb:	e8 36 ff ff ff       	call   80ff26 <nsipc>
}
  80fff0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fff3:	c9                   	leave  
  80fff4:	c3                   	ret    

0080fff5 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  80fff5:	55                   	push   %ebp
  80fff6:	89 e5                	mov    %esp,%ebp
  80fff8:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  80fffb:	8b 45 08             	mov    0x8(%ebp),%eax
  80fffe:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  810003:	8b 45 0c             	mov    0xc(%ebp),%eax
  810006:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  81000b:	b8 03 00 00 00       	mov    $0x3,%eax
  810010:	e8 11 ff ff ff       	call   80ff26 <nsipc>
}
  810015:	c9                   	leave  
  810016:	c3                   	ret    

00810017 <nsipc_close>:

int
nsipc_close(int s)
{
  810017:	55                   	push   %ebp
  810018:	89 e5                	mov    %esp,%ebp
  81001a:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  81001d:	8b 45 08             	mov    0x8(%ebp),%eax
  810020:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  810025:	b8 04 00 00 00       	mov    $0x4,%eax
  81002a:	e8 f7 fe ff ff       	call   80ff26 <nsipc>
}
  81002f:	c9                   	leave  
  810030:	c3                   	ret    

00810031 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810031:	55                   	push   %ebp
  810032:	89 e5                	mov    %esp,%ebp
  810034:	53                   	push   %ebx
  810035:	83 ec 08             	sub    $0x8,%esp
  810038:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  81003b:	8b 45 08             	mov    0x8(%ebp),%eax
  81003e:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810043:	53                   	push   %ebx
  810044:	ff 75 0c             	pushl  0xc(%ebp)
  810047:	68 04 d0 b3 00       	push   $0xb3d004
  81004c:	e8 82 eb ff ff       	call   80ebd3 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810051:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  810057:	b8 05 00 00 00       	mov    $0x5,%eax
  81005c:	e8 c5 fe ff ff       	call   80ff26 <nsipc>
}
  810061:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810064:	c9                   	leave  
  810065:	c3                   	ret    

00810066 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810066:	55                   	push   %ebp
  810067:	89 e5                	mov    %esp,%ebp
  810069:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  81006c:	8b 45 08             	mov    0x8(%ebp),%eax
  81006f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  810074:	8b 45 0c             	mov    0xc(%ebp),%eax
  810077:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  81007c:	b8 06 00 00 00       	mov    $0x6,%eax
  810081:	e8 a0 fe ff ff       	call   80ff26 <nsipc>
}
  810086:	c9                   	leave  
  810087:	c3                   	ret    

00810088 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  810088:	55                   	push   %ebp
  810089:	89 e5                	mov    %esp,%ebp
  81008b:	56                   	push   %esi
  81008c:	53                   	push   %ebx
  81008d:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810090:	8b 45 08             	mov    0x8(%ebp),%eax
  810093:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  810098:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  81009e:	8b 45 14             	mov    0x14(%ebp),%eax
  8100a1:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8100a6:	b8 07 00 00 00       	mov    $0x7,%eax
  8100ab:	e8 76 fe ff ff       	call   80ff26 <nsipc>
  8100b0:	89 c3                	mov    %eax,%ebx
  8100b2:	85 c0                	test   %eax,%eax
  8100b4:	78 35                	js     8100eb <nsipc_recv+0x63>
		assert(r < 1600 && r <= len);
  8100b6:	39 f0                	cmp    %esi,%eax
  8100b8:	7f 07                	jg     8100c1 <nsipc_recv+0x39>
  8100ba:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  8100bf:	7e 16                	jle    8100d7 <nsipc_recv+0x4f>
  8100c1:	68 ea 37 81 00       	push   $0x8137ea
  8100c6:	68 5f 24 81 00       	push   $0x81245f
  8100cb:	6a 62                	push   $0x62
  8100cd:	68 ff 37 81 00       	push   $0x8137ff
  8100d2:	e8 0a e3 ff ff       	call   80e3e1 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  8100d7:	83 ec 04             	sub    $0x4,%esp
  8100da:	50                   	push   %eax
  8100db:	68 00 d0 b3 00       	push   $0xb3d000
  8100e0:	ff 75 0c             	pushl  0xc(%ebp)
  8100e3:	e8 eb ea ff ff       	call   80ebd3 <memmove>
  8100e8:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  8100eb:	89 d8                	mov    %ebx,%eax
  8100ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8100f0:	5b                   	pop    %ebx
  8100f1:	5e                   	pop    %esi
  8100f2:	5d                   	pop    %ebp
  8100f3:	c3                   	ret    

008100f4 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  8100f4:	55                   	push   %ebp
  8100f5:	89 e5                	mov    %esp,%ebp
  8100f7:	53                   	push   %ebx
  8100f8:	83 ec 04             	sub    $0x4,%esp
  8100fb:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  8100fe:	8b 45 08             	mov    0x8(%ebp),%eax
  810101:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  810106:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  81010c:	7e 16                	jle    810124 <nsipc_send+0x30>
  81010e:	68 0b 38 81 00       	push   $0x81380b
  810113:	68 5f 24 81 00       	push   $0x81245f
  810118:	6a 6d                	push   $0x6d
  81011a:	68 ff 37 81 00       	push   $0x8137ff
  81011f:	e8 bd e2 ff ff       	call   80e3e1 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  810124:	83 ec 04             	sub    $0x4,%esp
  810127:	53                   	push   %ebx
  810128:	ff 75 0c             	pushl  0xc(%ebp)
  81012b:	68 0c d0 b3 00       	push   $0xb3d00c
  810130:	e8 9e ea ff ff       	call   80ebd3 <memmove>
	nsipcbuf.send.req_size = size;
  810135:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  81013b:	8b 45 14             	mov    0x14(%ebp),%eax
  81013e:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  810143:	b8 08 00 00 00       	mov    $0x8,%eax
  810148:	e8 d9 fd ff ff       	call   80ff26 <nsipc>
}
  81014d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810150:	c9                   	leave  
  810151:	c3                   	ret    

00810152 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810152:	55                   	push   %ebp
  810153:	89 e5                	mov    %esp,%ebp
  810155:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810158:	8b 45 08             	mov    0x8(%ebp),%eax
  81015b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  810160:	8b 45 0c             	mov    0xc(%ebp),%eax
  810163:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  810168:	8b 45 10             	mov    0x10(%ebp),%eax
  81016b:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  810170:	b8 09 00 00 00       	mov    $0x9,%eax
  810175:	e8 ac fd ff ff       	call   80ff26 <nsipc>
}
  81017a:	c9                   	leave  
  81017b:	c3                   	ret    

0081017c <free>:
	return v;
}

void
free(void *v)
{
  81017c:	55                   	push   %ebp
  81017d:	89 e5                	mov    %esp,%ebp
  81017f:	53                   	push   %ebx
  810180:	83 ec 04             	sub    $0x4,%esp
  810183:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810186:	85 db                	test   %ebx,%ebx
  810188:	0f 84 97 00 00 00    	je     810225 <free+0xa9>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81018e:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810194:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810199:	76 16                	jbe    8101b1 <free+0x35>
  81019b:	68 18 38 81 00       	push   $0x813818
  8101a0:	68 5f 24 81 00       	push   $0x81245f
  8101a5:	6a 7a                	push   $0x7a
  8101a7:	68 46 38 81 00       	push   $0x813846
  8101ac:	e8 30 e2 ff ff       	call   80e3e1 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  8101b1:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8101b7:	eb 3a                	jmp    8101f3 <free+0x77>
		sys_page_unmap(0, c);
  8101b9:	83 ec 08             	sub    $0x8,%esp
  8101bc:	53                   	push   %ebx
  8101bd:	6a 00                	push   $0x0
  8101bf:	e8 0b ed ff ff       	call   80eecf <sys_page_unmap>
		c += PGSIZE;
  8101c4:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  8101ca:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
		assert(mbegin <= c && c < mend);
  8101d0:	83 c4 10             	add    $0x10,%esp
  8101d3:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8101d8:	76 19                	jbe    8101f3 <free+0x77>
  8101da:	68 53 38 81 00       	push   $0x813853
  8101df:	68 5f 24 81 00       	push   $0x81245f
  8101e4:	68 81 00 00 00       	push   $0x81
  8101e9:	68 46 38 81 00       	push   $0x813846
  8101ee:	e8 ee e1 ff ff       	call   80e3e1 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8101f3:	89 d8                	mov    %ebx,%eax
  8101f5:	c1 e8 0c             	shr    $0xc,%eax
  8101f8:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8101ff:	f6 c4 02             	test   $0x2,%ah
  810202:	75 b5                	jne    8101b9 <free+0x3d>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  810204:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  81020a:	83 e8 01             	sub    $0x1,%eax
  81020d:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810213:	85 c0                	test   %eax,%eax
  810215:	75 0e                	jne    810225 <free+0xa9>
		sys_page_unmap(0, c);
  810217:	83 ec 08             	sub    $0x8,%esp
  81021a:	53                   	push   %ebx
  81021b:	6a 00                	push   $0x0
  81021d:	e8 ad ec ff ff       	call   80eecf <sys_page_unmap>
  810222:	83 c4 10             	add    $0x10,%esp
}
  810225:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810228:	c9                   	leave  
  810229:	c3                   	ret    

0081022a <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  81022a:	55                   	push   %ebp
  81022b:	89 e5                	mov    %esp,%ebp
  81022d:	57                   	push   %edi
  81022e:	56                   	push   %esi
  81022f:	53                   	push   %ebx
  810230:	83 ec 1c             	sub    $0x1c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  810233:	a1 14 b3 b3 00       	mov    0xb3b314,%eax
  810238:	85 c0                	test   %eax,%eax
  81023a:	75 22                	jne    81025e <malloc+0x34>
		mptr = mbegin;
  81023c:	c7 05 14 b3 b3 00 00 	movl   $0x8000000,0xb3b314
  810243:	00 00 08 

	n = ROUNDUP(n, 4);
  810246:	8b 45 08             	mov    0x8(%ebp),%eax
  810249:	83 c0 03             	add    $0x3,%eax
  81024c:	83 e0 fc             	and    $0xfffffffc,%eax
  81024f:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (n >= MAXMALLOC)
  810252:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  810257:	76 75                	jbe    8102ce <malloc+0xa4>
  810259:	e9 77 01 00 00       	jmp    8103d5 <malloc+0x1ab>
	void *v;

	if (mptr == 0)
		mptr = mbegin;

	n = ROUNDUP(n, 4);
  81025e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810261:	8d 53 03             	lea    0x3(%ebx),%edx
  810264:	83 e2 fc             	and    $0xfffffffc,%edx
  810267:	89 55 e0             	mov    %edx,-0x20(%ebp)

	if (n >= MAXMALLOC)
  81026a:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810270:	0f 87 66 01 00 00    	ja     8103dc <malloc+0x1b2>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  810276:	a9 ff 0f 00 00       	test   $0xfff,%eax
  81027b:	74 51                	je     8102ce <malloc+0xa4>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81027d:	89 c1                	mov    %eax,%ecx
  81027f:	c1 e9 0c             	shr    $0xc,%ecx
  810282:	89 d3                	mov    %edx,%ebx
  810284:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810288:	c1 ea 0c             	shr    $0xc,%edx
  81028b:	39 d1                	cmp    %edx,%ecx
  81028d:	75 1f                	jne    8102ae <malloc+0x84>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  81028f:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  810295:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  81029b:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  81029f:	89 da                	mov    %ebx,%edx
  8102a1:	01 c2                	add    %eax,%edx
  8102a3:	89 15 14 b3 b3 00    	mov    %edx,0xb3b314
			return v;
  8102a9:	e9 33 01 00 00       	jmp    8103e1 <malloc+0x1b7>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  8102ae:	83 ec 0c             	sub    $0xc,%esp
  8102b1:	50                   	push   %eax
  8102b2:	e8 c5 fe ff ff       	call   81017c <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8102b7:	a1 14 b3 b3 00       	mov    0xb3b314,%eax
  8102bc:	05 00 10 00 00       	add    $0x1000,%eax
  8102c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8102c6:	a3 14 b3 b3 00       	mov    %eax,0xb3b314
  8102cb:	83 c4 10             	add    $0x10,%esp
  8102ce:	8b 35 14 b3 b3 00    	mov    0xb3b314,%esi
	return 1;
}

void*
malloc(size_t n)
{
  8102d4:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  8102db:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8102de:	8d 78 04             	lea    0x4(%eax),%edi
  8102e1:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  8102e4:	89 fb                	mov    %edi,%ebx
  8102e6:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8102e9:	89 f0                	mov    %esi,%eax
  8102eb:	eb 2e                	jmp    81031b <malloc+0xf1>
		if (va >= (uintptr_t) mend
  8102ed:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8102f2:	77 30                	ja     810324 <malloc+0xfa>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8102f4:	89 c2                	mov    %eax,%edx
  8102f6:	c1 ea 16             	shr    $0x16,%edx
  8102f9:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  810300:	f6 c2 01             	test   $0x1,%dl
  810303:	74 11                	je     810316 <malloc+0xec>
  810305:	89 c2                	mov    %eax,%edx
  810307:	c1 ea 0c             	shr    $0xc,%edx
  81030a:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810311:	f6 c2 01             	test   $0x1,%dl
  810314:	75 0e                	jne    810324 <malloc+0xfa>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810316:	05 00 10 00 00       	add    $0x1000,%eax
  81031b:	39 c8                	cmp    %ecx,%eax
  81031d:	72 ce                	jb     8102ed <malloc+0xc3>
  81031f:	e9 84 00 00 00       	jmp    8103a8 <malloc+0x17e>
  810324:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  81032a:	89 c6                	mov    %eax,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  81032c:	3d 00 00 00 10       	cmp    $0x10000000,%eax
  810331:	75 ae                	jne    8102e1 <malloc+0xb7>
			mptr = mbegin;
  810333:	be 00 00 00 08       	mov    $0x8000000,%esi
			if (++nwrap == 2)
  810338:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
  81033c:	75 a3                	jne    8102e1 <malloc+0xb7>
  81033e:	c7 05 14 b3 b3 00 00 	movl   $0x8000000,0xb3b314
  810345:	00 00 08 
				return 0;	/* out of address space */
  810348:	b8 00 00 00 00       	mov    $0x0,%eax
  81034d:	e9 8f 00 00 00       	jmp    8103e1 <malloc+0x1b7>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810352:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  810358:	39 df                	cmp    %ebx,%edi
  81035a:	19 c0                	sbb    %eax,%eax
  81035c:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810361:	83 ec 04             	sub    $0x4,%esp
  810364:	83 c8 07             	or     $0x7,%eax
  810367:	50                   	push   %eax
  810368:	03 15 14 b3 b3 00    	add    0xb3b314,%edx
  81036e:	52                   	push   %edx
  81036f:	6a 00                	push   $0x0
  810371:	e8 d4 ea ff ff       	call   80ee4a <sys_page_alloc>
  810376:	83 c4 10             	add    $0x10,%esp
  810379:	85 c0                	test   %eax,%eax
  81037b:	78 20                	js     81039d <malloc+0x173>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  81037d:	89 fe                	mov    %edi,%esi
  81037f:	eb 34                	jmp    8103b5 <malloc+0x18b>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  810381:	83 ec 08             	sub    $0x8,%esp
  810384:	89 f0                	mov    %esi,%eax
  810386:	03 05 14 b3 b3 00    	add    0xb3b314,%eax
  81038c:	50                   	push   %eax
  81038d:	6a 00                	push   $0x0
  81038f:	e8 3b eb ff ff       	call   80eecf <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  810394:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  81039a:	83 c4 10             	add    $0x10,%esp
  81039d:	85 f6                	test   %esi,%esi
  81039f:	79 e0                	jns    810381 <malloc+0x157>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  8103a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8103a6:	eb 39                	jmp    8103e1 <malloc+0x1b7>
  8103a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8103ab:	a3 14 b3 b3 00       	mov    %eax,0xb3b314
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8103b0:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8103b5:	89 f2                	mov    %esi,%edx
  8103b7:	39 f3                	cmp    %esi,%ebx
  8103b9:	77 97                	ja     810352 <malloc+0x128>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  8103bb:	a1 14 b3 b3 00       	mov    0xb3b314,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  8103c0:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  8103c7:	00 
	v = mptr;
	mptr += n;
  8103c8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8103cb:	01 c2                	add    %eax,%edx
  8103cd:	89 15 14 b3 b3 00    	mov    %edx,0xb3b314
	return v;
  8103d3:	eb 0c                	jmp    8103e1 <malloc+0x1b7>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  8103d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8103da:	eb 05                	jmp    8103e1 <malloc+0x1b7>
  8103dc:	b8 00 00 00 00       	mov    $0x0,%eax
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  8103e1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8103e4:	5b                   	pop    %ebx
  8103e5:	5e                   	pop    %esi
  8103e6:	5f                   	pop    %edi
  8103e7:	5d                   	pop    %ebp
  8103e8:	c3                   	ret    

008103e9 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8103e9:	55                   	push   %ebp
  8103ea:	89 e5                	mov    %esp,%ebp
  8103ec:	56                   	push   %esi
  8103ed:	53                   	push   %ebx
  8103ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8103f1:	83 ec 0c             	sub    $0xc,%esp
  8103f4:	ff 75 08             	pushl  0x8(%ebp)
  8103f7:	e8 e9 f0 ff ff       	call   80f4e5 <fd2data>
  8103fc:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  8103fe:	83 c4 08             	add    $0x8,%esp
  810401:	68 6b 38 81 00       	push   $0x81386b
  810406:	53                   	push   %ebx
  810407:	e8 35 e6 ff ff       	call   80ea41 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  81040c:	8b 56 04             	mov    0x4(%esi),%edx
  81040f:	89 d0                	mov    %edx,%eax
  810411:	2b 06                	sub    (%esi),%eax
  810413:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810419:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810420:	00 00 00 
	stat->st_dev = &devpipe;
  810423:	c7 83 88 00 00 00 44 	movl   $0x814344,0x88(%ebx)
  81042a:	43 81 00 
	return 0;
}
  81042d:	b8 00 00 00 00       	mov    $0x0,%eax
  810432:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810435:	5b                   	pop    %ebx
  810436:	5e                   	pop    %esi
  810437:	5d                   	pop    %ebp
  810438:	c3                   	ret    

00810439 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810439:	55                   	push   %ebp
  81043a:	89 e5                	mov    %esp,%ebp
  81043c:	53                   	push   %ebx
  81043d:	83 ec 0c             	sub    $0xc,%esp
  810440:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810443:	53                   	push   %ebx
  810444:	6a 00                	push   $0x0
  810446:	e8 84 ea ff ff       	call   80eecf <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  81044b:	89 1c 24             	mov    %ebx,(%esp)
  81044e:	e8 92 f0 ff ff       	call   80f4e5 <fd2data>
  810453:	83 c4 08             	add    $0x8,%esp
  810456:	50                   	push   %eax
  810457:	6a 00                	push   $0x0
  810459:	e8 71 ea ff ff       	call   80eecf <sys_page_unmap>
}
  81045e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810461:	c9                   	leave  
  810462:	c3                   	ret    

00810463 <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  810463:	55                   	push   %ebp
  810464:	89 e5                	mov    %esp,%ebp
  810466:	57                   	push   %edi
  810467:	56                   	push   %esi
  810468:	53                   	push   %ebx
  810469:	83 ec 1c             	sub    $0x1c,%esp
  81046c:	89 c6                	mov    %eax,%esi
  81046e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  810471:	a1 9c b3 b3 00       	mov    0xb3b39c,%eax
  810476:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  810479:	83 ec 0c             	sub    $0xc,%esp
  81047c:	56                   	push   %esi
  81047d:	e8 d6 04 00 00       	call   810958 <pageref>
  810482:	89 c7                	mov    %eax,%edi
  810484:	83 c4 04             	add    $0x4,%esp
  810487:	ff 75 e4             	pushl  -0x1c(%ebp)
  81048a:	e8 c9 04 00 00       	call   810958 <pageref>
  81048f:	83 c4 10             	add    $0x10,%esp
  810492:	39 c7                	cmp    %eax,%edi
  810494:	0f 94 c2             	sete   %dl
  810497:	0f b6 c2             	movzbl %dl,%eax
		nn = thisenv->env_runs;
  81049a:	8b 0d 9c b3 b3 00    	mov    0xb3b39c,%ecx
  8104a0:	8b 79 58             	mov    0x58(%ecx),%edi
		if (n == nn)
  8104a3:	39 fb                	cmp    %edi,%ebx
  8104a5:	74 19                	je     8104c0 <_pipeisclosed+0x5d>
			return ret;
		if (n != nn && ret == 1)
  8104a7:	84 d2                	test   %dl,%dl
  8104a9:	74 c6                	je     810471 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  8104ab:	8b 51 58             	mov    0x58(%ecx),%edx
  8104ae:	50                   	push   %eax
  8104af:	52                   	push   %edx
  8104b0:	53                   	push   %ebx
  8104b1:	68 72 38 81 00       	push   $0x813872
  8104b6:	e8 ff df ff ff       	call   80e4ba <cprintf>
  8104bb:	83 c4 10             	add    $0x10,%esp
  8104be:	eb b1                	jmp    810471 <_pipeisclosed+0xe>
	}
}
  8104c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8104c3:	5b                   	pop    %ebx
  8104c4:	5e                   	pop    %esi
  8104c5:	5f                   	pop    %edi
  8104c6:	5d                   	pop    %ebp
  8104c7:	c3                   	ret    

008104c8 <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8104c8:	55                   	push   %ebp
  8104c9:	89 e5                	mov    %esp,%ebp
  8104cb:	57                   	push   %edi
  8104cc:	56                   	push   %esi
  8104cd:	53                   	push   %ebx
  8104ce:	83 ec 28             	sub    $0x28,%esp
  8104d1:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8104d4:	56                   	push   %esi
  8104d5:	e8 0b f0 ff ff       	call   80f4e5 <fd2data>
  8104da:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8104dc:	83 c4 10             	add    $0x10,%esp
  8104df:	bf 00 00 00 00       	mov    $0x0,%edi
  8104e4:	eb 4b                	jmp    810531 <devpipe_write+0x69>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8104e6:	89 da                	mov    %ebx,%edx
  8104e8:	89 f0                	mov    %esi,%eax
  8104ea:	e8 74 ff ff ff       	call   810463 <_pipeisclosed>
  8104ef:	85 c0                	test   %eax,%eax
  8104f1:	75 48                	jne    81053b <devpipe_write+0x73>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  8104f3:	e8 33 e9 ff ff       	call   80ee2b <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  8104f8:	8b 43 04             	mov    0x4(%ebx),%eax
  8104fb:	8b 0b                	mov    (%ebx),%ecx
  8104fd:	8d 51 20             	lea    0x20(%ecx),%edx
  810500:	39 d0                	cmp    %edx,%eax
  810502:	73 e2                	jae    8104e6 <devpipe_write+0x1e>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810504:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810507:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  81050b:	88 4d e7             	mov    %cl,-0x19(%ebp)
  81050e:	89 c2                	mov    %eax,%edx
  810510:	c1 fa 1f             	sar    $0x1f,%edx
  810513:	89 d1                	mov    %edx,%ecx
  810515:	c1 e9 1b             	shr    $0x1b,%ecx
  810518:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  81051b:	83 e2 1f             	and    $0x1f,%edx
  81051e:	29 ca                	sub    %ecx,%edx
  810520:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810524:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810528:	83 c0 01             	add    $0x1,%eax
  81052b:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81052e:	83 c7 01             	add    $0x1,%edi
  810531:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810534:	75 c2                	jne    8104f8 <devpipe_write+0x30>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  810536:	8b 45 10             	mov    0x10(%ebp),%eax
  810539:	eb 05                	jmp    810540 <devpipe_write+0x78>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81053b:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  810540:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810543:	5b                   	pop    %ebx
  810544:	5e                   	pop    %esi
  810545:	5f                   	pop    %edi
  810546:	5d                   	pop    %ebp
  810547:	c3                   	ret    

00810548 <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  810548:	55                   	push   %ebp
  810549:	89 e5                	mov    %esp,%ebp
  81054b:	57                   	push   %edi
  81054c:	56                   	push   %esi
  81054d:	53                   	push   %ebx
  81054e:	83 ec 18             	sub    $0x18,%esp
  810551:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  810554:	57                   	push   %edi
  810555:	e8 8b ef ff ff       	call   80f4e5 <fd2data>
  81055a:	89 c6                	mov    %eax,%esi
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81055c:	83 c4 10             	add    $0x10,%esp
  81055f:	bb 00 00 00 00       	mov    $0x0,%ebx
  810564:	eb 3d                	jmp    8105a3 <devpipe_read+0x5b>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  810566:	85 db                	test   %ebx,%ebx
  810568:	74 04                	je     81056e <devpipe_read+0x26>
				return i;
  81056a:	89 d8                	mov    %ebx,%eax
  81056c:	eb 44                	jmp    8105b2 <devpipe_read+0x6a>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  81056e:	89 f2                	mov    %esi,%edx
  810570:	89 f8                	mov    %edi,%eax
  810572:	e8 ec fe ff ff       	call   810463 <_pipeisclosed>
  810577:	85 c0                	test   %eax,%eax
  810579:	75 32                	jne    8105ad <devpipe_read+0x65>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  81057b:	e8 ab e8 ff ff       	call   80ee2b <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  810580:	8b 06                	mov    (%esi),%eax
  810582:	3b 46 04             	cmp    0x4(%esi),%eax
  810585:	74 df                	je     810566 <devpipe_read+0x1e>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810587:	99                   	cltd   
  810588:	c1 ea 1b             	shr    $0x1b,%edx
  81058b:	01 d0                	add    %edx,%eax
  81058d:	83 e0 1f             	and    $0x1f,%eax
  810590:	29 d0                	sub    %edx,%eax
  810592:	0f b6 44 06 08       	movzbl 0x8(%esi,%eax,1),%eax
  810597:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81059a:	88 04 19             	mov    %al,(%ecx,%ebx,1)
		p->p_rpos++;
  81059d:	83 06 01             	addl   $0x1,(%esi)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8105a0:	83 c3 01             	add    $0x1,%ebx
  8105a3:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  8105a6:	75 d8                	jne    810580 <devpipe_read+0x38>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8105a8:	8b 45 10             	mov    0x10(%ebp),%eax
  8105ab:	eb 05                	jmp    8105b2 <devpipe_read+0x6a>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  8105ad:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  8105b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8105b5:	5b                   	pop    %ebx
  8105b6:	5e                   	pop    %esi
  8105b7:	5f                   	pop    %edi
  8105b8:	5d                   	pop    %ebp
  8105b9:	c3                   	ret    

008105ba <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  8105ba:	55                   	push   %ebp
  8105bb:	89 e5                	mov    %esp,%ebp
  8105bd:	56                   	push   %esi
  8105be:	53                   	push   %ebx
  8105bf:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  8105c2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8105c5:	50                   	push   %eax
  8105c6:	e8 31 ef ff ff       	call   80f4fc <fd_alloc>
  8105cb:	83 c4 10             	add    $0x10,%esp
  8105ce:	89 c2                	mov    %eax,%edx
  8105d0:	85 c0                	test   %eax,%eax
  8105d2:	0f 88 2c 01 00 00    	js     810704 <pipe+0x14a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8105d8:	83 ec 04             	sub    $0x4,%esp
  8105db:	68 07 04 00 00       	push   $0x407
  8105e0:	ff 75 f4             	pushl  -0xc(%ebp)
  8105e3:	6a 00                	push   $0x0
  8105e5:	e8 60 e8 ff ff       	call   80ee4a <sys_page_alloc>
  8105ea:	83 c4 10             	add    $0x10,%esp
  8105ed:	89 c2                	mov    %eax,%edx
  8105ef:	85 c0                	test   %eax,%eax
  8105f1:	0f 88 0d 01 00 00    	js     810704 <pipe+0x14a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8105f7:	83 ec 0c             	sub    $0xc,%esp
  8105fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8105fd:	50                   	push   %eax
  8105fe:	e8 f9 ee ff ff       	call   80f4fc <fd_alloc>
  810603:	89 c3                	mov    %eax,%ebx
  810605:	83 c4 10             	add    $0x10,%esp
  810608:	85 c0                	test   %eax,%eax
  81060a:	0f 88 e2 00 00 00    	js     8106f2 <pipe+0x138>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810610:	83 ec 04             	sub    $0x4,%esp
  810613:	68 07 04 00 00       	push   $0x407
  810618:	ff 75 f0             	pushl  -0x10(%ebp)
  81061b:	6a 00                	push   $0x0
  81061d:	e8 28 e8 ff ff       	call   80ee4a <sys_page_alloc>
  810622:	89 c3                	mov    %eax,%ebx
  810624:	83 c4 10             	add    $0x10,%esp
  810627:	85 c0                	test   %eax,%eax
  810629:	0f 88 c3 00 00 00    	js     8106f2 <pipe+0x138>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  81062f:	83 ec 0c             	sub    $0xc,%esp
  810632:	ff 75 f4             	pushl  -0xc(%ebp)
  810635:	e8 ab ee ff ff       	call   80f4e5 <fd2data>
  81063a:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81063c:	83 c4 0c             	add    $0xc,%esp
  81063f:	68 07 04 00 00       	push   $0x407
  810644:	50                   	push   %eax
  810645:	6a 00                	push   $0x0
  810647:	e8 fe e7 ff ff       	call   80ee4a <sys_page_alloc>
  81064c:	89 c3                	mov    %eax,%ebx
  81064e:	83 c4 10             	add    $0x10,%esp
  810651:	85 c0                	test   %eax,%eax
  810653:	0f 88 89 00 00 00    	js     8106e2 <pipe+0x128>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810659:	83 ec 0c             	sub    $0xc,%esp
  81065c:	ff 75 f0             	pushl  -0x10(%ebp)
  81065f:	e8 81 ee ff ff       	call   80f4e5 <fd2data>
  810664:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  81066b:	50                   	push   %eax
  81066c:	6a 00                	push   $0x0
  81066e:	56                   	push   %esi
  81066f:	6a 00                	push   $0x0
  810671:	e8 17 e8 ff ff       	call   80ee8d <sys_page_map>
  810676:	89 c3                	mov    %eax,%ebx
  810678:	83 c4 20             	add    $0x20,%esp
  81067b:	85 c0                	test   %eax,%eax
  81067d:	78 55                	js     8106d4 <pipe+0x11a>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  81067f:	8b 15 44 43 81 00    	mov    0x814344,%edx
  810685:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810688:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  81068a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81068d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  810694:	8b 15 44 43 81 00    	mov    0x814344,%edx
  81069a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81069d:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  81069f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8106a2:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  8106a9:	83 ec 0c             	sub    $0xc,%esp
  8106ac:	ff 75 f4             	pushl  -0xc(%ebp)
  8106af:	e8 21 ee ff ff       	call   80f4d5 <fd2num>
  8106b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8106b7:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  8106b9:	83 c4 04             	add    $0x4,%esp
  8106bc:	ff 75 f0             	pushl  -0x10(%ebp)
  8106bf:	e8 11 ee ff ff       	call   80f4d5 <fd2num>
  8106c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8106c7:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  8106ca:	83 c4 10             	add    $0x10,%esp
  8106cd:	ba 00 00 00 00       	mov    $0x0,%edx
  8106d2:	eb 30                	jmp    810704 <pipe+0x14a>

    err3:
	sys_page_unmap(0, va);
  8106d4:	83 ec 08             	sub    $0x8,%esp
  8106d7:	56                   	push   %esi
  8106d8:	6a 00                	push   $0x0
  8106da:	e8 f0 e7 ff ff       	call   80eecf <sys_page_unmap>
  8106df:	83 c4 10             	add    $0x10,%esp
    err2:
	sys_page_unmap(0, fd1);
  8106e2:	83 ec 08             	sub    $0x8,%esp
  8106e5:	ff 75 f0             	pushl  -0x10(%ebp)
  8106e8:	6a 00                	push   $0x0
  8106ea:	e8 e0 e7 ff ff       	call   80eecf <sys_page_unmap>
  8106ef:	83 c4 10             	add    $0x10,%esp
    err1:
	sys_page_unmap(0, fd0);
  8106f2:	83 ec 08             	sub    $0x8,%esp
  8106f5:	ff 75 f4             	pushl  -0xc(%ebp)
  8106f8:	6a 00                	push   $0x0
  8106fa:	e8 d0 e7 ff ff       	call   80eecf <sys_page_unmap>
  8106ff:	83 c4 10             	add    $0x10,%esp
  810702:	89 da                	mov    %ebx,%edx
    err:
	return r;
}
  810704:	89 d0                	mov    %edx,%eax
  810706:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810709:	5b                   	pop    %ebx
  81070a:	5e                   	pop    %esi
  81070b:	5d                   	pop    %ebp
  81070c:	c3                   	ret    

0081070d <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  81070d:	55                   	push   %ebp
  81070e:	89 e5                	mov    %esp,%ebp
  810710:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810713:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810716:	50                   	push   %eax
  810717:	ff 75 08             	pushl  0x8(%ebp)
  81071a:	e8 2c ee ff ff       	call   80f54b <fd_lookup>
  81071f:	89 c2                	mov    %eax,%edx
  810721:	83 c4 10             	add    $0x10,%esp
  810724:	85 d2                	test   %edx,%edx
  810726:	78 18                	js     810740 <pipeisclosed+0x33>
		return r;
	p = (struct Pipe*) fd2data(fd);
  810728:	83 ec 0c             	sub    $0xc,%esp
  81072b:	ff 75 f4             	pushl  -0xc(%ebp)
  81072e:	e8 b2 ed ff ff       	call   80f4e5 <fd2data>
	return _pipeisclosed(fd, p);
  810733:	89 c2                	mov    %eax,%edx
  810735:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810738:	e8 26 fd ff ff       	call   810463 <_pipeisclosed>
  81073d:	83 c4 10             	add    $0x10,%esp
}
  810740:	c9                   	leave  
  810741:	c3                   	ret    

00810742 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810742:	55                   	push   %ebp
  810743:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  810745:	b8 00 00 00 00       	mov    $0x0,%eax
  81074a:	5d                   	pop    %ebp
  81074b:	c3                   	ret    

0081074c <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  81074c:	55                   	push   %ebp
  81074d:	89 e5                	mov    %esp,%ebp
  81074f:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810752:	68 8a 38 81 00       	push   $0x81388a
  810757:	ff 75 0c             	pushl  0xc(%ebp)
  81075a:	e8 e2 e2 ff ff       	call   80ea41 <strcpy>
	return 0;
}
  81075f:	b8 00 00 00 00       	mov    $0x0,%eax
  810764:	c9                   	leave  
  810765:	c3                   	ret    

00810766 <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  810766:	55                   	push   %ebp
  810767:	89 e5                	mov    %esp,%ebp
  810769:	57                   	push   %edi
  81076a:	56                   	push   %esi
  81076b:	53                   	push   %ebx
  81076c:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  810772:	be 00 00 00 00       	mov    $0x0,%esi
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  810777:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  81077d:	eb 2d                	jmp    8107ac <devcons_write+0x46>
		m = n - tot;
  81077f:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810782:	29 f3                	sub    %esi,%ebx
		if (m > sizeof(buf) - 1)
  810784:	83 fb 7f             	cmp    $0x7f,%ebx
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  810787:	ba 7f 00 00 00       	mov    $0x7f,%edx
  81078c:	0f 47 da             	cmova  %edx,%ebx
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  81078f:	83 ec 04             	sub    $0x4,%esp
  810792:	53                   	push   %ebx
  810793:	03 45 0c             	add    0xc(%ebp),%eax
  810796:	50                   	push   %eax
  810797:	57                   	push   %edi
  810798:	e8 36 e4 ff ff       	call   80ebd3 <memmove>
		sys_cputs(buf, m);
  81079d:	83 c4 08             	add    $0x8,%esp
  8107a0:	53                   	push   %ebx
  8107a1:	57                   	push   %edi
  8107a2:	e8 e7 e5 ff ff       	call   80ed8e <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8107a7:	01 de                	add    %ebx,%esi
  8107a9:	83 c4 10             	add    $0x10,%esp
  8107ac:	89 f0                	mov    %esi,%eax
  8107ae:	3b 75 10             	cmp    0x10(%ebp),%esi
  8107b1:	72 cc                	jb     81077f <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  8107b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8107b6:	5b                   	pop    %ebx
  8107b7:	5e                   	pop    %esi
  8107b8:	5f                   	pop    %edi
  8107b9:	5d                   	pop    %ebp
  8107ba:	c3                   	ret    

008107bb <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8107bb:	55                   	push   %ebp
  8107bc:	89 e5                	mov    %esp,%ebp
  8107be:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
		return 0;
  8107c1:	b8 00 00 00 00       	mov    $0x0,%eax
static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
	int c;

	if (n == 0)
  8107c6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8107ca:	75 07                	jne    8107d3 <devcons_read+0x18>
  8107cc:	eb 28                	jmp    8107f6 <devcons_read+0x3b>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8107ce:	e8 58 e6 ff ff       	call   80ee2b <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8107d3:	e8 d4 e5 ff ff       	call   80edac <sys_cgetc>
  8107d8:	85 c0                	test   %eax,%eax
  8107da:	74 f2                	je     8107ce <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  8107dc:	85 c0                	test   %eax,%eax
  8107de:	78 16                	js     8107f6 <devcons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
  8107e0:	83 f8 04             	cmp    $0x4,%eax
  8107e3:	74 0c                	je     8107f1 <devcons_read+0x36>
		return 0;
	*(char*)vbuf = c;
  8107e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8107e8:	88 02                	mov    %al,(%edx)
	return 1;
  8107ea:	b8 01 00 00 00       	mov    $0x1,%eax
  8107ef:	eb 05                	jmp    8107f6 <devcons_read+0x3b>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  8107f1:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  8107f6:	c9                   	leave  
  8107f7:	c3                   	ret    

008107f8 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  8107f8:	55                   	push   %ebp
  8107f9:	89 e5                	mov    %esp,%ebp
  8107fb:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  8107fe:	8b 45 08             	mov    0x8(%ebp),%eax
  810801:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  810804:	6a 01                	push   $0x1
  810806:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810809:	50                   	push   %eax
  81080a:	e8 7f e5 ff ff       	call   80ed8e <sys_cputs>
  81080f:	83 c4 10             	add    $0x10,%esp
}
  810812:	c9                   	leave  
  810813:	c3                   	ret    

00810814 <getchar>:

int
getchar(void)
{
  810814:	55                   	push   %ebp
  810815:	89 e5                	mov    %esp,%ebp
  810817:	83 ec 1c             	sub    $0x1c,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  81081a:	6a 01                	push   $0x1
  81081c:	8d 45 f7             	lea    -0x9(%ebp),%eax
  81081f:	50                   	push   %eax
  810820:	6a 00                	push   $0x0
  810822:	e8 93 ef ff ff       	call   80f7ba <read>
	if (r < 0)
  810827:	83 c4 10             	add    $0x10,%esp
  81082a:	85 c0                	test   %eax,%eax
  81082c:	78 0f                	js     81083d <getchar+0x29>
		return r;
	if (r < 1)
  81082e:	85 c0                	test   %eax,%eax
  810830:	7e 06                	jle    810838 <getchar+0x24>
		return -E_EOF;
	return c;
  810832:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  810836:	eb 05                	jmp    81083d <getchar+0x29>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  810838:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  81083d:	c9                   	leave  
  81083e:	c3                   	ret    

0081083f <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  81083f:	55                   	push   %ebp
  810840:	89 e5                	mov    %esp,%ebp
  810842:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810845:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810848:	50                   	push   %eax
  810849:	ff 75 08             	pushl  0x8(%ebp)
  81084c:	e8 fa ec ff ff       	call   80f54b <fd_lookup>
  810851:	83 c4 10             	add    $0x10,%esp
  810854:	85 c0                	test   %eax,%eax
  810856:	78 11                	js     810869 <iscons+0x2a>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  810858:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81085b:	8b 15 60 43 81 00    	mov    0x814360,%edx
  810861:	39 10                	cmp    %edx,(%eax)
  810863:	0f 94 c0             	sete   %al
  810866:	0f b6 c0             	movzbl %al,%eax
}
  810869:	c9                   	leave  
  81086a:	c3                   	ret    

0081086b <opencons>:

int
opencons(void)
{
  81086b:	55                   	push   %ebp
  81086c:	89 e5                	mov    %esp,%ebp
  81086e:	83 ec 24             	sub    $0x24,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  810871:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810874:	50                   	push   %eax
  810875:	e8 82 ec ff ff       	call   80f4fc <fd_alloc>
  81087a:	83 c4 10             	add    $0x10,%esp
		return r;
  81087d:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  81087f:	85 c0                	test   %eax,%eax
  810881:	78 3e                	js     8108c1 <opencons+0x56>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810883:	83 ec 04             	sub    $0x4,%esp
  810886:	68 07 04 00 00       	push   $0x407
  81088b:	ff 75 f4             	pushl  -0xc(%ebp)
  81088e:	6a 00                	push   $0x0
  810890:	e8 b5 e5 ff ff       	call   80ee4a <sys_page_alloc>
  810895:	83 c4 10             	add    $0x10,%esp
		return r;
  810898:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  81089a:	85 c0                	test   %eax,%eax
  81089c:	78 23                	js     8108c1 <opencons+0x56>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  81089e:	8b 15 60 43 81 00    	mov    0x814360,%edx
  8108a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8108a7:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  8108a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8108ac:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  8108b3:	83 ec 0c             	sub    $0xc,%esp
  8108b6:	50                   	push   %eax
  8108b7:	e8 19 ec ff ff       	call   80f4d5 <fd2num>
  8108bc:	89 c2                	mov    %eax,%edx
  8108be:	83 c4 10             	add    $0x10,%esp
}
  8108c1:	89 d0                	mov    %edx,%eax
  8108c3:	c9                   	leave  
  8108c4:	c3                   	ret    

008108c5 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  8108c5:	55                   	push   %ebp
  8108c6:	89 e5                	mov    %esp,%ebp
  8108c8:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  8108cb:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  8108d2:	75 2c                	jne    810900 <set_pgfault_handler+0x3b>
		// First time through!
		// LAB 4: Your code here.
              if (sys_page_alloc(0, (void*)(UXSTACKTOP-PGSIZE), PTE_W|PTE_U|PTE_P) != 0) 
  8108d4:	83 ec 04             	sub    $0x4,%esp
  8108d7:	6a 07                	push   $0x7
  8108d9:	68 00 f0 bf ee       	push   $0xeebff000
  8108de:	6a 00                	push   $0x0
  8108e0:	e8 65 e5 ff ff       	call   80ee4a <sys_page_alloc>
  8108e5:	83 c4 10             	add    $0x10,%esp
  8108e8:	85 c0                	test   %eax,%eax
  8108ea:	74 14                	je     810900 <set_pgfault_handler+0x3b>
                    panic("set_pgfault_handler:sys_page_alloc failed");
  8108ec:	83 ec 04             	sub    $0x4,%esp
  8108ef:	68 98 38 81 00       	push   $0x813898
  8108f4:	6a 21                	push   $0x21
  8108f6:	68 fc 38 81 00       	push   $0x8138fc
  8108fb:	e8 e1 da ff ff       	call   80e3e1 <_panic>
   
		//panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810900:	8b 45 08             	mov    0x8(%ebp),%eax
  810903:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
        if (sys_env_set_pgfault_upcall(0, _pgfault_upcall) < 0)
  810908:	83 ec 08             	sub    $0x8,%esp
  81090b:	68 34 09 81 00       	push   $0x810934
  810910:	6a 00                	push   $0x0
  810912:	e8 7e e6 ff ff       	call   80ef95 <sys_env_set_pgfault_upcall>
  810917:	83 c4 10             	add    $0x10,%esp
  81091a:	85 c0                	test   %eax,%eax
  81091c:	79 14                	jns    810932 <set_pgfault_handler+0x6d>
                panic("set_pgfault_handler:sys_env_set_pgfault_upcall failed");
  81091e:	83 ec 04             	sub    $0x4,%esp
  810921:	68 c4 38 81 00       	push   $0x8138c4
  810926:	6a 29                	push   $0x29
  810928:	68 fc 38 81 00       	push   $0x8138fc
  81092d:	e8 af da ff ff       	call   80e3e1 <_panic>
}
  810932:	c9                   	leave  
  810933:	c3                   	ret    

00810934 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810934:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810935:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  81093a:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  81093c:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
        subl $0x4, 0x30(%esp)
  81093f:	83 6c 24 30 04       	subl   $0x4,0x30(%esp)
        movl 0x30(%esp), %eax
  810944:	8b 44 24 30          	mov    0x30(%esp),%eax
        movl 0x28(%esp), %edx
  810948:	8b 54 24 28          	mov    0x28(%esp),%edx
        movl %edx, (%eax)
  81094c:	89 10                	mov    %edx,(%eax)
        
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
        addl $0x8, %esp
  81094e:	83 c4 08             	add    $0x8,%esp
        popal
  810951:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
        addl $0x4, %esp
  810952:	83 c4 04             	add    $0x4,%esp
        popfl
  810955:	9d                   	popf   
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
        pop %esp
  810956:	5c                   	pop    %esp
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
        ret
  810957:	c3                   	ret    

00810958 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810958:	55                   	push   %ebp
  810959:	89 e5                	mov    %esp,%ebp
  81095b:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  81095e:	89 d0                	mov    %edx,%eax
  810960:	c1 e8 16             	shr    $0x16,%eax
  810963:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  81096a:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  81096f:	f6 c1 01             	test   $0x1,%cl
  810972:	74 1d                	je     810991 <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  810974:	c1 ea 0c             	shr    $0xc,%edx
  810977:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  81097e:	f6 c2 01             	test   $0x1,%dl
  810981:	74 0e                	je     810991 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  810983:	c1 ea 0c             	shr    $0xc,%edx
  810986:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  81098d:	ef 
  81098e:	0f b7 c0             	movzwl %ax,%eax
}
  810991:	5d                   	pop    %ebp
  810992:	c3                   	ret    
  810993:	66 90                	xchg   %ax,%ax
  810995:	66 90                	xchg   %ax,%ax
  810997:	66 90                	xchg   %ax,%ax
  810999:	66 90                	xchg   %ax,%ax
  81099b:	66 90                	xchg   %ax,%ax
  81099d:	66 90                	xchg   %ax,%ax
  81099f:	90                   	nop

008109a0 <__udivdi3>:
  8109a0:	55                   	push   %ebp
  8109a1:	57                   	push   %edi
  8109a2:	56                   	push   %esi
  8109a3:	83 ec 10             	sub    $0x10,%esp
  8109a6:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  8109aa:	8b 7c 24 20          	mov    0x20(%esp),%edi
  8109ae:	8b 74 24 24          	mov    0x24(%esp),%esi
  8109b2:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  8109b6:	85 d2                	test   %edx,%edx
  8109b8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8109bc:	89 34 24             	mov    %esi,(%esp)
  8109bf:	89 c8                	mov    %ecx,%eax
  8109c1:	75 35                	jne    8109f8 <__udivdi3+0x58>
  8109c3:	39 f1                	cmp    %esi,%ecx
  8109c5:	0f 87 bd 00 00 00    	ja     810a88 <__udivdi3+0xe8>
  8109cb:	85 c9                	test   %ecx,%ecx
  8109cd:	89 cd                	mov    %ecx,%ebp
  8109cf:	75 0b                	jne    8109dc <__udivdi3+0x3c>
  8109d1:	b8 01 00 00 00       	mov    $0x1,%eax
  8109d6:	31 d2                	xor    %edx,%edx
  8109d8:	f7 f1                	div    %ecx
  8109da:	89 c5                	mov    %eax,%ebp
  8109dc:	89 f0                	mov    %esi,%eax
  8109de:	31 d2                	xor    %edx,%edx
  8109e0:	f7 f5                	div    %ebp
  8109e2:	89 c6                	mov    %eax,%esi
  8109e4:	89 f8                	mov    %edi,%eax
  8109e6:	f7 f5                	div    %ebp
  8109e8:	89 f2                	mov    %esi,%edx
  8109ea:	83 c4 10             	add    $0x10,%esp
  8109ed:	5e                   	pop    %esi
  8109ee:	5f                   	pop    %edi
  8109ef:	5d                   	pop    %ebp
  8109f0:	c3                   	ret    
  8109f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8109f8:	3b 14 24             	cmp    (%esp),%edx
  8109fb:	77 7b                	ja     810a78 <__udivdi3+0xd8>
  8109fd:	0f bd f2             	bsr    %edx,%esi
  810a00:	83 f6 1f             	xor    $0x1f,%esi
  810a03:	0f 84 97 00 00 00    	je     810aa0 <__udivdi3+0x100>
  810a09:	bd 20 00 00 00       	mov    $0x20,%ebp
  810a0e:	89 d7                	mov    %edx,%edi
  810a10:	89 f1                	mov    %esi,%ecx
  810a12:	29 f5                	sub    %esi,%ebp
  810a14:	d3 e7                	shl    %cl,%edi
  810a16:	89 c2                	mov    %eax,%edx
  810a18:	89 e9                	mov    %ebp,%ecx
  810a1a:	d3 ea                	shr    %cl,%edx
  810a1c:	89 f1                	mov    %esi,%ecx
  810a1e:	09 fa                	or     %edi,%edx
  810a20:	8b 3c 24             	mov    (%esp),%edi
  810a23:	d3 e0                	shl    %cl,%eax
  810a25:	89 54 24 08          	mov    %edx,0x8(%esp)
  810a29:	89 e9                	mov    %ebp,%ecx
  810a2b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810a2f:	8b 44 24 04          	mov    0x4(%esp),%eax
  810a33:	89 fa                	mov    %edi,%edx
  810a35:	d3 ea                	shr    %cl,%edx
  810a37:	89 f1                	mov    %esi,%ecx
  810a39:	d3 e7                	shl    %cl,%edi
  810a3b:	89 e9                	mov    %ebp,%ecx
  810a3d:	d3 e8                	shr    %cl,%eax
  810a3f:	09 c7                	or     %eax,%edi
  810a41:	89 f8                	mov    %edi,%eax
  810a43:	f7 74 24 08          	divl   0x8(%esp)
  810a47:	89 d5                	mov    %edx,%ebp
  810a49:	89 c7                	mov    %eax,%edi
  810a4b:	f7 64 24 0c          	mull   0xc(%esp)
  810a4f:	39 d5                	cmp    %edx,%ebp
  810a51:	89 14 24             	mov    %edx,(%esp)
  810a54:	72 11                	jb     810a67 <__udivdi3+0xc7>
  810a56:	8b 54 24 04          	mov    0x4(%esp),%edx
  810a5a:	89 f1                	mov    %esi,%ecx
  810a5c:	d3 e2                	shl    %cl,%edx
  810a5e:	39 c2                	cmp    %eax,%edx
  810a60:	73 5e                	jae    810ac0 <__udivdi3+0x120>
  810a62:	3b 2c 24             	cmp    (%esp),%ebp
  810a65:	75 59                	jne    810ac0 <__udivdi3+0x120>
  810a67:	8d 47 ff             	lea    -0x1(%edi),%eax
  810a6a:	31 f6                	xor    %esi,%esi
  810a6c:	89 f2                	mov    %esi,%edx
  810a6e:	83 c4 10             	add    $0x10,%esp
  810a71:	5e                   	pop    %esi
  810a72:	5f                   	pop    %edi
  810a73:	5d                   	pop    %ebp
  810a74:	c3                   	ret    
  810a75:	8d 76 00             	lea    0x0(%esi),%esi
  810a78:	31 f6                	xor    %esi,%esi
  810a7a:	31 c0                	xor    %eax,%eax
  810a7c:	89 f2                	mov    %esi,%edx
  810a7e:	83 c4 10             	add    $0x10,%esp
  810a81:	5e                   	pop    %esi
  810a82:	5f                   	pop    %edi
  810a83:	5d                   	pop    %ebp
  810a84:	c3                   	ret    
  810a85:	8d 76 00             	lea    0x0(%esi),%esi
  810a88:	89 f2                	mov    %esi,%edx
  810a8a:	31 f6                	xor    %esi,%esi
  810a8c:	89 f8                	mov    %edi,%eax
  810a8e:	f7 f1                	div    %ecx
  810a90:	89 f2                	mov    %esi,%edx
  810a92:	83 c4 10             	add    $0x10,%esp
  810a95:	5e                   	pop    %esi
  810a96:	5f                   	pop    %edi
  810a97:	5d                   	pop    %ebp
  810a98:	c3                   	ret    
  810a99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810aa0:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
  810aa4:	76 0b                	jbe    810ab1 <__udivdi3+0x111>
  810aa6:	31 c0                	xor    %eax,%eax
  810aa8:	3b 14 24             	cmp    (%esp),%edx
  810aab:	0f 83 37 ff ff ff    	jae    8109e8 <__udivdi3+0x48>
  810ab1:	b8 01 00 00 00       	mov    $0x1,%eax
  810ab6:	e9 2d ff ff ff       	jmp    8109e8 <__udivdi3+0x48>
  810abb:	90                   	nop
  810abc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810ac0:	89 f8                	mov    %edi,%eax
  810ac2:	31 f6                	xor    %esi,%esi
  810ac4:	e9 1f ff ff ff       	jmp    8109e8 <__udivdi3+0x48>
  810ac9:	66 90                	xchg   %ax,%ax
  810acb:	66 90                	xchg   %ax,%ax
  810acd:	66 90                	xchg   %ax,%ax
  810acf:	90                   	nop

00810ad0 <__umoddi3>:
  810ad0:	55                   	push   %ebp
  810ad1:	57                   	push   %edi
  810ad2:	56                   	push   %esi
  810ad3:	83 ec 20             	sub    $0x20,%esp
  810ad6:	8b 44 24 34          	mov    0x34(%esp),%eax
  810ada:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  810ade:	8b 7c 24 38          	mov    0x38(%esp),%edi
  810ae2:	89 c6                	mov    %eax,%esi
  810ae4:	89 44 24 10          	mov    %eax,0x10(%esp)
  810ae8:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  810aec:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  810af0:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  810af4:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810af8:	89 74 24 18          	mov    %esi,0x18(%esp)
  810afc:	85 c0                	test   %eax,%eax
  810afe:	89 c2                	mov    %eax,%edx
  810b00:	75 1e                	jne    810b20 <__umoddi3+0x50>
  810b02:	39 f7                	cmp    %esi,%edi
  810b04:	76 52                	jbe    810b58 <__umoddi3+0x88>
  810b06:	89 c8                	mov    %ecx,%eax
  810b08:	89 f2                	mov    %esi,%edx
  810b0a:	f7 f7                	div    %edi
  810b0c:	89 d0                	mov    %edx,%eax
  810b0e:	31 d2                	xor    %edx,%edx
  810b10:	83 c4 20             	add    $0x20,%esp
  810b13:	5e                   	pop    %esi
  810b14:	5f                   	pop    %edi
  810b15:	5d                   	pop    %ebp
  810b16:	c3                   	ret    
  810b17:	89 f6                	mov    %esi,%esi
  810b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  810b20:	39 f0                	cmp    %esi,%eax
  810b22:	77 5c                	ja     810b80 <__umoddi3+0xb0>
  810b24:	0f bd e8             	bsr    %eax,%ebp
  810b27:	83 f5 1f             	xor    $0x1f,%ebp
  810b2a:	75 64                	jne    810b90 <__umoddi3+0xc0>
  810b2c:	8b 6c 24 14          	mov    0x14(%esp),%ebp
  810b30:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
  810b34:	0f 86 f6 00 00 00    	jbe    810c30 <__umoddi3+0x160>
  810b3a:	3b 44 24 18          	cmp    0x18(%esp),%eax
  810b3e:	0f 82 ec 00 00 00    	jb     810c30 <__umoddi3+0x160>
  810b44:	8b 44 24 14          	mov    0x14(%esp),%eax
  810b48:	8b 54 24 18          	mov    0x18(%esp),%edx
  810b4c:	83 c4 20             	add    $0x20,%esp
  810b4f:	5e                   	pop    %esi
  810b50:	5f                   	pop    %edi
  810b51:	5d                   	pop    %ebp
  810b52:	c3                   	ret    
  810b53:	90                   	nop
  810b54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810b58:	85 ff                	test   %edi,%edi
  810b5a:	89 fd                	mov    %edi,%ebp
  810b5c:	75 0b                	jne    810b69 <__umoddi3+0x99>
  810b5e:	b8 01 00 00 00       	mov    $0x1,%eax
  810b63:	31 d2                	xor    %edx,%edx
  810b65:	f7 f7                	div    %edi
  810b67:	89 c5                	mov    %eax,%ebp
  810b69:	8b 44 24 10          	mov    0x10(%esp),%eax
  810b6d:	31 d2                	xor    %edx,%edx
  810b6f:	f7 f5                	div    %ebp
  810b71:	89 c8                	mov    %ecx,%eax
  810b73:	f7 f5                	div    %ebp
  810b75:	eb 95                	jmp    810b0c <__umoddi3+0x3c>
  810b77:	89 f6                	mov    %esi,%esi
  810b79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  810b80:	89 c8                	mov    %ecx,%eax
  810b82:	89 f2                	mov    %esi,%edx
  810b84:	83 c4 20             	add    $0x20,%esp
  810b87:	5e                   	pop    %esi
  810b88:	5f                   	pop    %edi
  810b89:	5d                   	pop    %ebp
  810b8a:	c3                   	ret    
  810b8b:	90                   	nop
  810b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810b90:	b8 20 00 00 00       	mov    $0x20,%eax
  810b95:	89 e9                	mov    %ebp,%ecx
  810b97:	29 e8                	sub    %ebp,%eax
  810b99:	d3 e2                	shl    %cl,%edx
  810b9b:	89 c7                	mov    %eax,%edi
  810b9d:	89 44 24 18          	mov    %eax,0x18(%esp)
  810ba1:	8b 44 24 0c          	mov    0xc(%esp),%eax
  810ba5:	89 f9                	mov    %edi,%ecx
  810ba7:	d3 e8                	shr    %cl,%eax
  810ba9:	89 c1                	mov    %eax,%ecx
  810bab:	8b 44 24 0c          	mov    0xc(%esp),%eax
  810baf:	09 d1                	or     %edx,%ecx
  810bb1:	89 fa                	mov    %edi,%edx
  810bb3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  810bb7:	89 e9                	mov    %ebp,%ecx
  810bb9:	d3 e0                	shl    %cl,%eax
  810bbb:	89 f9                	mov    %edi,%ecx
  810bbd:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810bc1:	89 f0                	mov    %esi,%eax
  810bc3:	d3 e8                	shr    %cl,%eax
  810bc5:	89 e9                	mov    %ebp,%ecx
  810bc7:	89 c7                	mov    %eax,%edi
  810bc9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  810bcd:	d3 e6                	shl    %cl,%esi
  810bcf:	89 d1                	mov    %edx,%ecx
  810bd1:	89 fa                	mov    %edi,%edx
  810bd3:	d3 e8                	shr    %cl,%eax
  810bd5:	89 e9                	mov    %ebp,%ecx
  810bd7:	09 f0                	or     %esi,%eax
  810bd9:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  810bdd:	f7 74 24 10          	divl   0x10(%esp)
  810be1:	d3 e6                	shl    %cl,%esi
  810be3:	89 d1                	mov    %edx,%ecx
  810be5:	f7 64 24 0c          	mull   0xc(%esp)
  810be9:	39 d1                	cmp    %edx,%ecx
  810beb:	89 74 24 14          	mov    %esi,0x14(%esp)
  810bef:	89 d7                	mov    %edx,%edi
  810bf1:	89 c6                	mov    %eax,%esi
  810bf3:	72 0a                	jb     810bff <__umoddi3+0x12f>
  810bf5:	39 44 24 14          	cmp    %eax,0x14(%esp)
  810bf9:	73 10                	jae    810c0b <__umoddi3+0x13b>
  810bfb:	39 d1                	cmp    %edx,%ecx
  810bfd:	75 0c                	jne    810c0b <__umoddi3+0x13b>
  810bff:	89 d7                	mov    %edx,%edi
  810c01:	89 c6                	mov    %eax,%esi
  810c03:	2b 74 24 0c          	sub    0xc(%esp),%esi
  810c07:	1b 7c 24 10          	sbb    0x10(%esp),%edi
  810c0b:	89 ca                	mov    %ecx,%edx
  810c0d:	89 e9                	mov    %ebp,%ecx
  810c0f:	8b 44 24 14          	mov    0x14(%esp),%eax
  810c13:	29 f0                	sub    %esi,%eax
  810c15:	19 fa                	sbb    %edi,%edx
  810c17:	d3 e8                	shr    %cl,%eax
  810c19:	0f b6 4c 24 18       	movzbl 0x18(%esp),%ecx
  810c1e:	89 d7                	mov    %edx,%edi
  810c20:	d3 e7                	shl    %cl,%edi
  810c22:	89 e9                	mov    %ebp,%ecx
  810c24:	09 f8                	or     %edi,%eax
  810c26:	d3 ea                	shr    %cl,%edx
  810c28:	83 c4 20             	add    $0x20,%esp
  810c2b:	5e                   	pop    %esi
  810c2c:	5f                   	pop    %edi
  810c2d:	5d                   	pop    %ebp
  810c2e:	c3                   	ret    
  810c2f:	90                   	nop
  810c30:	8b 74 24 10          	mov    0x10(%esp),%esi
  810c34:	29 f9                	sub    %edi,%ecx
  810c36:	19 c6                	sbb    %eax,%esi
  810c38:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810c3c:	89 74 24 18          	mov    %esi,0x18(%esp)
  810c40:	e9 ff fe ff ff       	jmp    810b44 <__umoddi3+0x74>
